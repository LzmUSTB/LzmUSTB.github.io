[{"title":"my-maya-note","url":"/2025/07/16/my-maya-note/","content":"\n# 注意事项\n\n* 建模中，不允许出现超过四个点组成的面（多边面）\n* UV展开前先冻结变换\n\n# 显示\n\n## 面数\n\n[Display]->[heads up display]->[poly count]\n\n# 操作\n\n## 变换\n\n`G`：重复操作\n\n`alt + 鼠标左键`：视角旋转\n\n`alt + 鼠标中键`：视角移动\n\n`alt + 鼠标右键`：视角缩放\n\n`alt + shift + 鼠标`：单轴缩放/移动/旋转\n\n`F`：聚焦物体\n\n`w`：平移物体\n\n​\t`ctrl + shift + 左键`：沿着边滑动\n\n`E`：旋转物体\n\n`R`：缩放物体\n\n​\t`J`：固定变换比例\n\n## 显示\n\n`1`：普通\n\n`2`：带线框的平滑着色\n\n`3`：平滑着色\n\n`4`：线框\n\n`5`：面着色\n\n`6`：带纹理的着色\n\n\n\n`alt + H` ：只显示选中的模型\n\n[Display]->[Show]->[All]显示outliner的所有物体\n\n## soft select\n\n`B`：启动\n\n选中顶点，`B + 鼠标中键`：改变影响范围\n\n## multi-cut\n\n`ctrl`：环状切\n\n`shift`：整数百分比\n\n## 挤出边Extrude\n\n`ctrl + E`\n\n## 参考图的导入\n\n[View]->[Image Plane]->[Import Image Plane]\n\n在Layers窗口可以添加Layer，将参考图添加到Layer中后，可以锁定\n\n## 右键菜单\n\n`右键`：切换选择的组件\n\n`shift + 右键`：\n\n`ctrl + shift + 右键`：(在放射变换选中的情况下)可以将仿射变换的参照在世界/物体/组件之间切换\n\n## 冻结变化\n\n应用并重置物体的变换\n\n## 移动中心点\n\n`D`\n\n居中中心点\n\n## 吸附\n\n![image-20250717103626720](../images/image-20250717103626720.png)\n\n吸附网格`x`\n\n吸附曲线`c`：选定物体，打开线框显示，对着曲线中键\n\n吸附端点`v`：按住`ctrl`\n\n吸附多边形面\n\n吸附视锥体：吸附到摄像机投影平面\n\n吸附物体：选中物体开启，吸附到选中物体表面\n\n## 复制Transform\n\n① 选中复制目标\n\n②选中复制源\n\n③在Channel Box中，对需要复制的属性按`Tab`\n\n## 选择\n\n选择循环面：①选中一个面，按住`Shift`双击相邻面\n\n## 合并顶点工具\n\n* 合并顶点到中心\n* 根据阈值合并顶点\n* 目标焊接工具\n\n## 反转法线\n\n在maya中，正面为**灰色**，北面为**黑色**\n\n反转：[Mesh Display]->[Reverse]\n\n## 复制\n\n`ctrl + D`：原位置复制\n\n`shift + 平移`：（物体模式下）复制并移动\n\n### 特殊复制\n\n[Edit]->[Duplicate Special]\n\n复制类型改为实例，可以与复制源关联\n\n## 清理\n\n[Mesh]->[Clean Up]\n\n## 隔离选择\n\n`alt + H` ：只显示选择的物体\n\n`ctrl + H`：隐藏选择的物体\n\n`ctrl + Shift + H`：显示隐藏的物体\n\n## 面提取/面复制\n\n![image-20250717103529450](../images/image-20250717103529450.png)\n\n面提取：从模型分离选中的面\n\n## 晶格\n\n[Deform]->[Lattice]\n\n![image-20250717170607119](../images/image-20250717170607119.png)\n\n删除晶格：[Edit]->[Delete by Type]->[History]\n\n## 弯曲\n\n[Deform]->[Nonlinear]->[bend]\n\n## Outliner分组\n\n`Ctrl + G`或[Edit]->[Group]\n\n# 纹理\n\nPanels->UV Editor\n\n## 材质\n\n`右键`->[Material Attributes]\n\n## AO bake\n\n[Arnold]->[Utilities]->[Render Selection to Texture]\n\n## 输出snapshot\n\n在UV Editor中，选中切割后的UV，菜单[Image]->[UV snapshot]\n\n# 骨骼\n\n## Joint\n\n* [Menu Set] -> [Rigging]\n* Skeleton->Create Joints\n\n在Ourliner中，`中键`拖拽可以添加子节点\n\n### 显示节点的旋转轴\n\n[DIsplay]->[Transform Display]->[Local Rotate Axis]\n\n### 修改旋转轴\n\n[Skeleton]->[Orient Joints]\n\n### 镜像\n\n[Skeleton]->[Mirror Joints]\n\n## Skin\n\n### 绑定\n\n选中模型&骨骼，[Skin]->[Bind Skin]\n\n### 调整权重\n\n[Skin]->[Paint Skin Weights]\n\n笔刷大小：`B + 左键`\n\n## Rig\n\n![image-20250719222900082](../images/image-20250719222900082.png)\n\n### IK\n\n[Skeleton]->[Create IK Handle]\n\n### HumanIK\n\n[Windows]->[Animation Editor]->[HumanIK]\n\nCreate Character definition\n\n在Outliner中选择骨骼，在任务面板右键骨骼选择[assign selected bone]\n\n绑定完后，点击[Create Control Rig]（垃圾桶旁边）\n\n![image-20250720123420924](../images/image-20250720123420924.png)\n\n### Constrain\n\nRigging模式下：[Constrain]\n\n* 用一个物体约束另一个物体的某些属性\n\n[Parent]：相对位置\n\n[Point]：绝对位置\n\n[Orient]：方向\n\n[Scale]：缩放\n\n[Aim]：物体B朝向物体A所在方向\n\n[Pole Vector]：物体B(IK Handle)折向物体A\n\n# 光源\n\n创建：[Create]->[Light]\n\n\n\n# Blender\n\n## 物体半透明\n\n`alt + z`\n\n## 选择循环边\n\n`alt 左键`\n\n## Edge Crease\n\nShift + E\n\n## 贝塞尔曲线\n\n`F`连接两个端点\n\n`ctrl + 右键`：在指针处添加端点\n\n[subdivide]：在两个端点之间添加一个端点\n\n`p`：分离选中的两个端点之间的线段\n\n`v`：修改曲线定义\n"},{"title":"Java笔记","url":"/2025/06/23/my-java-notes/","content":"\n# Java\n\n| Java开发 |                              |\n| -------- | ---------------------------- |\n| JDK      | Java开发                     |\n| JRE      | Java运行环境（JVM+核心类库） |\n\n## 基本语法&数据类型\n\n输出 `System.out.println()`\n\n| 数据类型                 |                                                              |\n| ------------------------ | ------------------------------------------------------------ |\n| 引用数据类型（地址传递） | String，Array                                                |\n| 基本数据类型（值传递）   | 整数 {`byte`(1); `short`(2); `int`(4); `long`(8); }<br />浮点数 {`float`(4); `double`(8); }<br />字符 {`char`(2); }<br />布尔值 {`boolean`(1); } |\n\n数据后+L：long\n\n+F：float\n\n* 标识符：不能以数字开头，不为关键字\n* **变量**首字母小写，**类**首字母大写\n\n+号与字符串运算时算作连接符：\n\n```java\nint a = 5;\nSystem.out.println(a + 'a'); \t\t // 5+97=102\nSystem.out.println(15 + \"abc\");\t\t // \"15abc\"\nSystem.out.println(\"abc\" + a + 'a'); // \"abc5a\"\n```\n\n* 双与 优先级 高于 双或\n\n键盘录入：\n\n```java\nimport java.util.Scanner;\n```\n\n### 数组\n\n定义：\n\n```java\n数据类型[] 数组名 = (new 数据类型[]){}\n数组名[] = ...\n```\n\n扩容：\n\n```java\nint[] newArr = new int[arr.length + 1];\narr = newArr\n```\n\n\n\n### 结束外层循环\n\n使用标签结束外层循环\n\n```java\nOUT:\nwhile(true){\n    for(){\n        break OUT;\n    }\n}\n```\n\n### Java内存分配\n\n| 空间   |                                                              |\n| ------ | ------------------------------------------------------------ |\n| 栈     | 方法运行时进入，存储变量（数组名）                           |\n| 堆     | new产生的对象                                                |\n| 方法区 | class文件（字节码文件加载，未被调用时存放，调用时入栈），引用类型 |\n\n```java\n// 两个变量指向同一个数组\nint[] arr1 = {1,2,3};\nint[] arr2 = arr1;\n```\n\n### String\n\n* 判断相等的方法`s.equals(<String>)`\n* 基本数据类型转String：`String s = n + \"\";`\n* String转基本数据类型：`int n = Integer.parseInt(s);`\n\n## 方法\n\n```java\npublic static int add(int a, int b){}\n```\n\n","tags":["编程"],"categories":["程序设计"]},{"title":"my-fluid-material-editor","url":"/2025/03/21/my-fluid-material-editor/"},{"title":"游戏引擎编程学习笔记","url":"/2025/02/25/my-gameEngine-learning/","content":"\n# 前言\n\n观看Cherno [GameEngine系列教程](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqa3FXT0VLbHctcGxTWFB0LVEyVjVxN0kwa05oUXxBQ3Jtc0tsc082bWs3YmFPVXY3WE5WMlJrUU1URlFxaXIxa1ZGMFhwVU1xQ29DT0ZIVzVNbFdDenJ0MXFTY25QT2hoUEh1V3lHV0pEUWhQZ0hBOUZkelNzb2NVU2Y2T0JJUzdBUWVKX3VHTU9Ob2w1eThtZll5WQ&q=https%3A%2F%2Fthecherno.com%2Fengine&v=5mlziHwq90k)所做的笔记\n\n# 游戏引擎编程\n\n## 项目架构\n\n* 引擎本体（生成dll，给sandbox使用）\n*  Sandbox（依赖engine的dll，继承engine的`Application`类）\n\n```\nGameEnginePractice\n├─ GameEnginePractice\n│  ├─ src\n│  │  ├─ Core\n│  │  │  ├─ Application.cpp\t【引擎应用层】\n│  │  │  ├─ Application.h\n│  │  │  ├─ Core.h\t\t\t【通过宏配置dllexport/import】\n│  │  │  ├─ EntryPoint.h\t【应用程序入口】\n│  │  │  ├─ Log.cpp\t\t\t【日志类】\n│  │  │  └─ Log.h\n│  │  └─ pEngine.h\t\t\t【用于包含整个项目，用户只需include这个头文件】\n│  └─ vendor\t\t\t\t【第三方库文件夹】\n├─ Sandbox\n│  └─ src\n│     └─ Source.cpp\n└─ vendor\n```\n\n## 单头文件\n\n在`pEngine.h`中，统一include其他文件，则用户在使用该dll时，只需包含`pEngine.h`。\n\n```c++\n#pragma once\n\n#include \"Core/Application.h\"\n#include \"Core/Log.h\"\n\n// --Entry Point--\n#include \"Core/EntryPoint.h\"\n// ---------------\n```\n\n## EntryPoint\n\n```c++\n#ifdef PE_PLATFORM_WINDOWS\n\nextern pEngine::Application* pEngine::CreateApplication();\n\nint main(int argc, char** argv) {\n\tpEngine::Log::Init();\n\n\tstd::cout << \"Run Application\" << std::endl;\n\tauto app = pEngine::CreateApplication();\n\tapp->Run();\n\tdelete app;\n}\n\n#endif\n```\n\n在dll文件的`EntryPoint.h`中定义**main函数**，而不是在Sandbox中。Sandbox中只需继承Application类，并定义`CreateApplication()`\n\n## 日志系统\n\n本教程采用的是[spdlog](https://github.com/gabime/spdlog)\n\n* 包装为log类：未来更换日志库时，不影响用户的使用\n* 用宏代替直接调用：通过`undef`可以轻易屏蔽日志\n\n```c++\n#pragma once\n#include \"Core.h\"\n#include \"spdlog/spdlog.h\"\n#include <memory>\nnamespace pEngine {\n\n\tclass PENGINE_API Log\n\t{\n\tpublic:\n\t\tstatic void Init();\n\n\t\tinline static std::shared_ptr<spdlog::logger>& GetCoreLogger() { return s_CoreLogger; }\n\t\tinline static std::shared_ptr<spdlog::logger>& GetClientLogger() { return s_ClientLogger; }\n\tprivate:\n\t\tstatic std::shared_ptr<spdlog::logger> s_CoreLogger;\n\t\tstatic std::shared_ptr<spdlog::logger> s_ClientLogger;\n\t};\n}\n\n//core log macros\n#define PE_CORE_ERROR(...)\t::pEngine::Log::GetCoreLogger()->error(__VA_ARGS__)\n#define PE_CORE_WARN(...)\t::pEngine::Log::GetCoreLogger()->warn(__VA_ARGS__)\n#define PE_CORE_INFO(...)\t::pEngine::Log::GetCoreLogger()->info(__VA_ARGS__)\n#define PE_CORE_TRACE(...)\t::pEngine::Log::GetCoreLogger()->trace(__VA_ARGS__)\n#define PE_CORE_FATAL(...)\t::pEngine::Log::GetCoreLogger()->fatal(__VA_ARGS__)\n\n//client log macros\n#define PE_ERROR(...)\t::pEngine::Log::GetClientLogger()->error(__VA_ARGS__)\n#define PE_WARN(...)\t::pEngine::Log::GetClientLogger()->warn(__VA_ARGS__)\n#define PE_INFO(...)\t::pEngine::Log::GetClientLogger()->info(__VA_ARGS__)\n#define PE_TRACE(...)\t::pEngine::Log::GetClientLogger()->trace(__VA_ARGS__)\n#define PE_FATAL(...)\t::pEngine::Log::GetClientLogger()->fatal(__VA_ARGS__)\n```\n\nInit:\n\n```c++\nvoid Log::Init()\n{\n\tspdlog::set_pattern(\"%^[%T] %n: %v%$\");\n\ts_CoreLogger = spdlog::stdout_color_mt(\"pEngine\");\n\ts_CoreLogger->set_level(spdlog::level::trace);\n\tPE_CORE_WARN(\"CoreLogger Initialized.\");\n\n\ts_ClientLogger = spdlog::stdout_color_mt(\"APP\");\n\ts_ClientLogger->set_level(spdlog::level::trace);\n\tPE_INFO(\"ClientLogger Initialized.\");\n}\n```\n\n## premake\n\n[github](https://github.com/premake/premake-core)\n\n用于项目构建的程序，cmake的替代方案\n\n### 使用\n\n下载premake5.exe\n\n在项目根目录创建`premake5.lua`，写配置脚本\n\n创建`GenerateProjects.bat`：\n\n```bat\ncall vendor\\bin\\premake\\premake5.exe vs2022\nPAUSE\n```\n\n## EventSystem\n\n```\n├─ Events\n│  ├─ Event.h\n│  ├─ KeyEvent.h\n│  ├─ MouseEvent.h\n│  ├─ ApplicationEvent.h\n```\n\n### Event基类\n\n枚举类型EventType用于标注事件具体类型，EventCategory用于区分事件标签\n\n**Event基类**\n\n```c++\nclass PENGINE_API Event\n{\npublic:\n\tvirtual ~Event() = default;\n\n\tbool Handled = false;\n\tvirtual EventType GetEventType() const = 0;\n\tvirtual const char* GetName() const = 0;\n\tvirtual int GetCategoryFlags() const = 0;\n\tvirtual std::string ToString() const { return GetName(); }\n    //一个事件可以有多个category，用与运算判断\n\tbool IsInCategory(EventCategory category)\n\t{\n\t\treturn GetCategoryFlags() & category;\n\t}\n};\n```\n\n**事件发送类**\n\n```c++\nclass PENGINE_API EventDispatcher\n{\npublic:\n\tEventDispatcher(Event& event)\n\t\t: m_Event(event)\n\t{\n\t}\n\t// F will be deduced by the compiler\n\ttemplate<typename T, typename F>\n\tbool Dispatch(const F& func)\n\t{\n\t\tif (m_Event.GetEventType() == T::GetStaticType())\n\t\t{\n\t\t\tm_Event.Handled |= func(static_cast<T&>(m_Event));\n\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\tprivate:\n\t\tEvent& m_Event;\n};\n```\n\n### KeyEvent类\n\n```c++\n//抽象类\nclass KeyEvent : public Event\n{\npublic:\n\tKeyCode GetKeyCode() const { return m_KeyCode; }\n\n    //定义EventCategory\n\tEVENT_CLASS_CATEGORY(EventCategoryKeyboard | EventCategoryInput)\nprotected:\n\tKeyEvent(const KeyCode keycode)\n\t\t: m_KeyCode(keycode) {}\n    \n\tKeyCode m_KeyCode;\n};\n\n//KeyPressedEvent\nclass KeyPressedEvent : public KeyEvent\n{\npublic:\n\tKeyPressedEvent(const KeyCode keycode, bool isRepeat = false)\n\t\t: KeyEvent(keycode), m_IsRepeat(isRepeat) {}\n\n\tbool IsRepeat() const { return m_IsRepeat; }\n\tstd::string ToString() const override\n\t{\n\t\tstd::stringstream ss;\n\t\tss << \"KeyPressedEvent: \" << m_KeyCode << \" (repeat = \" << m_IsRepeat << \")\";\n\t\treturn ss.str();\n\t}\n    //定义EventType\n\tEVENT_CLASS_TYPE(KeyPressed)\nprivate:\n\tbool m_IsRepeat;\n};\n\n// KeyReleasedEvent，KeyTypedEvent类似\n```\n\n## precompiled header\n\n预编译头文件是一种C++编译技术，用于提高**编译速度**\n\n`xxpch.h`：预编译头文件，包含了**不常修改的api头文件**(标准库头文件等)\n\n`xxpch.cpp`：对应的源文件，通常只有一句`include \"xxpch.h\"`，用于生成`xxpch.h`的二进制文件。\n\n### premake中使用\n\n在引擎的project中：\n\n```lua\npchheader \"pepch.h\"\npchsource \"pepch.cpp所在路径\"\n```\n\n### Visual Studio 中使用\n\n在Visual Studio的项目属性中：\n\nPrecompiled Header 设为`Use`，File设为`pepch.h`\n\n![image-20250227194015335](../images/image-20250227194015335.png)\n\n在pepch.cpp的属性中：\n\nPrecompiled Header 设为`Create`即可启用。\n\n![image-20250227193811006](../images/image-20250227193811006.png)\n\n## Window\n\n抽象Window类，将逻辑，API从实现平台分离。\n\n```\n├─ Core\n│  ├─ Window.h\n│  ├─ Window.cpp\n├─ Platform\n│  ├─ Windows\n│  │  ├─WindowsWindow.cpp\n│  │  ├─WindowsWindow.h\n```\n\n```c++\nclass PENGINE_API Window\n{\npublic:\n\tusing EventCallbackFn = std::function<void(Event&)>;\n\n    virtual ~Window() = default;\n\n\tvirtual void OnUpdate() = 0;\n\n\tvirtual uint32_t GetWidth() const = 0;\n\tvirtual uint32_t GetHeight() const = 0;\n\n\t// Window attributes\n\tvirtual void SetEventCallback(const EventCallbackFn& callback) = 0;\n\tvirtual void SetVSync(bool enabled) = 0;\n\tvirtual bool IsVSync() const = 0;\n\n\tstatic Window* Create(const WindowProps& props = WindowProps());\n};\n```\n\n### Window&Event\n\n在不同平台的事件api中调用抽象类的事件api\n\n```c++\nglfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)\n\t{\n\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\t\tWindowResizeEvent event(width, height);\n        //调用抽象类的回调函数\n\t\tdata.EventCallback(event);\n\t\tdata.Width = width;\n\t\tdata.Height = height;\n\t});\n```\n\n## Layer\n\n在主循环中，按照顺序处理不同Layer的逻辑\n\n### Layer\n\n```c++\nclass PENGINE_API Layer\n{\npublic:\n\tLayer(const std::string& name = \"Layer\");\n\tvirtual ~Layer() = default;\n    \n    //初始化\n\tvirtual void OnAttach() {}\n    \n    //销毁\n\tvirtual void OnDetach() {}\n    \n    //在主循环中，每一帧调用\n\tvirtual void OnUpdate() {}\n    \n    //在应用的OnEvent中，自底向上调用所有layer的onevent\n\tvirtual void OnEvent(Event& event) {}\n    \n\tconst std::string& GetName() const { return m_DebugName; }\nprotected:\n\tstd::string m_DebugName;\n};\n```\n\n### LayerStack\n\n```c++\nclass PENGINE_API LayerStack\n{\npublic:\n\tLayerStack() = default;\n\t~LayerStack();\n\n\tvoid PushLayer(Layer* layer);\n\tvoid PushOverlay(Layer* overlay);\n\tvoid PopLayer(Layer* layer);\n\tvoid PopOverlay(Layer* overlay);\n\n\tstd::vector<Layer*>::iterator begin() { return m_Layers.begin(); }\n\tstd::vector<Layer*>::iterator end() { return m_Layers.end(); }\n\tstd::vector<Layer*>::reverse_iterator rbegin() { return m_Layers.rbegin(); }\n\tstd::vector<Layer*>::reverse_iterator rend() { return m_Layers.rend(); }\n\n\tstd::vector<Layer*>::const_iterator begin() const { return m_Layers.begin(); }\n\tstd::vector<Layer*>::const_iterator end()\tconst { return m_Layers.end(); }\n\tstd::vector<Layer*>::const_reverse_iterator rbegin() const { return m_Layers.rbegin(); }\n\tstd::vector<Layer*>::const_reverse_iterator rend() const { return m_Layers.rend(); }\nprivate:\n\tstd::vector<Layer*> m_Layers;\n\tunsigned int m_LayerInsertIndex = 0;\n};\n```\n\n## 导入ImGui\n\n## RenderAPI\n\n### API架构\n\n**※确定平台相关/非相关API的分界线**\n\nRenderAPI：(platform specific)\n\n* Render Context\n* Swap chain\n* Framebuffer\n* Vertex Buffer\n* Index Buffer\n* Texture\n* Shader\n* states\n* pipelines\n* Render passes\n\nRenderer：(platform agnostic)\n\n* 2D&3D renderer（forward, defferred, etc）\n* scene manager\n* sorting\n* culling\n* materials\n* LOD\n* animation\n* camera\n* VFX\n* PostFX\n\n","tags":["编程","游戏","C++"],"categories":["程序设计","图形学"]},{"title":"c++笔记","url":"/2025/01/08/my-cpp-learning-note/","content":"\n# Cmake\n\n\n\n# 头文件\n\n头文件通常包含那些只能被定义一次的实体，如类，const和constexpr变量等。\n\n> ※头文件不应使用using声明，否则会导致每个使用了该头文件的文件都有这个声明\n\n## 预处理器\n\n在编译之前执行，用于部分改变我们所写的程序\n\n预处理指令：\n\n```c++\n//用指定的头文件代替include\n#include \"Sales_data.h\"\n\n//防止头文件重复包含\n#ifndef SALES_DATA_H\n#define SALES_DATA_H\nclass Sales_data{\n    ...\n};\n#endif\n```\n\n# 基本类型\n\n## 标识符identifier\n\n标识符identifier由字母，数字，下划线组成，**必须以字母或下划线开头**，长度无限制，大小写敏感。\n\n### c++关键字\n\n![image-20250108151203596](../images/image-20250108151203596.png)\n\n### 作用域scope\n\n同一个名字在不同作用域可能指向不同的实体。\n\n一个名字的有效区域始于名字的声明，在作用域末端结束。\n\n使用`using`引入命名空间的成员：\n\n```c++\n//使所有库函数都默认std（不常用）\nusing namespace std;\n\n//个别引入\nusing std::cin;\nusing std::cout;\nusing std::endl;\n```\n\n## 无符号/有符号\n\n> ※在同一个表达式中，有符号类型会转换为无符号类型\n>\n> ```c++\n> int a = -2;\n> unsigned int b = 1;\n> cout << a + b; //输出1+2^32-2==2^32-1\n> ```\n\n## 变量初始化\n\n### 声明和定义\n\n※声明不分配空间，定义申请空间并赋初值\n\n※变量可以被多次声明，但只能被定义一次\n\n仅声明：\n\n```c++\nextern int i;\t//仅声明\nint j;\t\t\t//声明并定义\n```\n\n###  默认初始化\n\n定义变量时没有指定初值，将会被默认初始化\n\n* 函数体外的基本类型变量初始化为0\n\n* 函数体内部的基本类型变量将**不被初始化**\n\n### {}列表初始化\n\n禁止类型的自动转化，防止因自动转换而丢失信息\n\n```c++\nint i1 = 7.2 \t//自动转换为7\nint i2 {7.2} \t//报错\nint i3 = {7.2} \t//报错\n```\n\n### auto\n\nc++11\n\n编译器自动推断类型\n\n※auto定义的变量必须有初始值\n\n### decltype\n\nc++11\n\n表达式的返回类型作为类型声明\n\n```c++\ndecltype(func()) sum = x;\n//将func()的返回值类型作为sum的类型，但不调用func()\n\nint* p = &i;\n//c的类型为int&\ndecltype(*p) c = 1; //传入解引用，则得到引用类型，必须初始化\n```\n\n> ```c++\n> int i = 0;\n> decltype(i) c;\t\t//正确，c的类型为int\n> decltype((i)) c;\t//错误，c的类型为int&,必须初始化\n> ```\n>\n> 加上括号的变量可以作为赋值语句左值的特殊表达式，所以**一定**得到引用类型\n\n## 常量\n\n### 字面值常量\n\n字面值常量（literal）\n\n* 整型\n\n不同进制的20声明：\n\n十六进制：`0x14`\n\n八进制：`024`\n\n十进制：`20`\n\n* 浮点型\n\n`3.14159`，`3.14159E0`，`0.`，`.001`\n\n* 字符型\n\n`'a'`：字符只占一个字节\n\n`\"a\"`：字符串是字符数组，多占一个字节存储空字符`'\\0'`\n\n```c++\n//字符串字面值可以分多行书写\nstd::cout << \"a really long string literal\"\n    \t\t\"that spans two lines\" << std::endl;\n```\n\n#### 字符转义\n\n| 转义序列(escape sequence) | 含义            |\n| ------------------------- | --------------- |\n| \\n                        | 换行符          |\n| \\t                        | 横向制表符(tab) |\n| \\a                        | 报警(响铃)符    |\n| \\v                        | 纵向制表符      |\n| \\\\\\                       | 反斜线          |\n| \\r                        | 回车符          |\n| \\\\\"                       | 双引号          |\n| \\\\'                       | 单引号          |\n\n#### 指定字面值类型\n\n![image-20250108145832735](../images/image-20250108145832735.png)\n\n### 常量标识符\n\n#### const\n\n>※默认情况下，`const`定义的变量只在文件内有效。\n>\n>跨文件使用：都使用`extern`关键字\n>\n>```c++\n>//file1\n>extern const int bufSize = func();\n>//file2\n>extern const int bufSize;\n>```\n\n常量引用：\n\n> ※不能用普通引用去引用一个常量\n>\n> 本质：创建一个临时变量的引用\n>\n> ```c++\n> const int &ref = 10;\n> //等价于\n> const int temp = 10;\n> const int &ref = temp;\n> ```\n\n```c++\nconst int a = 1024;\nint b = 1024;\nconst int &r = a;\t//正确\nint &r2 = a;\t\t//错误，引用也必须声明为常量\nconst int &r3 = b;\t//正确\nconst int &r4 = 42;\t//正确\nint &r5 = r;\t\t//错误，引用也必须声明为常量\n```\n\n`const`修饰形参，防止修改：\n\n```c++\nvoid print(const int &val);\n```\n\n#### constexpr\n\nc++11\n\n常量表达式（const expression）是指不会改变且在编译过程就能预知结果的表达式\n\n**非**常量表达式：\n\n```c++\nint a = 27;\t\t\t\t\t//在后续可能改变\nconst int b = random();\t\t//编译时不确定\n```\n\n用于指针：\n\n```c++\nconstexpr int* p = nullptr;\t//p是一个const pointer，顶层const\n```\n\n## 复合类型\n\n基于其他类型定义的类型\n\n* 引用\n* 指针\n\n### 左值引用\n\n```c++\nint a = 1024;\nint &b = a;\t//b指向a，当a改变b也改变\nint &c;\t\t//报错，引用必须被初始化\nint &d = 10\t//报错,引用的初始值不能为字面值\n```\n\n引用的本质：指针常量（无法修改指向的地址）\n\n```c++\nint a = 10;\n\nint &ref = a;\n//等价于\nint* const ref = &a;\n```\n\n引用传递：\n\n```c++\nvoid swap(int &a, int &b);\n```\n\n引用返回：\n\n```c++\nint& test();\n//使得函数调用可以作为左值\n//※不能返回局部变量的引用（会被释放）\n```\n\n### 指针\n\n> ```c++\n> int* p1,p2;\t//p1为指针，p2为int\n> ```\n\n```c++\nint a = 1024;\nint* p;\t\t\t//指针无需在定义时赋值\nint* p = &a;\t//指针存放地址，因此使用取址符\n```\n\n指针的解引用：\n\n```c++\ncout<< *p;\t\t//获取p指向的值\n*p = 0;\t\t\t//给指针所指的变量赋值\n```\n\nc++11空指针：\n\n```c++\nint* p = nullptr;\n```\n\n指向指针的指针：\n\n```c++\nint** p = new int*[10]; //指向一个int指针数组\ncout<< **p;\t\t\t\t//解引用到int\n```\n\n指向指针的引用：\n\n```c++\nint* p = nullptr;\nint* &r = p;\n```\n\n※面对比较复杂的指针或引用声明时，从右向左有助于弄清真实含义。\n\n#### 指针和const\n\npointer to const（low-level const）：不能改变值，可以改变指向的地址\n\n```c++\nconst int a = 1024;\nconst int * ptr = &a;\n```\n\nconst pointer（top-level const）：不可改变指向（引用的本质）\n\n```c++\nint a = 10;\n\nint &ref = a;\n//等价于\nint* const ref = &a;\n```\n\n#### void*\n\n可以用于存放任意类型的指针\n\n### 声明\n\n```c++\nchar* p;\nchar v[6]; //变量'v'存的是数组第一个值的地址\n```\n\n### 取值&取址\n\n```c++\nchar* p = &v[3]; //前置&获取变量的地址\nchar x = *p;     //前置*获取变量的值\n```\n\n## 遍历\n\n### for\n\n```c++\n//基本for循环\nfor(int i=0; i<10; i++){\n    ...\n}\n\n//复制v中的元素\nfor(auto x : v){\n    ...\n}\n\n//引用v中的元素\nfor(auto& x : v){\n    ...\n}\n```\n\n# 类型别名\n\n## 类型别名type alias\n\n```c++\ntypedef double wages;\t//wages是double的同义词\n```\n\n> ```c++\n> typedef char *pstring;\n> //cstr是const pointer\n> const pstring cstr = 0;\n> ```\n>\n> 不能简单将pstring替换为char*来理解\n\n## 别名声明alias declaration\n\n```c++\nusing SI = Sales_item;\t//SI是Sales_item的同义词\n```\n\n# 标准库类型\n\n## string\n\n> 为了与c兼容，字符串字面值与string类型不同，字符串字面值为char array\n\n可变长的字符序列\n\n引入：\n\n```c++\n#include <string>\nusing std::string;\n```\n\n### 定义\n\n```c++\n//直接初始化\nstring a(\"a\");\n\n//拷贝初始化（将创建临时变量）\nstring a = \"a\";\n```\n\n### 读取\n\n```c++\n//1.按单词读取（空格截断）\nstring word;\nwhile(cin >> word){\n    cout << word << endl;\n}\n\n//2.整行读取（换行符截断）(string中不包含换行符)\nstring line;\nwhile(getline(cin, line)){\n\tcout << line << endl;\n}\n```\n\n### empty\n\n用于判断字符串是否为空\n\n```c++\nif(!line.empty())\n    cout << line << endl;\n```\n\n### size\n\n返回字符数量（不包括空字符）\n\n返回类型：`size_type`，无符号整数\n\n```c++\nstring a(\"abc\");\na.size();\t\t//为3\na[3]\t\t\t//得到空字符\n```\n\n### 运算\n\n```c++\nstring s3 = s1 + s2;\t\nstring s3 = s1 + \", \" + s2 + '\\n';\n```\n\n> 必须确保每个`+`运算符两边至少有一个string对象\n>\n> ```c++\n> //错误！\n> string s3 = \"hello\" + \"world\"; \n> \n> //正确，前面的运算返回string类型\n> string s4 = s1 + \",\" + \"world\";\n> ```\n\n### 遍历\n\n```c++\nfor (auto &c : str){\n    c = toupper(c);\n    cout << c << endl;\n}\n```\n\n### c风格字符串\n\n定义在cstring头文件中\n\n```c++\n//返回长度，不包含空字符\n//※strlen会找到空字符才停下来，因此不能用于不包含空字符的字符数组\nstrlen(p)\n\n//比较p1p2\nstrcmp(p1,p2);\n\n//将p2附加到p1后\nstrcat(p1,p2);\n\n//将p2拷贝给p1\nstrcpy(p1,p2);\n```\n\nstring和c风格字符串的转换：\n\n```c++\n//将string转换为const char\nconst char *str = s.c_str();\n```\n\n\n\n## vector\n\nvector不是一个类，而是**类模板**\n\n引入：\n\n```c++\n#include <vector>\nusing std::vector;\n```\n\nvector包含vector：\n\n```c++\n//早期版本中右尖括号之间要有空格\nvector<vector<int> >\n```\n\n### 初始化\n\n```c++\n//列表初始化 c++11,创建一个元素，值为10\nvector<int> v1{10};\n\n//创建10个元素，值为0\nvector<int> v1(10);\n\n//创建10个元素，每个值为1\nvector<int> v1(10, 1);\n\n//创建2个元素，值分别为10和1\nvector<int> v1{10, 1};\n```\n\n### 遍历\n\n```c++\n//范围for语句\nfor (auto &i:v){\n    ...\n}\n```\n\n\n> 范围for语句中不应出现向vector添加元素的语句（遍历序列的大小会改变）\n\n### 迭代器\n\n| 方法        | 返回值                                 |\n| ----------- | -------------------------------------- |\n| `v.begin()` | 第一个元素的迭代器                     |\n| `v.end()`   | 尾后迭代器（最后一个元素的后一个位置） |\n\n```c++\nfor(auto it = v.begin(); it != v.end(); it++){\n    *it...\n}\n\n//获取中间位置迭代器(返回difference_type，有符号整数)\nauto mid = v.begin() + v.size()/2;\n```\n\n## 数组\n\n### 初始化\n\n```c++\n//前两个元素初始化为1，2，后面元素为默认值\nint arr[3]{1, 2};\n```\n\n> ※字符数组可以用字符串字面值初始化，**但字符串末的空字符也会被存入**\n>\n> ```c++\n> char arr[]{'c', '+', '+'};\n> \n> //错误，\"apple\"要占6个元素\n> char arr[5] = \"apple\";\n> ```\n>\n> ※不能直接把另一个数组拷贝初始化或赋值\n>\n> ```c++\n> int a[]{0,1,2};\n> \n> //错误\n> int a2[] = a;\n> a2 = a\t//(一些编译器支持)\n> ```\n\n复杂数组声明：\n\n```c++\n//Parray指向一个含有10个整数的数组\n//没加括号会报错\n//arr大小不是10会报错\nint (*Parray)[10] = &arr;\n\n//arrRef引用一个含有10个整数的数组\nint (&arrRef)[10] = arr;\n```\n\n> 数组的对象实际上是指向该数组首元素的指针\n>\n> ```c++\n> int ia[2]{1,2};\n> \n> auto ia2(ia);\t\t//ia2的类型被推断为int*\n> auto ia2(&ia[0])\t//等价\n> \n> decltype(ia)\t\t//推断为int[10]\n> ```\n\n### 遍历\n\nc++11 begin，end：\n\n```c++\nint arr[3]{0,1,2};\nint *begin = begin(arr);\nint *end = end(arr);\t\t//返回尾元素的下一位置(不能解引用)\n\n//ptrdiff_t类型，有符号\nauto n = end(arr) - begin(arr);\n```\n\n### 多维数组\n\n> 本质是数组的数组\n\n```c++\n//内层花括号可以省略\nint ia[3][4]{\n    {0,1,2,3},\n    {4,5,6,7},\n    {8,9,10,11}\n}\n```\n\n# 表达式\n\n## 算数运算\n\nc++11除法运算int类型，向0取整（直接去除小数部分），且结果的符号看m和n\n\nm%n如果不等于零，则符号与m相同\n\n```c++\n21 % -5 == 1\n21 / -5 == -4\n    \n-21 % -8 == -5\n-21 / -8 == 2\n```\n\n### 递增递减\n\n> 除非必须，否则不用后置递增递减：后置版本需要**额外**将修改前的原始值存储下来\n\n```c++\nauto iter = v.begin();\nwhile(iter !=v.end()){\n    //解引用后递增\n    cout <<*iter++ << endl;\n}\n```\n\n## 逻辑和关系运算\n\n### 短路求值\n\n```c++\n&& ||\n```\n\n## 赋值\n\nc++新标准：初始值列表\n\n```c++\nk = {3.14};\t//错误，窄化转换\n```\n\n赋值满足**右结合律**：\n\n```c++\nint ival, jval;\nival = jval = 0;\t//0赋值给jval,jval赋值给ival\n\nint ival, *pval;\nival = pval = 0;\t//错误，pval无法转换为ival\n```\n\n## 位运算符\n\n位运算符作用于**整数类型**的运算对象\n\n| 运算符 | 功能     |\n| ------ | -------- |\n| ~      | 按位求反 |\n| <<     | 左移     |\n| >>     | 右移     |\n| &      | 按位与   |\n| \\|     | 按位或   |\n| ^      | 按位异或 |\n\n> 位运算符对符号位的处理依赖于机器，因此建议仅用于**无符号类型**\n\n### 移位操作\n\n移位运算符满足**左结合律**\n\n优先级比算术运算符低，比关系，赋值，条件运算符高\n\n## sizeof\n\n※`sizeof`的返回值是**常量表达式**，可以声明数组的维度\n\n※`sizeof`中解引用一个无效指针是**安全行为**\n\n```c++\nsizeof(*p); //即使p指向无效地址也安全，因为sizeof不需要真的解引用指针\n```\n\n※对数组名执行`sizeof`，得到整个数组元素所占空间大小\n\n```c++\n//计算arr中的元素数量\nconstexpr size_t count = sizeof(arr)/sizeof(*arr);\n```\n\n※对string或vector对象执行`sizeof`，返回的是**固定部分的大小**，\n\n不会计算对象中的元素占用空间：\n\n```c++\nstring a = \"abc\";\nstring b = \"abcd\";\nsizeof(a) == sizeof(b) == 32\n```\n\n## 逗号运算符\n\n※优先级小于赋值符号\n\n含有两个运算对象，按从左到右的顺序求值，返回的是**右侧表达式的值**：\n\n```c++\nint a = (1,2);\t// a==2\n```\n\n常用在for循环中，用于递增递减两个变量\n\n# 类型转换\n\n> 尽量避免强制类型转换\n\n## 隐式转换\n\n* 比int小的整型值和char首先提升为较大的整数类型\n* 在条件表达式中非布尔值转换成布尔类型\n* 初始化和赋值过程中，右侧对象转换为左侧对象的类型\n* 用数组名初始化指针\n\n```c++\n3.14159L + 'a'\t//'a'提升成int，然后转化为long double\n```\n\n## 显示转换\n\n### static_cast\n\n不包含`low-level const`的任何具有明确定义的类型转换都可以使用`static_cast`，使用静态转换时相当于告诉编译器**忽略潜在的精度损失**。\n\n```c++\n//用static_cast还原void*\nvoid* p = &d;\ndouble *dp = static_cast<double*>(p);\n\n//将char*转换为string\nconst char* cp;\nstatic_cast<string>(cp);\n```\n\n### const_cast\n\n`const_cast`只能改变运算对象的`low-level const`性质\n\n```c++\nconst char *pc;\nchar *p = const_cast<char*>(pc);\n```\n\n常用于函数重载中：\n\n```c++\nconst string &shorterString(const string &s1, const string &s2){\n    return s1.size() <= s2.size() ? s1 : s2;\n}\n\n//将s1,s2转换成const后调用const版本的函数\nstring &shorterString(string &s1, string &s2){\n    auto &r = shorterString(const_cast<const string>(s1),\n                           const_cast<const string>(s2));\n    return const_cast<string&>(r);\n} \n```\n\n### reinterpret_cast\n\n重新解释运算对象的底层位模式\n\n```c++\nint *ip;\nchar *pc = reinterpret_cast<char*>(ip);\n//将*ip的数据解释为char\n```\n\n# 异常处理\n\n* throw表达式：用于抛出异常（异常检测）。\n* try语句块：以`try`开始，一个或多个`catch`语句结束。（异常处理）\n* 一套异常类：用于在`throw`和`try-catch`之间传递信息。\n\n## throw表达式\n\n```c++\nif(...){\n    throw runtime_error(\"...\");\n}\n```\n\n`throw`表达式抛出异常后，将**终止当前函数，把控制权转移给能处理异常的代码**\n\n## try语句块\n\n```c++\ntry{\n    //执行有可能异常的代码，并抛出异常\n    if(...){\n    \tthrow runtime_error(\"...\");\n    }\n}catch(runtime_error e){\n    //如果抛出了runtime_error,则跳转到该语句块处理\n}catch(异常声明){\n    ...\n}\n```\n\n> 若程序在抛出异常时经过了**多层try语句块**，则会自底向上，不断向调用该函数的函数抛出异常，直到找到匹配的`catch`语句。\n>\n> 如果没要找到任何匹配的`catch`（或没有try语句块），则转到名为`terminate`的标准库函数，该函数的行为与系统相关，一般导致程序非正常退出（闪退）\n\n## 标准异常类\n\n| \\<stdexcept>异常类 |                            |\n| ------------------ | -------------------------- |\n| exception          | 最常见的问题               |\n| runtime_error      | 运行时才能检测出的问题     |\n| range_error        | 运算结果超出了有效值       |\n| overflow_error     | 计算上溢                   |\n| underflow_error    | 计算下溢                   |\n| logic_error        | 程序逻辑错误               |\n| domain_error       | 参数对应的结果值不存在     |\n| invalid_argument   | 不合法的参数               |\n| length_error       | 试图创建超出最大长度的对象 |\n| out_of_range       | 使用一个超出有效范围的值   |\n\n# 函数\n\n### 局部静态对象\n\n```c++\nvoid func(){\n    //静态变量知道程序终止才销毁\n    static int count = 0;\n    //统计函数调用次数\n    count++;\n    return;\n}\n```\n\n## 参数传递\n\n### 值传递\n\n初始化一个非引用类型的形参时，初始值被拷贝，**在函数内的改动不会影响实参本身**。\n\n### 引用传递\n\n通过引用传递可以在函数内**改变实参本身**，也可以专门用一个参数返回额外信息\n\n### 引用形参与const\n\n※可以使用非常量初始化一个底层const对象，但不能用const对象，字面值传给普通的引用形参。\n\n```c++\n//规范传入数组\n//传入头尾指针\nvoid print(const int* beg, const int* end){\n    ....\n}\n//传入数组和大小\nvoid print(const int arr[], size_t size){\n    ....\n}\n```\n\n### 参数默认值\n\n※一旦某个形参有默认值，**后面的所有形参都必须有默认值**。\n\n## 返回值\n\n※不要返回局部对象的引用或指针\n\n### 列表初始化返回值\n\nc++11\n\n```c++\nvector<string> process(){\n    return {\"a\", \"b\", \"c\"};\n}\n```\n\n### 尾置返回类型\n\n用于函数**声明**，在形参列表后用箭头声明返回类型，前面用`auto`。\n\n```c++\nauto func(int i) -> int(*)[10];\n```\n\n使用`decltype`也可以声明：\n\n```c++\nint arr[] = {1,2,3};\n\n//decltype(arr)返回一个大小为3的整形数组，用*转换为指针\ndecltype(arr)* func(int i){\n    ...\n} \n```\n\n## main函数\n\n### 传参\n\n```c++\nint main(int argc, char* argv[]){\n    ...\n}\n```\n\n### 返回值\n\nmain函数如果没有写return语句，编译器将自动插入`return 0`\n\nmain函数的返回值可以看作是状态指示器，返回0表示**执行成功**，返回其他值表示执行失败。\n\n`cstdlib`定义了两个预处理变量，可以表示执行成功与失败：`EXIT_FAILURE`，`EXIT_SUCCESS`\n\n## 函数重载\n\n同一作用域内，**形参列表不同，函数名相同**的函数称之为**重载函数overloaded**。\n\n※不能只有**返回类型不同**。\n\n局部函数会覆盖全局函数（一般不在局部作用域声明函数）:\n\n```c++\nvoid print(const string &);\nvoid print(double);\nvoid main(){\n    //导致上面两个print均被隐藏\n    void print(int);\n}\n```\n\n> c++中先进行名字查找，再类型检查。\n\n### 函数匹配\n\n## 函数内联\n\n在函数声明的开头标注\n\n在编译过程中展开函数，用函数体替换函数调用。（提升性能）\n\n## 常量表达式\n\n* 函数的返回类型和所有形参都是字面值类型\n* 函数体有且只有一条return\n\n编译时，`constexpr`函数被隐式指定为内联函数，在执行初始化任务时替换为结果值。\n\n## 函数指针\n\n# 类\n\n※类本身就是一个作用域，类的成员函数的定义嵌套在作用域内。\n\n※class和struct的唯一区别是默认的访问权限不同。\n\n※类内定义的函数默认`inline`。\n\n类外显示定义类成员函数为`inline`：\n\n```c++\ninline\nScreen& Screen::move(){\n    ...\n    //返回对象本身\n   \treturn *this;\n}\n```\n\n## 构造函数\n\n### 默认构造函数的作用\n\n对象被默认初始化或值初始化时，自动执行默认构造函数\n\n### 手动生成默认构造函数\n\nc++11\n\n```c++\n//定义了其他构造函数的情况下，还需要默认构造函数时\nClass() = default;\n```\n\n### 初始值列表\n\n※初始值列表的前后位置关系不会影响初始化顺序，成员的初始化顺序与**类定义中出现的顺序一致**。\n\n>**必须使用初始值的情况：**\n>\n>* const或引用成员\n>* 类类型，且无默认构造函数的成员\n>\n>```c++\n>class Class{\n>private:\n>    const int i;\n>    int &ri;\n>}\n>```\n\n```c++\nClass(): var1(value1), var2(value2) {}\n```\n\n### 委托构造函数\n\nc++11\n\n可以将构造函数的一部分职责交给其他构造函数\n\n```c++\nclass Sales_data{\n    //先执行委托的构造函数的初始值列表和函数体\n    //再执行自身构造函数的内容\n    Sales_data(): Sales_data(\"\", 0, 0){\n        ...\n    };\n}\n```\n\n## 友元\n\n令其他类或函数成为**友元(friend)**，就可以允许其他类或函数访问`private`成员。\n\n```c++\nclass Sales_data{\n    friend Sales_data add(const Sales_data&, const Sales_data&);\n   \t...\n}\n//类外声明\nSales_data add(const Sales_data&, const Sales_data&);\n```\n\n## 可变成员\n\n`mutable`关键字声明的成员属性，可以在`const`函数内被修改。\n\n```c++\nmutable size_t count;\n\n//用mutable成员记录函数调用次数\nvoid Screen::func() const{\n    ++count;\n}\n```\n\n## 类类型转换\n\n※隐式转换只会转换一步\n\n```c++\n//该构造函数会在需要Sales_data类型时，自动将istream类型转换\nSales_data(std::istream&);\n\nitem.combine(cin);//函数接受Sales_data类型，但传入的是istream\n```\n\n### 抑制隐式转换\n\n※`explicit`只对一个实参的构造函数有效\n\n※只能在类内声明时使用`explicit`，在类外定义时不使用\n\n```c++\n//阻止构造函数的隐式转换\nexplicit Sales_data(std::istream&);\n```\n\n仍然可以显式地转换：\n\n```c++\n//两者都调用构造函数，创建一个临时的Sales_data对象\nitem.combine(Sales_data(cin));\nitem.combine(static_cast<Sales_data>(cin));\n```\n\n## 聚合类\n\naggregate class\n\n满足以下条件的类，称为聚合类：\n\n* 所有成员public\n* 没有定义任何构造函数\n* 没有类内初始值\n* 没有基类，virtual函数\n\n```c++\nstruct Data{\n    int ival;\n    string s;\n}\n\n//可以用初始值列表初始化：\nData data = {0, \"Vavid\"}\n```\n\n### 字面值常量类\n\n数据成员都是字面值类型的聚合类**或**满足以下条件的类，称为字面值常量类：\n\n* 数据成员都是字面值类型\n* 含有一个`constexpr`构造函数，且类成员也有自己的`constexpr`构造函数\n* 使用默认析构函数\n\n## 静态成员\n\n该类的所有对象**共用**类的静态成员。\n\n## 虚函数\n\n- 用纯虚函数定义接口，强制子类实现。\n- 用普通虚函数提供默认行为，子类按需覆盖。\n\n# IO库\n\n| 头文件   | 类型                                               |\n| -------- | -------------------------------------------------- |\n| iostream | istream：输入流类型<br />ostream：输出流类型<br /> |\n|          |                                                    |\n|          |                                                    |\n|          |                                                    |\n\n# 智能指针\n\n## RAII\n\nResource Acquisition is Initialization ：在对象构造时分配资源，在对象析构时释放资源，使对象在生命周期内始终有效。\n\n# 调试\n\n```c++\n//未定义NDEBUG时触发\n#ifndef NDEBUG\n\tcerr << _ _func_ _ << endl;\n#endif\n```\n\n* `_ _func_ _`：输出当前调试的函数的名字\n* `_ _FILE_ _`：存放文件名的字符串字面值\n* `_ _LINE_ _`：存放当前行号的整形字面值\n* `_ _TIME_ _`：存放文件编译时间的字符串字面值\n* `_ _DATE_ _`：存放文件编译日期的字符串字面值\n\n","tags":["编程","C++"],"categories":["程序设计"]},{"title":"OpenGL学习笔记","url":"/2024/12/18/my-OpenGL-notes/","content":"\n[LearnOpenGL](https://learnopengl-cn.github.io/)学习笔记\n\n<!--more-->\n\n# GLFW\n\n针对OpenGL的C语言库，提供渲染物体所需的最低限度的接口\n\n※不同操作系统生成窗口的代码不同\n\n※不同操作系统鼠标，键盘的响应方式不同\n\n## 初始化\n\n[glfwWindowHint配置选项](https://www.glfw.org/docs/latest/window.html#window_hints)\n\n```c++\nglfwInit();\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //主版本号\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //次版本号\n//使用核心模式\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n//macOS额外添加：\n//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n```\n\n## 创建窗口\n\n```c++\nGLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL);\nif (window == NULL)\n{\n\tstd::cout << \"Failed to create GLFW window\" << std::endl;\n\tglfwTerminate();\n\treturn -1;\n}\n//将window作为openGL绘制所用的窗体\nglfwMakeContextCurrent(window);\n```\n\n## 事件回调\n\n```c++\n//窗口大小改变\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n//光标位置改变\nglfwSetCursorPosCallback(window, mouse_callback);\n//鼠标滚动\nglfwSetScrollCallback(window, scroll_callback);\n//键盘\nglfwSetKeyCallback(window,key_callback);\n\n//action : GLFW_PRESS/GLFW_RELEASE \n//mods   : GLFW_MOD_CONTROL/GLFW_MOD_SHIFT\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){\n    if(key == GLFW_KEY_W){\n        ...\n    }\n}\n```\n\n## 输入\n\n### 键盘绑定\n\n```c++\nvoid processInput(GLFWwindow* window) {\n\t//glfwGetKey()检查是否按下某个键，返回GLFW_PRESS或GLFW_RELEASE\n\tif (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\n\t\tglfwSetWindowShouldClose(window, true);\n\t}\n\tfloat cameraSpeed = 2.5f * deltaTime;\n\tif (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)\n\t\tcameraPos += cameraSpeed * cameraFront;\n\tif (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)\n\t\tcameraPos -= cameraSpeed * cameraFront;\n\tif (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)\n\t\tcameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;\n\tif (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n\t\tcameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;\n}\n```\n\n### 鼠标输入\n\n```c++\n// 隐藏并捕捉光标\nglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n```\n\n计算鼠标输入：\n\n* 光标初始值设为屏幕中央\n\n* 计算光标距离上一帧的偏移量\n* 把偏移量加到摄像机的俯仰角和偏航角中\n* 限制转角的最大最小值\n* 计算方向向量\n\n```c++\nfloat lastX = 400, lastY = 300;\nfloat xoffset = xpos - lastX;\n// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的\nfloat yoffset = lastY - ypos; \nlastX = xpos;\nlastY = ypos;\n\nfloat sensitivity = 0.05f;\nxoffset *= sensitivity;\nyoffset *= sensitivity;\n\nyaw   += xoffset;\npitch += yoffset;\n\nif(pitch > 89.0f)\n  pitch =  89.0f;\nif(pitch < -89.0f)\n  pitch = -89.0f;\n\nglm::vec3 front;\nfront.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));\nfront.y = sin(glm::radians(pitch));\nfront.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));\ncameraFront = glm::normalize(front);\n```\n\n## 渲染循环\n\n```c++\nwhile (!glfwWindowShouldClose(window))\n{\n\t// 计算时间\n\t// --------------------\n\tfloat currentFrame = static_cast<float>(glfwGetTime());\n\tdeltaTime = currentFrame - lastFrame;\n\tlastFrame = currentFrame;\n\n\t// 输入\n\t// -----\n\tprocessInput(window);\n\t\n\t// 渲染指令\n\t// ------\n\t......\n\n\t// 交换缓冲，接受并分发窗口消息\n\t// ------\n\tglfwSwapBuffers(window);\n\tglfwPollEvents();\n}\n\n// 退出程序，释放分配的资源\nglfwTerminate();\n```\n\n# GLAD\n\n**※`#include <glad/glad.h>`必须放在所有头文件之前**\n\n根据不同OpenGL版本，获取驱动的函数指针\n\n## OpenGL函数加载\n\nOpenGL是一个规范标准，而不是具体实现\n\n实现靠各家显卡厂商编写的驱动程序\n\n程序如果需要运行，就需要向显卡驱动查询函数的具体位置并加载进来\n\n```c++\n// 使用GLAD加载OpenGL函数\nif (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n{\n\tstd::cout << \"Failed to initialize GLAD\" << std::endl;\n\treturn -1;\n}\n```\n\n## gladLoadGLLoader\n\n```c++\nint gladLoadGLLoader(GLADloadproc load) {\n\tGLVersion.major = 0; GLVersion.minor = 0;\n\tglGetString = (PFNGLGETSTRINGPROC)load(\"glGetString\");\n\tif(glGetString == NULL) return 0;\n\tif(glGetString(GL_VERSION) == NULL) return 0;\n\tfind_coreGL(); //标识需要支持的版本号\n    \n    //将需要支持的版本中的函数都加载进来\n\tload_GL_VERSION_1_0(load);\n\tload_GL_VERSION_1_1(load);\n\tload_GL_VERSION_1_2(load);\n\tload_GL_VERSION_1_3(load);\n\tload_GL_VERSION_1_4(load);\n\tload_GL_VERSION_1_5(load);\n\tload_GL_VERSION_2_0(load);\n\tload_GL_VERSION_2_1(load);\n\tload_GL_VERSION_3_0(load);\n\tload_GL_VERSION_3_1(load);\n\tload_GL_VERSION_3_2(load);\n\tload_GL_VERSION_3_3(load);\n\tload_GL_VERSION_4_0(load);\n\tload_GL_VERSION_4_1(load);\n\tload_GL_VERSION_4_2(load);\n\tload_GL_VERSION_4_3(load);\n\tload_GL_VERSION_4_4(load);\n\tload_GL_VERSION_4_5(load);\n\tload_GL_VERSION_4_6(load);\n\n\tif (!find_extensionsGL()) return 0;\n\treturn GLVersion.major != 0 || GLVersion.minor != 0;\n}\n```\n\n# OpenGL\n\n## 初始化\n\n```c++\n// 设置视口大小\nglViewport(GLint x,GLint y, GLsizei width, GLsizei height);\n\n//设置清理颜色\nglClearColor(r,g,b,a);\n```\n\n## 错误检查与封装\n\n```c++\n#include <assert.h>\n\n//检查之前的函数调用，并返回最新的一个错误码\nvoid checkError(){\n    GLenum errorCode = glGetError();\n\tif(errorCode != 0){\n    \tassert(false); //中断程序\n\t}\n}\n\n//定义宏,在调用GL函数后自动调用检错\n#ifdef DEBUG\n#define GL_CALL(func) func;checkError();\n#else\n#define GL_CALL(func) func;\n#endif\n\n//cmake预编译宏\nadd_definitions(-DDEBUG)\n```\n\n## 封装窗体类\n\n ### 单例模式\n\n* 静态成员实例指针\n* 私有构造函数\n\n```c++\nclass Application{\n    public:\n    \t~Application();\n    \tstatic Application* getInstance();\n    private:\n    \tstatic Application* mInstance;\n    \tApplication();\n    \tuint32_t mWidth{ 0 };\n    \tuint32_t mHeight{ 0 };\n    \tGLFWwindow* mWindow{nullptr};\n}\n#define app Application::getInstance();\n```\n\n### 对外接口\n\n* init：设置初始信息，生成窗体，载入openGL函数\n* update：更新双缓存，接受并分发窗体消息\n* destroy：退出程序\n\n### 回调函数\n\n用函数指针成员存储回调函数\n\n* 声明一个函数指针\n* 声明一个Callback成员变量\n* 声明一个`static`的GLFW注册回调函数\n\n## 坐标系统\n\n右手系\n\n![coordinate_systems_right_handed](https://learnopengl-cn.github.io/img/01/08/coordinate_systems_right_handed.png)\n\n### 纹理\n\n左下角为 (0, 0)\n\n### 坐标空间\n\n顶点着色器→\n\n* 物体空间/局部空间 （object/local space）\n\n* 世界空间（world space）\n\n* 观察空间（view space）\n\n* 裁剪空间（clip space）\n  * -1~1，并舍弃视角外的物体\n\n* 屏幕空间（screen space）\n  * 将-1~1的范围变换到`glViewport`定义的坐标范围内\n\n→光栅化rasterizer\n\n不同坐标空间变换的过程：\n\n![coordinate_systems](https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png)\n\n## 图元\n\n| 类型          |      |\n| ------------- | ---- |\n| GL_POINTS     |      |\n| GL_TRIANGLES  |      |\n| GL_LINE_STRIP |      |\n\n## GPU显存对象\n\n### 绑定\n\n将某个资源与OpenGL状态机中某个状态**插槽**进行关联\n\n每个插槽每个时刻只有一个资源被绑定\n\n![image-20241227134149501](../images/image-20241227134149501.png)\n\n插槽：\n\n| GLenum                  |         |\n| ----------------------- | ------- |\n| GL_ARRAY_BUFFER         | 当前VBO |\n| GL_ELEMENT_ARRAY_BUFFER | EBO     |\n| GL_TEXTURE_2D           |         |\n\n### VBO\n\nvertex buffer object：表示在GPU显存上的一段存储空间对象，在c++中，用`unsigned int`类型存储它的ID。\n\n![image-20241227133016316](../images/image-20241227133016316.png)\n\n```c++\n//创建VBO,将GPU分配的编号存入vboID中(还没有真正分配显存)\nGLuint vboID = 0;\nglGenBuffers(1, &vboID);\n\n//创建多个vbo\nGLuint vboArr[] = {0,0,0};\nglGenBuffers(3, vboArr);\n\n//销毁\nglDeleteBuffers(1, &vboID);\nglDeleteBuffers(3, vboArr);\n\n//绑定插槽\nglBindBuffer(GL_ARRAY_BUFFER, vboID);\n    \n//向插槽绑定的空间填充数据(分配显存)\n//第四个参数：指定显卡管理数据的方式\n//GL_STATIC_DRAW:数据几乎不变\n//GL_DYNAMIC_DRAW:数据会被改变很多\n//GL_STREAM_DRAW:数据每次绘制都改变\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n```\n\n#### 多属性存储\n\nsingleBuffer 策略：每个属性存储为一个vbo\n\ninterleavedBuffer 策略：将所有属性存在一个vbo，数据交叉存储\n\n### VAO\n\nVertex Array Object, VAO\n\n存放一个Mesh网格的顶点描述信息，`core`模式要求使用VAO。\n\n存储的内容：\n\n* `glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 的调用\n* `glVertexAttribPointer` 设置的顶点属性配置\n* 通过 `glVertexAttribPointer` 调用顶点缓冲对象\n\n![img](https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png)\n\n#### Single buffer\n\n```c++\n//===创建\nGLuint VAO;\nglGenVertexArrays(1, &VAO);\n\n//===销毁\nglDeleteVertexArrays(1, &VAO);\n\n//===绑定VAO\nglBindVertexArray(VAO);\n\n//---绑定VBO，接下来VAO的操作从该VBO读取\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n//===激活VAO的0号位\nglEnableVertexAttribArray(0);\n\n//===设置顶点属性指针\n//index：描述第几个属性\n//size：属性包含几个变量\n//type：每个变量的数据类型\n//normalized：是否需要归一化\n//stride：整个顶点数据的步长\n//offset：这个属性在顶点数据中的偏移量\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n\n//---绑定下一个VBO\nglBindBuffer(GL_ARRAY_BUFFER, VBO2);\n\n//===激活VAO的1号位\nglEnableVertexAttribArray(1);\n\n//===设置第二个属性（由于在不同VBO，偏移量还是0）\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n\n//===解绑VAO\nglBindVertexArray(0);\n```\n\n#### interleaved buffer\n\n```c++\n//===创建\nGLuint VAO;\nglGenVertexArrays(1, &VAO);\n\n//===销毁\nglDeleteVertexArrays(1, &VAO);\n\n//===绑定VAO\nglBindVertexArray(VAO);\n\n//---绑定VBO，接下来VAO的操作从该VBO读取\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n//===激活VAO的0号位置（对应shader的location）\nglEnableVertexAttribArray(0);\n\n//===设置顶点属性指针\n//index：描述第几个属性\n//size：属性包含几个变量\n//type：每个变量的数据类型\n//normalized：是否需要归一化\n//stride：整个顶点数据的步长\n//offset：这个属性在顶点数据中的偏移量\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n\n//===激活VAO的1号位\nglEnableVertexAttribArray(1);\n\n//===设置第二个属性（在相同VBO内，要设置偏移量）\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(3 * sizeof(float)));\n\n//===解绑VAO\nglBindVertexArray(0);\n```\n\n### EBO\n\nElement Buffer Object，EBO \n\n又称索引缓冲对象(Index Buffer Object，IBO)\n\n> 绑定VAO后再绑定EBO或VBO，都会记录到当前VAO中\n\n```c++\nfloat vertices[] = {\n    0.5f, 0.5f, 0.0f,   // 右上角\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, -0.5f, 0.0f, // 左下角\n    -0.5f, 0.5f, 0.0f   // 左上角\n};\n\nunsigned int indices[] = {\n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n\nglGenBuffers(1, &mEbo);\nglGenVertexArrays(1, &mVao);\nglBindVertexArray(mVao);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ARRAY_BUFFER, mVbo);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);\n\n//解绑\nglBindVertexArray(0);\n```\n\n#### 绘制\n\n```c++\n//mode: GL_TRIANGLES,GL_LINES\n//count: 使用索引数组中几个索引\n//type: 索引的数据类型\n//indices: \n//\t\t\t①使用了EBO：数组内偏移量（一般传入0）\n//\t\t\t②没使用EBO：直接传入索引数组（效率较低）\nglDrawElements()\n```\n\n## 摄像机\n\n**摄像机决定了MVP中的projection和view矩阵**\n\n* 位置\n\n* 方向\n\n  通过 UP × 相机方向 得到右轴，\n\n  再通过 相机方向 × 右轴 得到正交的上轴。 \n\n![img](https://learnopengl-cn.github.io/img/01/09/camera_axes.png)\n\n创建LookAt矩阵：（P为摄像机位置）（坐标轴变换+平移）\n\n![image-20241222155156460](../images/image-20241222155156460.png)\n\n```c++\n//GLM:\nglm::mat4 view;\nview = glm::lookAt(cameraPos, //位置\n                  cameraPos + cameraFront,\t //目标点\n                  cameraUp); //上向量\n```\n\n* 角度\n\n欧拉角：\n\n![img](https://learnopengl-cn.github.io/img/01/09/camera_pitch_yaw_roll.png)\n\n摄像机方向向量：\n\n```c++\nglm::vec3 front;\nfront.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));\nfront.y = sin(glm::radians(pitch));\nfront.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));\ncameraFront = glm::normalize(front);\n```\n\n## 光照\n\nphong 光照模型：\n\n![3ca691007cece010fad8ddf4ba92572](../images/3ca691007cece010fad8ddf4ba92572.png)\n\n### 光照贴图\n\n* 漫反射贴图\n* 镜面光贴图\n\n## 测试\n\n### 深度测试\n\n```c++\n//开启\nglEnable(GL_DEPTH_TEST);\n\n//在每一帧清除缓冲\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n//禁用写入（只测试）\nglDepthMask(GL_FALSE);\n\n//深度测试运算符\nglDepthFunc(GL_LESS);\n```\n\n深度测试运算符选项：\n\n* GL_ALWAYS\n* GL_NEVER\n* GL_LESS：片段深度值**小于**缓冲深度值通过（默认）\n* GL_EQUAL\n* GL_LEQUAL\n* GL_GREATER\n* GL_NOTEQUAL\n* GL_GEQUAL\n\n在片元着色器中访问：\n\n```c++\nvoid main()\n{\n    //内建向量gl_FragCoord.z\n    FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\n}\n```\n\n### 模板测试\n\n```c++\n//开启\nglEnable(GL_STENCIL_TEST);\n\n//清除缓冲\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n\n//设置掩码\nglStencilMask(0xFF);  //全部位写入\nglStencilMask(0x00);  //全部位禁用 \n\n//模板函数\n//参数1：使用的运算符\n//参数2：比较值\n//参数3：掩码\n//通过测试，则绘制该像素\nglStencilFunc(GLenum func, GLint ref, GLuint mask)\n    \n//更新模板缓冲值\n//参数1：模板测试失败时的行为\n//参数2：模板测试通过，深度测试失败时的行为 \n//参数3：模板，深度测试均通过的行为    \nglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)    \n```\n\n模板缓冲更新选项：\n\n* GL_KEEP：保持不变（默认）\n* GL_ZERO：置0\n* GL_REPLACE：替换为ref值\n* GL_INCR：加1\n* GL_INCR_WRAP：加1，且循环\n* GL_DECR：减1\n* GL_DECR_WRAP：减1，且循环\n* GL_INVERT：按位反转\n\n## 面剔除\n\n通过分析三角形的**环绕顺序**，判断正面，背面\n\n![img](https://learnopengl-cn.github.io/img/04/04/faceculling_frontback.png)\n\n```c++\n//启用\nglEnable(GL_CULL_FACE);\n\n//剔除的面 ： GL_BACK/GL_FRONT/GL_FRONT_AND_BACK\nglCullFace(GL_FRONT);\n\n//定义环绕方向 ：GL_CCW 逆时针，GL_CW 顺时针\n//将逆时针的面定义为正向面↓\nglFrontFace(GL_CCW);\n```\n\n## 帧缓冲\n\n```c++\n//创建帧缓冲对象\nunsigned int fbo;\nglGenFramebuffers(1, &fbo);\n\n//绑定\n//GL_FRAMEBUFFER: 读写操作\n//GL_READ_FRAMEBUFFER: 只读\n//GL_DRAW_FRAMEBUFFER: 只写\nglBindFramebuffer(GL_FRAMEBUFFER, fbo);\n\n//判断帧缓冲是否完整\nif(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)\n    \n//删除\nglDeleteFramebuffers(1, &fbo);\n```\n\n完整的帧缓冲要满足以下条件：\n\n* 附加至少一个缓冲（颜色，深度，或模板缓冲）\n* 至少有一个颜色附件（Attachment）\n* 所有的附件都必须是完整的（保留了内存）\n* 每个缓冲都应该有相同的样本数（sample）\n\n### 渲染纹理\n\n把一个纹理附加到帧缓冲，可以让渲染的结果写入这个纹理。\n\n※帧缓冲中需要显式绑定深度缓冲，才能让渲染纹理的深测试生效\n\n```c++\nunsigned int texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\n\n//data参数传入NULL\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);\n\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n//附加到帧缓冲上\n//参数1：帧缓冲目标\n//参数2：附加类型\n//参数3：纹理类型\n//参数4：纹理本身\n//参数5：mipmap level\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);\n```\n\n## 绘制流程\n\n### 编译着色器\n\n```c++\n//着色器源码\nconst char *vertexShaderSource = \"#version 330 core\\n\"\n    \"layout (location = 0) in vec3 aPos;\\n\"\n    \"void main()\\n\"\n    \"{\\n\"\n    \"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\n    \"}\\0\";\n\n//创建着色器函数glCreateShader(着色器类型)\nunsigned int vertexShader;\nvertexShader = glCreateShader(GL_VERTEX_SHADER);\n\n//指定着色器源码glShaderSource(目标着色器, 源码字符串数量, 源码， )\nglShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\nglCompileShader(vertexShader);\n```\n\n* 检测编译是否成功\n\n```c++\nint  success;\nchar infoLog[512];\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n\nif(!success)\n{\n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n}\n```\n\n### 链接\n\n将多个着色器链接乘着色器程序对象。\n\n当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会报错。\n\n```c++\n//创建\nunsigned int shaderProgram;\nshaderProgram = glCreateProgram(); //返回一个ID\n\n//附加着色器，链接成程序\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram);\n\n//激活程序对象\nglUseProgram(shaderProgram);\n\n//链接后删除着色器对象\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n```\n\n* 链接顶点属性\n\n```c++\n//参数1：对应layout(location),顶点属性的位置值\n//参数2：顶点属性的大小，vec3即为3\n//参数3：指定数据类型 (vec*均为GL_FLOAT)\n//参数4：是否归一化数据(开启后，映射到0~1之间/有符号-1~1)\n//参数5：步长，即链接的顶点属性组之间的间隔\n//参数6：位置数据在缓冲中起始位置的偏移量，类型转换为void*\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n//启用顶点属性\nglEnableVertexAttribArray(0);\n```\n\n### 绘制\n\n* 准备**几何数据(vao,vbo)**，**材质数据(shader)**\n* 设置接下来绘制所使用的shader和vao\n* 发出**DrawCall**\n\n```c++\n//设置所使用的Shader程序\nglUseProgram(ProgramID);\n\n//设置所使用的VAO\nglBindVertexArray(vaoID);\n\n//发出渲染指令（绘制VAO）\n//mode:GL_TRIANGLES,GL_LINES\n//first:从当前第几个顶点开始绘制\n//count:绘制几个顶点\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n#### 绘制模式\n\n| 绘制模式          |                                                     |\n| ----------------- | --------------------------------------------------- |\n| GL_TRIANGLES      | 每三个顶点连成三角形，不足3个则忽略，每个点只用一次 |\n| GL_TRIANGLE_STRIP | 复用连接过的点                                      |\n| GL_TRIANGLE_FAN   | 以0为起点，每两个点都与0号点连接                    |\n| GL_LINES          | 每两个定点构成直线，每个点只用一次                  |\n| GL_LINE_STRIP     | 所有点依次连接                                      |\n\nGL_TRIANGLE_STRIP：（保证每个三角形的连接方向都相同）\n\n![image-20241228131532564](../images/image-20241228131532564.png)\n\nGL_TRIANGLE_FAN：\n\n![image-20241228131615993](../images/image-20241228131615993.png)\n\n## 着色器类的封装\n\n```c++\n#ifndef SHADER_H\n#define SHADER_H\n\n#include <glad/glad.h>; // 包含glad来获取所有的必须OpenGL头文件\n\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n\nclass Shader\n{\npublic:\n    // 程序ID\n    GLuint ID;\n\n    // 构造器读取并构建着色器\n    Shader(const char* vertexPath, const char* fragmentPath);\n    \n    // 使用/取消使用程序\n    void begin();\n    void end();\n    \n    // uniform工具函数\n    void setBool(const std::string &name, bool value) const;  \n    void setInt(const std::string &name, int value) const;   \n    void setFloat(const std::string &name, float value) const;\n};\n\n#endif\n```\n\n### 构造函数\n\n```c++\n#include <string>\n#include <fstream>\n#include <sstream>\n\nShader(const char* vertexPath, const char* fragmentPath)\n{\n    // 1. 从文件路径中获取顶点/片段着色器\n    std::string vertexCode;\n    std::string fragmentCode;\n    std::ifstream vShaderFile;\n    std::ifstream fShaderFile;\n    // 保证ifstream对象可以抛出异常：\n    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n    try \n    {\n        // 打开文件\n        vShaderFile.open(vertexPath);\n        fShaderFile.open(fragmentPath);\n        std::stringstream vShaderStream, fShaderStream;\n        // 读取文件的缓冲内容到数据流中\n        vShaderStream << vShaderFile.rdbuf();\n        fShaderStream << fShaderFile.rdbuf();       \n        // 关闭文件处理器\n        vShaderFile.close();\n        fShaderFile.close();\n        // 转换数据流到string\n        vertexCode   = vShaderStream.str();\n        fragmentCode = fShaderStream.str();     \n    }\n    catch(std::ifstream::failure e)\n    {\n        std::cout << \"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\" << std::endl;\n    }\n    const char* vShaderCode = vertexCode.c_str();\n    const char* fShaderCode = fragmentCode.c_str();\n    [...]\n```\n\n## 纹理\n\n### stbImage库\n\n读取图片：\n\n```c++\nint width, height, channels;\n//stbi_load(相对文件路径，图片宽度，图片高度，读取的格式，输出的格式)\nunsigned char* data = stbi_load(\"assets/textures/container.jpg\", &width, &height, &channels, STBI_rgb_alpha);\n\n//载入时翻转y轴\nstbi_set_flip_vertically_on_load(true);\n\n//释放资源\nstbi_image_free(data);\n```\n\n## 纹理单元\n\n采样器和纹理对象的中间层\n\n至少有0~15号\n\n![image-20241229132512504](../images/image-20241229132512504.png)\n\n### 纹理采样\n\n> 激活纹理单元后绑定纹理对象，可以将对象与单元连接\n>\n> (如果不先激活，默认激活0号单元)\n>\n> ※激活纹理单元无法关闭，只能激活其他纹理单元\n\n```c++\n//创建纹理对象（与VBO类似）\n//个数，ID数组\nglGenTextures(1，&texture);\n\n//激活纹理单元\nglActiveTexture(GL_TEXTURE0);\n    \n//绑定纹理对象到状态机插槽\nglBindTexture(GL_TEXTURE_2D, texture);\n\n//开辟显存，传输数据\nglTexImage2D(\n\tGLenum target,\t\t//目标插槽\n    GLint level,\t\t//mipmap层级\n    GLint internalformat,\t\t//目标在显存中的图片格式（GL_RGBA）\n    GLsizei width, GLsizei height,\t\t//宽高\n    GLint border,\t\t//填0\n    GLenum format,\t\t//内存中的图片格式（GL_RGBA）\n    GLenum type,\t\t//每个通道的数据格式（GL_UNSIGNED_BYTE）\n    const void *pixels\t//原始数据指针\n)\n```\n\n### 纹理过滤\n\n设置纹理过滤方式：\n\n```c++\nglTexParameteri(GL_TEXTURE_2D,\t\t\t//目标插槽\n                GL_TEXTURE_MIN_FILTER \t//放大还是缩小过滤\n                \t↑or↓\n                GL_TEXTURE_MAG_FILTER,\n                GL_LINEAR\t\t\t\t//过滤方式\n               );\n```\n\n#### Nearest\n\n`GL_NEAREST`\n\n临近过滤（nearest neighbor filtering）：取最近像素值\n\n复用像素，变成像素画的风格\n\n**缩小过滤使用**\n\n#### Bilinear\n\n`GL_LINEAR`\n\n双线性插值过滤：用周围4个像素颜色计算加权平均\n\n**放大过滤使用**\n\n#### Mipmap\n\n`GL_LINEAR`：在层级内用插值\n\n`MIPMAP_NEAREST`：在不同层级间选择邻近的层级\n\n`GL_NEAREST`：在层级内用邻近采样\n\n`MIPMAP_LINEAR`：在不同层级间取插值\n\n```c++\n//设置后自动采样mipmap（不需要在shader中手动写）\nglTexParameteri(GL_TEXTURE_2D,\t\t\t\n                GL_TEXTURE_MIN_FILTER,\n                GL_NEAREST_MIPMAP_LINEAR\n               );\n```\n\n※mipmap只能用于**缩小过滤**\n\n**①** mipmap的生成：\n\n* 滤波（模糊处理）\n* 采样\n\n离散高斯核心：\n\n```c++\n[0.09474, 0.11832, 0.09474,\n 0.11831, 0.14776, 0.11831,\n 0.09474, 0.11832, 0.09474]\n```\n\n**②** 距离判定：\n\n> 在片元着色器中，并不是每个片元单独处理，而是打包成2*2的区块进行处理。\n>\n> 因此可以通过偏导函数得到某个属性的**变化量**：\n>\n> ` dFdx() `，` dFdy() `\n>\n> 当纹理需要缩小到**1个像素对应n*n个纹素**，需要采样log~2~(n)级mipmap。\n>\n> 如果长宽**不等比**缩放，采样较高级别的mipmap\n>\n> 或在两个方向上分别采样mipmap\n\n```glsl\n//--手动在shader中实现mipmap采样--\n//获取当前像素中心点对应纹理的坐标\nvec2 location = uv*vec2(textureWidth, textureHeight);\n\n//获取坐标在周边像素的变化量，即两个片元跨过的纹素\nvec2 dx = dFdx(location);\nvec2 dy = dFdy(location);\n\n//求level,L<0,图片被放大，不考虑mipmap\nfloat maxDelta = sqrt(max(dot(dx,dx),dot(dy,dy)));\nfloat L = log2(maxDelta);\nint level = max(int(L+0.5),0);\n```\n\n③OpenGL载入：\n\n```c++\n//手动传入\n//在level中传入0以上的数字，自动开启mipmap，需要添加到1x1的图像\nglTexImage2D();\n\n//自动生成\nglGenerateMipmap(GL_TEXTURE_2D);\nglTexParameteri(GL_TEXTURE_2D,\t\t\t\n                GL_TEXTURE_MIN_FILTER,\n                GL_NEAREST_MIPMAP_LINEAR\n               );\n```\n\n### Wrapping\n\n* `GL_REPEAT`：重复\n* `GL_MIRRORED_REPEAT`：镜像重复\n* `GL_CLAMP_TO_EDGE`：复用边缘颜色\n* `GL_CLAMP_TO_BORDER`：设置一个颜色\n\n设置Wrapping：\n\n```c++\nglTexParameteri(GL_TEXTURE_2D,\t\t\t//目标插槽\n                GL_TEXTURE_WRAP_S \t\t//横向pr纵向\n                \t↑or↓\n                GL_TEXTURE_WRAP_T,\n                GL_REPEAT\t\t\t\t//wrap方式\n               );\n```\n\n### 采样器\n\nshader中：\n\n```glsl\n//声明\nuniform sampler2D mainTex;\n\nvoid main(){\n    //采样\n    FragColor = texture(mainTex, uv);\n}\n```\n\n程序中：\n\n```c++\n//向sampler的location传入纹理单元的编号\nglUniform1i(mainTexLocation,0);\n```\n\n## CubeMap\n\n```c++\n//自动采样来自不同面的临近点\nglEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);\n```\n\n### 环境渲染\n\n①最先渲染环境，且不写入深度缓冲\n\n缺点：被物体遮挡的环境依然会被渲染\n\n```c++\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nglDepthMask(GL_FALSE);\n// draw background\nglDepthMask(GL_TRUE);\n// draw objects\n```\n\n②屏幕空间渲染背景\n\n\n\n# Assimp\n\n**Open Asset Import Library**\n\n![img](https://learnopengl-cn.github.io/img/03/01/assimp_structure.png)\n\n### Mesh\n\n```c++\nclass Mesh{\n    public:\n        /*  网格数据  */\n        vector<Vertex> vertices;\n        vector<unsigned int> indices;\n        vector<Texture> textures;\n        /*  函数  */\n        Mesh(vector<Vertex> vertices, vector<unsigned int> indices, vector<Texture> textures);\n        void Draw(Shader shader);\n    private:\n        /*  渲染数据  */\n        unsigned int VAO, VBO, EBO;\n        /*  函数  */\n        void setupMesh();\n}\n\n//初始化\nvoid setupMesh()\n{\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n    //由于struct在内存上连续分布，可以直接传入buffer\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);  \n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), \n                 &indices[0], GL_STATIC_DRAW);\n\n    // 顶点位置\n    glEnableVertexAttribArray(0);   \n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);\n    // 顶点法线\n    glEnableVertexAttribArray(1);   \n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));\n    // 顶点纹理坐标\n    glEnableVertexAttribArray(2);   \n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));\n\n    glBindVertexArray(0);\n}  \n\n//渲染\nvoid Draw(Shader shader) \n{\n    unsigned int diffuseNr = 1;\n    unsigned int specularNr = 1;\n    for(unsigned int i = 0; i < textures.size(); i++)\n    {\n        glActiveTexture(GL_TEXTURE0 + i); // 在绑定之前激活相应的纹理单元\n        // 获取纹理序号（diffuse_textureN 中的 N）\n        string number;\n        string name = textures[i].type;\n        if(name == \"texture_diffuse\")\n            number = std::to_string(diffuseNr++);\n        else if(name == \"texture_specular\")\n            number = std::to_string(specularNr++);\n\n        shader.setInt((\"material.\" + name + number).c_str(), i);\n        glBindTexture(GL_TEXTURE_2D, textures[i].id);\n    }\n    glActiveTexture(GL_TEXTURE0);\n\n    // 绘制网格\n    glBindVertexArray(VAO);\n    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);\n    glBindVertexArray(0);\n}\n```\n\n### Model\n\n```c++\nclass Model \n{\n    public:\n        /*  函数   */\n        Model(char *path)\n        {\n            loadModel(path);\n        }\n        void Draw(Shader shader);   \n    private:\n        /*  模型数据  */\n        vector<Mesh> meshes;\n        string directory;\n        /*  函数   */\n        void loadModel(string path);\n        void processNode(aiNode *node, const aiScene *scene);\n        Mesh processMesh(aiMesh *mesh, const aiScene *scene);\n        vector<Texture> loadMaterialTextures(aiMaterial *mat, aiTextureType type, \n                                             string typeName);\n};\n\nvoid Draw(Shader &shader)\n{\n    for(unsigned int i = 0; i < meshes.size(); i++)\n        meshes[i].Draw(shader);\n}\n\nvoid loadModel(string path)\n{\n    Assimp::Importer import;\n    const aiScene *scene = import.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);    \n\n    if(!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) \n    {\n        cout << \"ERROR::ASSIMP::\" << import.GetErrorString() << endl;\n        return;\n    }\n    directory = path.substr(0, path.find_last_of('/'));\n\n    processNode(scene->mRootNode, scene);\n}\n\n//递归处理网格可以定义网格间的父子关系，方便一并变换所有子网格\nvoid processNode(aiNode *node, const aiScene *scene)\n{\n    // 处理节点所有的网格（如果有的话）\n    for(unsigned int i = 0; i < node->mNumMeshes; i++)\n    {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]]; \n        meshes.push_back(processMesh(mesh, scene));         \n    }\n    // 接下来对它的子节点重复这一过程\n    for(unsigned int i = 0; i < node->mNumChildren; i++)\n    {\n        processNode(node->mChildren[i], scene);\n    }\n}\n\nMesh processMesh(aiMesh *mesh, const aiScene *scene)\n{\n    vector<Vertex> vertices;\n    vector<unsigned int> indices;\n    vector<Texture> textures;\n\n    for(unsigned int i = 0; i < mesh->mNumVertices; i++)\n    {\n        Vertex vertex;\n        // 处理顶点位置、法线和纹理坐标\n        ...\n        vertices.push_back(vertex);\n    }\n    // 处理索引\n    ...\n    // 处理材质\n    if(mesh->mMaterialIndex >= 0)\n    {\n        ...\n    }\n\n    return Mesh(vertices, indices, textures);\n}\n```\n\n### Assimp加载模型\n\n```c++\nAssimp::Importer importer;\nconst aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);\n```\n\n常用选项：\n\n* aiProcess_Triangulate：将所有图元转换为三角形\n* aiProcess_FlipUVs：反转y轴纹理坐标\n* aiProcess_GenNormals：如果模型不包含法向量，就创建法线\n* aiProcess_SplitLargeMeshes：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。\n* aiProcess_OptimizeMeshes：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。\n\n# GLSL\n\n## 基本结构\n\n`location=n`表示去VAO的第n个属性去取数据\n\n```c++\n#version 330 core\nlayout(location = 0)in type in_variable_name;\nlayout(location = 1)in type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nvoid main()\n{\n  // 处理输入并进行一些图形操作\n  ...\n  // 输出处理过的结果到输出变量\n  out_variable_name = weird_stuff_we_processed;\n}\n```\n\n## 内置变量\n\n| 内置变量    |         |\n| ----------- | ------- |\n| gl_Position | NDC坐标 |\n|             |         |\n|             |         |\n\n## 编译Shader\n\n```c++\n//创建Shader程序 GL_VERTEX_SHADER/GL_FRAGMENT_SHADER\nGLuint shaderID = glCreateShader(GL_VERTEX_SHADER);\n\n//向Shader注入源代码\n//参数1：shader程序的ID\n//参数2：字符串数量\n//参数3：字符串数组\n//参数4：字符串数组中每个串的长度\nglShaderSource(shaderID, 1, &vertexShaderSource, NULL);\n\n//编译Shader\nglCompileShader(shaderID);\n\n//检查编译结果\nint success = 0;\nchar infoLog[1024];\nglGetShaderiv(shaderID, GL_COMPILE_STATUS, &success);\nif(!success){\n\tglGetShaderInfoLog(shaderID, 1024, NULL, infoLog);\n    std::cout << infoLog <<std::endl; \n}\n```\n\n#### 链接\n\n```c++\n//创建可执行程序\nGLuint programID = glCreateProgram()\n    \n//将编译好的shader程序添加到program中\nglAttachShader(programID, vertexID);\nglAttachShader(programID, fragmentID);\n\n//链接\nglLinkProgram(programID);\n\n//检查链接错误\nint success = 0;\nchar infoLog[1024];\nglGetProgramiv(programID, GL_LINK_STATUS, &success);\nif(!success){\n\tglGetProgramInfoLog(program, 1024, NULL, infoLog);\n    std::cout << infoLog <<std::endl; \n}\n\n//清除源代码\nglDeleteShader(vertexID);\nglDeleteShader(fragmentID);\n```\n\n## 顶点属性\n\n在顶点着色器中，输入变量也叫**顶点属性**\n\n顶点属性的上限由硬件决定，OpenGL确保至少有16个包含4分量的顶点属性可用\n\n通过`GL_MAX_VERTEX_ATTRIBS`可以查看上限\n\n```c++\nint nrAttributes;\nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);\nstd::cout << nrAttributes << std::endl;\n```\n\n### 数据类型\n\n基本类型：`int`，`float(32bit)`，`double(64bit)`，`uint`，`bool`\n\n容器类型：`Vector`，`Matrix`\n\n#### 向量\n\n有`vec`,`bvec`,`ivec`,`uvec`,`dvec`\n\n```c++\n//重组\nvec2 someVec;\nvec4 differentVec = someVec.xyxx;\nvec3 anotherVec = differentVec.zyw;\nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n\n//传入构造函数\nvec2 vect = vec2(0.5, 0.7);\nvec4 result = vec4(vect, 0.0, 0.0);\nvec4 otherResult = vec4(result.xyz, 1.0);\n```\n\n## 输入输出\n\n> vertexShader的输出和fragmentShader的输入名字一致即可调用。\n\n顶点着色器的输入要标识location：\n\n```c++\nlayout (location = 0) in vec3 aPos;   // 位置变量的属性location值为 0 \nlayout (location = 1) in vec3 aColor; // 颜色变量的属性location值为 1\n\n//程序中的顶点数据\nfloat vertices[] = {\n    // 位置              // 颜色\n     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 一个顶点的数据，包含位置和颜色\n    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   \n     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    \n};\n\n//加载到缓冲\n// 位置属性\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n// 颜色属性\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));\nglEnableVertexAttribArray(1);\n\n//不设置location，动态获取\nGLuint posLocation = glGetAttribLocation(programID, \"aPos\");\nglVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(posLocation);\n```\n\n## Uniform\n\n* uniform是**全局的**，即每个uniform变量必须在所有着色器中独一无二\n\n* uniform可以被着色器程序的任意着色器在任意阶段访问\n\n* uniform会保存数据，直到它们被重置或刷新\n* 可以用于在程序和着色器之间交互\n\n### 声明\n\n在任意着色器中声明\n\n```c++\n#version 330 core\nout vec4 FragColor;\n\nuniform vec4 ourColor; \n\n//也可以自定义结构体作为uniform\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n}; \n\nuniform Material material;\n\nvoid main()\n{\n    FragColor = ourColor;\n}\n```\n\n### 赋值\n\n在OpenGL程序中赋值\n\n```c++\nfloat timeValue = glfwGetTime();\nfloat greenValue = (sin(timeValue) / 2.0f) + 0.5f;\n\n//获取\n//返回-1表示没有找到该uniform\nint vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\n\nglUseProgram(shaderProgram);\n\n//赋值\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n```\n\n※查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你**必须**先使用程序（调用`glUseProgram`)，因为它是在当前激活的着色器程序中设置uniform的。\n\n## 内置函数\n\n### mix\n\n混合两个值\n\n`mix(a,b,value)` = a * (1-value) + b * value\n\n## Compute Shader\n\n用于通用并行计算的shader\n\n资源：\n\n* Read Only：`Uniform变量`，`Buffers`，`Textures`\n* Read/Write：`Images`，`Shader Storage Buffer`\n\n### 核心概念\n\n* 工作组（WorkGroup）：\n  * 每个工作组包含{local_size_x * local_size_y * local_size_z }个线程\n  * 工作组内的线程可以通过共享内存（`shared variable`）高效通信。\n  * Workgroup.xyz>=64k\n  * LocalSize.xy>=1k\n  * LocalSize.z>=64\n  \n* GLSL的内部变量：\n  * `uvec3 gl_LocalInvocationID`：工作组内的线程ID\n  * `uvec3 gl_GlobalInvocationID`：全局线程ID\n  * `uvec3 gl_WorkGroupID`：工作组ID\n  * `uvec3 gl_NumWorkGroups`：工作组大小\n  \n  ```c++\n  //获取组内线程最大值\n  glGetInteger_iv(GL_MAX_COMPUTE_WORK_GROUP_COUNT,0/1/2,&x/&y/&z);\n  \n  //获取工作组数最大值\n  glGetInteger_iv(GL_MAX_COMPUTE_WORK_GROUP_SIZE,0/1/2,&x/&y/&z);\n  ```\n  \n  ※工作组内可以访问共享的变量，但不同工作组访问同一个变量会导致死锁\n\n### Images\n\n```glsl\n// GLSL \n// IMAGE_COORD:整型像素坐标\ngvec4 imageLoad(gimage img, IMAGE_COORD);\ngvec4 imageStore(gimage img, IMAGE_COORD, gvec4 data);\n\ngint imageAtomicExchange(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicCompSwap(gimage img, IMAGE_COORDS, gint compare,gint data);\ngint imageAtomicAdd(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicAnd(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicOr(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicXor(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicMin(gimage img, IMAGE_COORDS, gint data);\ngint imageAtomicMax(gimage img, IMAGE_COORDS, gint data);\n```\n\n* `image2D`：float\n* `iimage2D`：int\n* `uimage2D`：uint\n\n| GLSL                      | OpenGL                          |\n| ------------------------- | ------------------------------- |\n| gimage{*x*}D (x=1~3)      | GL_TEXTURE_{*x*}D               |\n| gimageCube                | GL_TEXTURE_CUBE_MAP             |\n| gimage2Drect              | GL_TEXTURE_RECTANGLE            |\n| gimage{*x*}DArray (x=1~2) | GL_TEXTURE_{*x*}D_ARRAY         |\n| gimageCubeArray           | GL_TEXTURE_CUBE_MAP_ARRAY       |\n| gimageBuffer              | GL_TEXTURE_BUFFER               |\n| gimage2DMS                | GL_TEXTURE_2D_MULTISAMPLE       |\n| gimage2DMSArray           | GL_TEXTURE_2D_MULTISAMPLE_ARRAY |\n| ...                       | ...                             |\n\n### SSBO\n\n**GLSL中**\n\nshader storage buffer object\n\n```c++\nGLuint ssbo;\nglGenBuffers(1, &ssbo);\nglBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo);\nglBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(data), data, GL_STATIC_READ);\n\n// p2:bufferID\nglBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, ssbo);\n\n// unbind\nglBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);\n```\n\n### 编译ComputeShader\n\n```c++\nGLuint computeShader = glCreateShader(GL_COMPUTE_SHADER);\nglShaderSource(cs, 1, &source, NULL);\nglCompileShader(cs);\n\nGLuint computeProgram = glCreateProgram();\nglAttachShader(prog, cs);\nglLinkProgram(prog);\n```\n\n### 启用\n\n```c++\nglUseProgram(computeProgram);\nglDispathCompute(size_x,size_y,size_z); //workgroupSize\n\nglMemoryBarrier(GL_ALL_BARRIER_BITS);\n```\n\n\n\n# GLM\n\n## 变量\n\n```c++\n//向量\nglm::vec2 v0(0);\nglm::vec3 v0(0);\nglm::vec4 v0(0);\nauto mul = v0 * v0;\nauto dot = glm::dot(v0, v0);\nauto cross = glm::cross(v0, v0); //只能使用3维向量\n\n//矩阵\nglm::mat2 m0(1.0);\nglm::mat3 m0(1.0);\nglm::mat4 m0(1.0);\nglm::mat2x3 m0(1.0);\nglm::mat4 m1 = glm::identity<glm::mat4>();\n\n//打印矩阵\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/string_cast.hpp>\ncout << glm::to_string(m1) <<endl;\n```\n\n","tags":["编程","游戏","C++"],"categories":["程序设计","图形学"]},{"title":"Unity学习笔记","url":"/2024/09/29/my-Unity-learning-note/","content":"\n> Always separate the logic from the visuals in your game objects.\n\n<!--more-->\n\n# 常见问题\n\n## VsCode作为默认编辑器\n\n**STEP1：**在Package Manager中安装`Visual Studio Code Editor`\n\n**STEP2：**在`Edit -> Preferences -> ExternalTools`中修改External Script Editor为VsCode后，**在Browse中选到VsCode的exe文件**。\n\n## Animator中使用Trigger的时机\n\n从`Any State`转到`State1`时，为了防止`State1`转到`State1`，用单次触发的Trigger变量\n\n## 打开VsCode后开始下载.NET\n\n在settings.json中加上以下内容\n\n```json\n    \"dotnetAcquisitionExtension.existingDotnetPath\": [\n        {\n            \"extensionId\": \"ms-dotnettools.csharp\",\n            \"path\": \"C:\\\\Program Files\\\\dotnet\\\\dotnet.exe\"\n        },\n        {\n            \"extensionId\": \"visualstudiotoolsforunity.vstuc\",\n            \"path\": \"C:\\\\Program Files\\\\dotnet\\\\dotnet.exe\"\n        }\n    ],\n```\n\n# Inspector 标签\n\n`HideInInspector`：使变量在检视器中不可见\n\n`ReadOnly`：使变量在检视器中不可编辑\n\n`DefaultExecutionOrder(NUMBER)`：修改脚本的优先级\n\n`RuntimeInitializeOnLoadMethod`：让脚本的静态方法成为入口方法，并在所有脚本的Awake()之前执行\n\n`Range(0,100)`：限制参数范围\n\n`Tooptip(\"提示\")`：鼠标悬浮提示\n\n## 序列化\n\n`System.Serializable`：序列化一个类\n\n`System.NonSerialized`：表示属性不参与序列化\n\n`SerializeField`：让私有属性参与序列化\n\n`SerializeReference`：序列化一个引用\n\n`Serializable`：序列化自定义的`struct`等列表时使用\n\n```c#\n[System.Serializable]\npublic class Data\n{\n    public int a; //序列化\n    [System.NonSerialized] \n    public int b; //不序列化\n}\n\n[Serializable]\npublic struct SO_KitchenObj_GameObj\n{\n    public SO_KitchenObj kitchenObjSO;\n    public GameObject gameObject;\n}\n\n[SerializeField]\nprivate Data data; //序列化\n```\n\n## Header\n\n`[Header(\"name\")]`：在面板中添加标记，方便查看。\n\n## 强绑定脚本\n\n`[RequireComponent(typeof(\"类名\"),typeof(\"...\"))]`\n\n自动导入关联的脚本，并且限制手动无法删除依赖的脚本\n\n# 脚本生命周期\n\n## 脚本的执行顺序\n\n在`ScriptExecution Order`中可以设置脚本的执行顺序，数值越小越先执行。\n\n※Unity在执行生命周期方法时要通过遍历找到所有脚本，然后反射调用每个脚本的方法，因此**脚本绑定越多，执行效率越低**。\n\n※不要在脚本内留下**空的**生命周期方法。\n\n## 初始化\n\n| 执行顺序   | 执行时机                          |\n| ---------- | --------------------------------- |\n| Awake()    | 脚本被首次初始化时                |\n| OnEnable() | 每当脚本被启动(勾选)时            |\n| Reset()    | 只在编辑模式下执行                |\n| Start()    | 在所有Awake()执行完后的下一帧执行 |\n\n在`Awake()`中初始化**脚本内**数据，在`start()`中访问**脚本外或其他脚本**数据。\n\n`Awake()`和`OnEnable()`在第0帧执行，`start()`和`Update()等`在第一帧执行。\n\n## 循环\n\n### 固定更新\n\n对帧率有稳定要求的地方使用，如动画系统，物理系统。`FixedUpdate()`依赖于每帧执行的`Update()`，如果帧率不稳定，`FixedUpdate()`可能在一帧里执行多次。\n\n| 执行顺序                   |                                                              |\n| -------------------------- | ------------------------------------------------------------ |\n| FixedUpdate()              | 默认每0.02s调用一次，在`TimeManager -> Fixed Timestep`中修改 |\n| 内部动画更新               |                                                              |\n| 内部物理更新               |                                                              |\n| OnTriggerXXX               | 碰撞的回调事件                                               |\n| OnCollisioinXXX            |                                                              |\n| yield `WaitForFixedUpdate` | 协程回调，表示：*等待下一个FixedUpdate()执行完毕*            |\n\n### 逻辑更新\n\n| 执行顺序                                             |              |\n| ---------------------------------------------------- | ------------ |\n| Update()                                             |              |\n| yield `null` `WaitForSeconds` `WWW` `StartCoroutine` | 部分协程回调 |\n| 动画系统的每帧更新，内部逻辑                         |              |\n| Late Update()                                        |              |\n\n### 场景渲染\n\n| 执行顺序           |                            |\n| ------------------ | -------------------------- |\n| OnPreCull          | 场景被摄像机裁剪之前       |\n| OnWillRenderObject | 物体对当前摄像机可见时     |\n| OnBecameVisible    | 物体对任意摄像机可见时     |\n| OnBecameInvisible  | 物体对所有摄像机都不可见时 |\n| OnPreRender        | 摄像机开始渲染场景前       |\n| OnRenderObject     | 摄像机开始渲染场景后       |\n| OnPostRender       | 摄像机完成渲染场景后       |\n| OnRenderImage      | 全部渲染完毕后             |\n\n### 编辑器UI更新\n\n| 执行顺序                  |                        |\n| ------------------------- | ---------------------- |\n| OnDrawGizmos              | `OnDraw...`系列API调用 |\n| OnGUI                     | 早期制作界面的接口     |\n| yield `WaitForEndOfFrame` |                        |\n| OnApplicationPause        |                        |\n\n## 销毁\n\n| 执行顺序            | 执行时机     |\n| :------------------ | ------------ |\n| OnApplicationQuit() | 程序退出时   |\n| OnDisable()         | 脚本被关闭时 |\n| OnDestroy()         | 脚本被销毁时 |\n\n# Events\n\n事件分为`Publisher/广播者`和`Subscriber/监听者`，多个`Subscriber`可以监听同一个Event。\n\n事件的`Publisher`不关心事件的`Subscriber`,在游戏中，可以由游戏逻辑发送事件，让游戏表现监听事件，从而实现逻辑和表现的分离。\n\n## C# Events\n\n```c#\n//声明\npublic event EventHandler OnSpacePressed;\n\n//带参数的声明\npublic event EventHandler<OnSpacePressedArgs> OnSpacePressed;\npublic class OnSpacePressedArgs : EventArgs{\n    public int counter;\n}\n\n//广播事件\n{\n    //判断有无监听者\n    if(OnSpacePressed != null){\n    \tOnSpacePressed(this,EventArgs.Empty);        \n    }\n    \n    //或简写\n    OnSpacePressed?.Invoke(this,EventArgs.Empty);\n}\n\n//监听事件\nprivate void OnEnable()\n{\n    <组件实例>.OnSpacePressed += HandleSpacePressed;\n}\n\n//取消监听\nprivate void OnDisable()\n{\n    <组件实例>.OnSpacePressed -= HandleSpacePressed;    \n}\n```\n\n# 协程\n\n※协程不是多线程\n\n语法：\n\n```c#\n//协程方法：\nIEnumerator Func()\n{\n    Debug.Log(\"1\");\n    yield return '※协程回调';\n   \tDebug.Log(\"2\");\n}\n\nvoid Func2(){\n    //启动协程\n    StartCoroutine(Func());\n    \n    //关闭协程\n    StopCoroutine(Func());\n    \n    //关闭所有协程\n    StopAllCoroutines();\n    \n    //启动其他脚本的协程\n    GetComponent<ComponentName>().StartCoroutine(Func());\n}\n```\n\n协程回调：\n\n| 方法                         | 时机                         |\n| ---------------------------- | ---------------------------- |\n| null                         | 等待一帧                     |\n| new WaitForSeconds(1)        | 等待固定时间                 |\n| new WaitForSecondRealtime(1) | 等待固定时间，且忽略时间缩放 |\n\n# 脚本\n\n## 脚本序列化\n\n使用`public`声明的属性会被序列化。标注`[System.NonSerialized]`可以让属性不参与序列化，防止浪费内存。\n\n## DontDestroyOnLoad\n\n使用`DontDestroyOnLoad(GameObject)`标记的游戏对象在切换场景时不会销毁。（默认会卸载场景中的所有游戏对象和脚本）\n\n## 父类转子类（里氏转换）\n\n```c#\n\nif (parent != null && parent.GetType() == typeof(Son))\n{\n\tSon son = parent as Son;\n    son.func();\n}\n```\n\n## Interface 接口\n\n一个接口可以实现另一个接口\n\n```c#\n//定义\npublic interface IOwner <: 另一个接口>\n{\n    //只能使用property，不能使用field\n    public KitchenObj KitchenObj { get; set; }\n    \n    public void ClearKitchenObject();\n    public void GetKitchenObject();\n\n}\n\n```\n\n## Singleton 单例模式\n\n```c#\n//方案1\npublic class DataManager:MonoBehaviour\n{\n\tpublic static DataManager instance;\n    \n    private void Awake()\n    {\n        //确保只有一个实例\n        if (instance == null)\n            instance = this;\n        else\n            Destroy(this.gameObject);\n    }\n}\n\n//方案2\npublic class Player : MonoBehaviour\n{\n    //设为 类外只读权限\n    public static Player Instance { get; private set; }\n    \n    private void Awake()\n    {\n        //在多于一个实例时报错\n        if(Instance!=null){\n            Debug.LogError(\"Player is not singleton\");\n        }\n        Instance = this;\n    }    \n}\n```\n\n## 获取组件\n\n```c#\n//返回布尔值\ntransform.TryGetComponent(out <类名(组件名)> 实例形参)\n```\n\n### TryGet 实现\n\n```C#\npublic bool TryGetPlate(out PlateObj plateObj)\n{\n\tif (this is PlateObj)\n\t{\n\t\tplateObj = this as PlateObj;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tplateObj = null;\n\t\treturn false;\n\t}\n}\n```\n\n## EnumFlags\n\n使用枚举类型的Flag可以用来判断菜单，配方等。\n\n```c#\n//定义\n[Flags] //使变量在Inspector中可以多选\npublic enum KitchenObjEnum\n{\n    Plate = 1,\n    Bread = 1 << 1,\n    Cabbage = 1 << 2,\n    Cabbage_Slices = 1 << 3,\n    Cheese = 1 << 4,\n    Cheese_Slices = 1 << 5,\n    Meat_Burned = 1 << 6,\n    Meat_Cooked = 1 << 7,\n    Meat_Uncooked = 1 << 8,\n    Tomato = 1 << 9,\n    Tomato_Slices = 1 << 10,\n}\n```\n\n\n\n# GameObject\n\n```c#\n//激活或销毁游戏对象\n<游戏对象实例>.SetActive(true/false);\n```\n\n# Prefab\n\nPrefab（预制体）\n\n## Instantiate 创建实例\n\n```c#\npublic class <组件> : MonoBehaviour\n{\n    [SerializeField] private Transform prefab;\n    \n    private void Update(){\n        if(Input.GetKeyDown(KeyCode.T)){\n            Transform prefabTransform = Instantiate(prefab);\n        }\n    }\n}\n```\n\n\n\n# Tag\n\n## 特殊tag：EditorOnly\n\n`EditorOnly`：标记后，打包游戏时会自动忽略该游戏对象\n\n## 相关方法\n\n`GameObject.FindGameObjectWithTag(\"tagName\")`：通过tag找到游戏对象\n\n```c#\nforeach (var item in GameObject.FindGameObjectsWithTag(\"tagName\"))\n{\n    //获取所有tagName的对象并遍历\n}\n```\n\n# InputSystem\n\n## 导入项目\n\n`Package Manager -> input System -> install` \n\n## 修改生效的输入方式\n\n`Edit -> Project Settings -> Player -> Other Settings -> Active Input Handling`\n\n## 创建InputAction\n\n`Project -> [new]Input Action`\n\n![image-20241018165500463](../images/image-20241018165500463.png)\n\n## 生成Input Action的C#类\n\n![image-20241018140338995](../images/image-20241018140338995.png)\n\n## 引入input action\n\n```c#\n//使用单例模式\npublic static InputSystem Singleton {get;private set;}\n\nprivate PlayerInputControls inputControls;\n\nprivate void Awake(){\n    //创建实例\n    inputControls = new PlayerInputControls();\n}\n\n//启动\nprivate void OnEnable(){\n    inputControls?.Enable();\n}\n\n//关闭\nprivate void OnDisable()\n{\n\tinputControl?.Disable();\n}\n    \n//按帧读取输入值\nVector2 inputDir = inputControl.<MAP名>.<Action名>.ReadValue<Vector2>();\n\n//注册事件\ninputControls.<MAP名>.<Action名>.started/canceled/performed += <函数名>\n\n//示例（回调函数）\ninputControl.GamePlay.WalkButton.performed += ctx =>\n{\n    if (physicsCheck.isGround)\n    \tspeed = walkSpeed;\n};\n\n//全局事件（需引入UnityEngine.InputSystem）\n //输入设备发生变化时触发\nInputSystem.onActionChange += OnActionChange;\n```\n\n# ScriptableObject\n\nscriptableObject是一种数据容器，在项目菜单中通过`AssetMenu`可以创建SO文件，以`.asset`的形式保存在项目中。\n\n## 定义SO脚本\n\n```c#\n[CreateAssetMenu(menuName = \"目录/选项名\")]\npublic class TestSO : ScriptableObject{\n    public string myString;\n}\n```\n\n## 作为gameObject基类\n\n\n\n## 作为事件传递\n\n```c#\n[CreateAssetMenu(menuName = \"Event/CharacterEventSO\")]\npublic class CharacterEventSO : ScriptableObject\n{\n    public UnityAction<Character> OnEventRaised;\n\n    public void RaiseEvent(Character character)\n    {\n        OnEventRaised?.Invoke(character);\n    }\n}\n```\n\n\n\n# Animator\n\n```c#\nprivate Animator playerAnim;\n\n//设置参数\nplayerAnim.SetBool(\"Anim_isWalking\", isWalking);\nplayerAnim.SetTrigger(\"hurt\");\nplayerAnim.SetFloat(\"velocityX\", Math.Abs(rb.velocity.x));\n```\n\n## 动画状态机脚本\n\n状态机可以生成c#脚本，在状态机的各个生命周期进行操作\n\n```c#\npublic class <状态机名> : StateMachineBehaviour\n{\n    // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state\n    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)\n    {\n        animator.GetComponent<PlayerController>().isAttacking = false;\n        animator.GetComponent<PlayerController>().attackMotion = true;\n    }\n\n    // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks\n    //override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)\n    //{\n    //    \n    //}\n\n    // OnStateExit is called when a transition ends and the state machine finishes evaluating this state\n    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)\n    {\n        animator.GetComponent<PlayerController>().attackMotion = false;\n    }\n\n    // OnStateMove is called right after Animator.OnAnimatorMove()\n    //override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)\n    //{\n    //    // Implement code that processes and affects root motion\n    //}\n\n    // OnStateIK is called right after Animator.OnAnimatorIK()\n    //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)\n    //{\n    //    // Implement code that sets up animation IK (inverse kinematics)\n    //}\n}\n```\n\n# 多人游戏\n\n## Netcode for GameObjects\n\n### 初始化\n\n* 创建`NetWorkManager`对象，并绑定`NetWorkManager`脚本，设置为`UnityTransport`。\n\n## NetworkManager\n\n### 启动\n\n```C#\n//启动主机(服务器+客户端)\nNetworkManager.Singleton.StartHost();\n//启动客户端\nNetworkManager.Singleton.StartClient();\n//启动服务器\nNetworkManager.Singleton.StartServer();\n\n//表示当前状态\nNetworkManager.Singleton.IsClient/IsServer/\n    \n//加载场景\nNetworkManager.Singleton.SceneManager.LoadScene()\n```\n\n### 网络连接事件\n\n* `OnClientConnectedCallback`：监听客户端连接成功\n* `OnClientDisconnectCallback`：监听客户端断开连接\n* `OnServerStarted`：监听服务器启动\n* `OnTransportFailure`：监听不可恢复的断开事件\n* `NetworkManager.Singleton.Shutdown()`：客户端断开网络方法\n* `NetworkManager.Singleton.DisconnectClient(client)`：服务器断开指定客户端方法\n\n## NetworkObject\n\n需要服务端同步的对象要绑定`NetworkObject`脚本，并继承`NetworkBehaviour`。\n\n### Player Prefab\n\n`Player Prefab`是特殊的网络对象，每台客户端只能拥有一个。\n\n### NetworkPrefabs List\n\n其他网络对象的列表，勾选`override`后可以对服务器和客户端设置不同的模型。\n\n※**加载和卸载，隐藏和显示**网络对象必须发生在服务器。玩家退出或掉线，对象仍然在服务器中（除非设置为玩家拥有的对象）。\n\n```c#\n//加载\n[ServerRpc]\npublic void ServerRpc(){\n\tTransform Obj = Instantiate(prefab);\n\tObj.GetComponent<NetworkObject>().Spawn()/Despawn();\n}\n\n//修改所有者\nGetComponent<NetworkObject>().ChangeOwnership(clientId);\nGetComponent<NetworkObject>().RemoveOwnership();\n//指定客户端的玩家对象\nNetworkManager.Singleton.ConnectedClients[OwnerClientId].PlayerObject;\n//指定客户端的拥有对象\nNetworkManager.Singleton.ConnectedClients[OwnerClientId].OwnedObjects;\n\n//隐藏与显示\n[ServerRpc]\npublic void HideServerRpc(){\n    foreach(var item in NetworkManager.Singleton.ConnectedClients){\n        if(item.Key != OwnerClientId)\n        {\n        \tthis.NetworkObject.NetworkHide(item.Key); //只在拥有者的客户端显示\n            this.NetworkObject.NetworkShow(item.Key);\n        }\n    }\n}\n\n//对每个客户端设置判断可见性的规则\nGetComponent<NetworkObject>().CheckObjectVisibility = ((clientId) => {\n    if(...){\n        return true;\n    }else{\n        return false;\n    }\n})\n```\n\n### 生命周期方法\n\n※动态生成的网络对象和场景内置的网络对象调用`OnNetworkSpawn()`的顺序**不一样**。\n\n* Dynamically Spawned：`Awake -> OnNetworkSpawned -> Start`\n* In-Scene placed：`Awake -> Start -> OnNetworkSpawned`  \n\n```c#\n//网络对象和脚本被创建时调用\npublic override void OnNetworkSpawn()\n//网络对象和脚本被删除时调用\npublic override void OnNetworkDespawn()\n\npublic override void OnGainOwnership()\n```\n\n\n\n### Network Transform(脚本)\n\n**参数：**\n\n* Syncing：需要同步的坐标，旋转和缩放轴\n* Thresholds：表示执行同步的阈值\n* Configurations：\n  * In Local Space：使用Local Position\n  * Interpolate：同步时使用插值移动，而非直接同步最终位置\n\n默认为`server authoritative mode`，不接受客户端改变状态。\n\n改为`Owner authoritative mode`（ClientNetworkTransform）:\n\n[官方文档](https://docs-multiplayer.unity3d.com/netcode/current/components/networktransform/#owner-authoritative-mode)\n\n```c#\nusing Unity.Netcode.Components;\nusing UnityEngine;\n\nnamespace Unity.Multiplayer.Samples.Utilities.ClientAuthority\n{\n    /// <summary>\n    /// Used for syncing a transform with client side changes. This includes host. Pure server as owner isn't supported by this. Please use NetworkTransform\n    /// for transforms that'll always be owned by the server.\n    /// </summary>\n    [DisallowMultipleComponent]\n    public class ClientNetworkTransform : NetworkTransform\n    {\n        /// <summary>\n        /// Used to determine who can write to this transform. Owner client only.\n        /// This imposes state to the server. This is putting trust on your clients. Make sure no security-sensitive features use this transform.\n        /// </summary>\n        protected override bool OnIsServerAuthoritative()\n        {\n            return false;\n        }\n    }\n}\n```\n\n缓冲帧：\n\n客户端每帧从缓冲区取一帧的结果（或操作）同步。\n\n![b326333c6a88b827e2db61d78100c72](../images/b326333c6a88b827e2db61d78100c72-1729852340628-4.png)\n\n### Network Rigidbody\n\n### Network Animator\n\n设为NetworkAnimator后，在`ServerRpc`中执行的参数会自动同步到客户端中。\n\n## RPC\n\nRemote Procedure Call Protocol，可以通过调用方法在服务器和客户端中实现交互，而无需关心底层数据传递。在游戏开发中也常采用前后端分离的开发方式，但使用Netcode时，前后端代码是一套的，因此要使用`[ServerRpc]`/`[ClientRpc]`标记来区分服务端和客户端的方法。\n\n* 在`Network Behaviour`中可用\n* 用`[ServerRpc]`或`[ClientRpc]`标记\n* 方法名以`...ClientRpc()`或`...ServerRpc()`结尾\n\n* static function 不可设为RPC\n\n### ServerRpc\n\n客户端只调用`ServerRpc()`方法但不执行。服务端收到请求（**有延时**）后对服务端版本的对象进行操作。\n\n![bed19136f6485d0c249daf647f5370a](../images/bed19136f6485d0c249daf647f5370a.png)\n\n### ClientRpc\n\n由服务端调用后，在客户端（一个或多个）中执行。**不同客户端之间会有延迟**。\n\n![88ad48bfa834395144cd6fd1dc0946e](../images/88ad48bfa834395144cd6fd1dc0946e.png)\n\n**※无论是ServerRpc还是ClientRpc都不会在调用的瞬间完成，因此在代码上下文中需要考虑延迟。**\n\n```c#\n    private void Update()\n    {\n        //服务端执行以下代码，并让所有客户端执行ClientRPC部分的代码\n        if (!IsServer)\n        {\n            return;\n        }\n        if (waitingRecipeList.Count == waitingRecipeMax)\n        {\n            return;\n        }\n        spawnRecipeTimer -= Time.deltaTime;\n        if (spawnRecipeTimer <= 0f)\n        {\n            spawnRecipeTimer = spawnRecipeTimerMax;\n            int randamIndex = UnityEngine.Random.Range(0, deliveryRecipeList.Count);\n            SpawnNewWaitingRecipeClientRPC(randamIndex); \n        }\n    }\n\n    //客户端执行以下代码\n    [ClientRpc]\n    private void SpawnNewWaitingRecipeClientRPC(int index)\n    {\n        SO_DeliveryRecipe recipe = deliveryRecipeList[index];\n        waitingRecipeList.Add(recipe);\n        OnRecipeSpawned?.Invoke(this, EventArgs.Empty);\n    }\n```\n\n## NetworkVariables\n\n当RPC调用时，如果客户端处于断开状态就会**丢失信息**。因此，持续化的数据需要使用NetworkVariables来进行同步。\n\n```c#\n//基础类型\npublic NetworkVariable<Vector3> Position = new NetworkVariable<Vector3>(初始值，读取权限,写入权限);\n\n//数组\nNetworkList<T>\n\n//字典\nNetworkDictionary<T,U>\n```\n\n例：\n\n```c#\npublic class Player : NetworkBehaviour{\n    public TextMesh TextMesh;//显示血量的文本\n    public NetworkVariable<int> HP = new NetworkVariable<int>(0,NetworkVariableReadPermission.Everyone,NetworkVariableWritePermission.Server);\n    \n    [ServerRpc]\n    public void CallServerRpc(Vector3 position){\n        tranform.position += position;\n    }\n    \n    [ServerRpc]\n    public void CallHPServerRpc(int hp){\n        //在服务端设置网络变量值\n        HP.Value = hp;\n    }\n    \n    private void Update(){\n        //通过IsOwner可以判断是否是本地客户端控制的Player\n        if(IsOwner){\n            CallHPServerRpc(HP.value-1);\n        }\n        //所有Player都要刷新血量，因此不判断IsOwner\n        TextMesh.text = HP.Value.ToString();\n    }\n}\n```\n\n## 前后端时间\n\n# 2D游戏\n\n## Sprite Renderer\n\n## 碰撞检测 \n\n### Physics2D\n\n```c#\n//包围圈，检测圈内有无碰撞。LayerMask可以指定检测的层级。\nPhysics2D.OverlapCircle((Vector2)transform.position + bottomOffset, checkRadius, groundLayerMask);\n```\n\n### Collider2D\n\nLayer Overrides：\n\n* Priority：规则矛盾时，采取规则的优先级，优先级相同，不会发生碰撞\n\n* Include Layers：发生碰撞的层级\n* Exclude Layers：不会产生碰撞的层级\n* Contact Capture Layers：\n* Callback Layers：触发回调函数的层级（OnCollisionXXX，OnTriggerXXX）\n\n#### 触发器\n\n触发条件：\n\n* 双方都有`Collider`组件\n* 其中一方必须是`Rigidbody`\n* 至少其中一方勾选`isTrigger`\n\n```c#\n//有物体进入触发器时调用\nprivate void OnTriggerEnter2D(Collider2D other){}\n\n//有物体离开触发器时调用\nprivate void OnTriggerExit2D(Collider2D other){}\n\n//有物体触发时持续调用\nprivate void OnTriggerStay2D(Collider2D other){}\n```\n\n\n\n# 3D游戏\n\n## 碰撞检测\n\n### Raycast\n\n使用`Physics.CapsuleCast`可以判断前方是否有物体\n\n```c#\nPhysics.CapsuleCast(transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirection, moveDistance) \n```\n\n# 调试\n\n## Gizmos\n\n```c#\n//在Object被选中时绘制\nprivate void OnDrawGizmosSelected()\n{\n    //绘制圆框\n    Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkRadius);\n}\n```\n\n# Shader\n\n## MVP矩阵\n\nModel矩阵：从模型空间 → 世界空间\n\nView矩阵：世界空间→视角空间（相对于摄像机）\n\nProjection矩阵：视角空间→裁剪空间\n\n## ShaderLab\n\n| Pass属性          | 作用                           |\n| ----------------- | ------------------------------ |\n| NAME \"xxx\"        | 通过名字可以在其他shader中调用 |\n| Tags {\"xx\"=\"xx\"}  |                                |\n| CGPROGRAM / ENDCG | 用于标注shader语言的范围       |\n|                   |                                |\n\n### 渲染队列\n\n设置：`Tags { \"Queue\" = \"XXX\" }`\n\n| 名称        | 值   |                                          |\n| ----------- | ---- | ---------------------------------------- |\n| Background  | 1000 |                                          |\n| Geometry    | 2000 | 不透明物体，默认                         |\n| AlphaTest   | 2450 | 需要进行AlphaTest的物体                  |\n| Transparent | 3000 | 半透明物体，从后往前渲染，一般不写入深度 |\n| Overlay     | 4000 | 覆盖效果，屏幕贴片，镜头光晕等           |\n\n#### multi-pass shader\n\n当一个shader中含有多个pass，unity会将该物体插在多个pass中**值较小的渲染队列中**，且按代码顺序执行pass。\n\n## 渲染路径 render path\n\n### 前向渲染\n\n### 延迟渲染\n\n\n\n## 屏幕空间坐标\n\n计算片元在屏幕上的像素位置`ComputeScreenPos()`\n\n```c#\n//第一步：在vert中调用ComputeScreenPos()，保存到插值寄存器中\nv2f vert(meshData v){\n    v2f o;\n    \n    //裁剪空间的齐次坐标，xy范围为[-w,w]\n    o.pos = UnityObjectToClipPos(v.vertex); \n    \n    //输出为( (clip_x + clip_w)/2, (clip_y + clip_w)/2, clip_z, clip_w)\n    //xy范围为[0,w]\n    o.scrPos = ComputeScreenPos(o.pos);\n    return o;\n}\n\n//第二步：用scrPos.xy 除以scrPos.w 得到[0,1]范围的屏幕空间坐标\n//zw的范围为 透视投影([-Near, Far],[Near, Far])\n//          正交投影([-1, 1],[1])\nfixed4 frag(v2f i){\n    float2 wcoord = (i.scrPos.xy/i.scrPos.w);\n    return fixed4(wcoord,0,1.0);\n}\n```\n\n## 曲面细分着色器\n\n### LOD\n\nlevel of detail，近处的物体要求更高的精细度，但远处的物体不要求高精度。\n\n### 着色器执行顺序\n\n通过曲面细分着色器，可以动态改变模型精度，从而减少CPU传入GPU的顶点信息。\n\n![image-20241214121543927](../images/image-20241214121543927.png)\n\n### TESS流程\n\n* 输入：Patch，多个顶点及其属性的集合\n* Hull Shader：设定TESS factor，决定细分方式\n* Tessellation Primitive Generator：进行细分操作\n* Domain Shader：将细分后的点从重心空间转换到屏幕空间\n\n### Hull Shader\n\nOpenGL中称为Tessellation Control Shader\n\n| Tessellation Factor     | 决定将一条边细分的方式      |\n| ----------------------- | --------------------------- |\n| equal_spacing           | 等分                        |\n| fractional_even_spacing | 向上取最近的偶数，最小值为2 |\n| fractional_odd_spacing  | 最小值为1                   |\n\n### Tessellation Primitive Generator\n\n输入：Inner tessellation level，Outer tessellation level\n\n输出：Triangles，Quads，Isolines\n\n### Domain Shader\n\n\n\n## 几何着色器\n\n一个图元（三角形）的所有顶点经过顶点着色器后，一并传入几何着色器。**并行能力较顶点着色器更弱**。\n\n![image-20241214131841069](../images/image-20241214131841069.png)\n\n* 输入：经过顶点着色器后的一个图元的所有顶点信息\n* 输出：独立于输入的顶点，线段，或三角形信息（三者之一）\n\n### 输入\n\n| 输入类型            | 顶点数                    |\n| ------------------- | ------------------------- |\n| points              | 1                         |\n| lines               | 2                         |\n| triangles           | 3                         |\n| lines_adjacency     | 4（线段和端点的相邻点）   |\n| triangles_adjacency | 6（三角形和端点的相邻点） |\n\n### 输出\n\n| 输出类型   |                |\n| ---------- | -------------- |\n| line_strip | 线段（不封口） |\n| line_loop  | 线段（封口）   |\n|            |                |\n\n\n\n## 测试\n\n### 模板测试Stencil\n\n[Unity官方文档](https://docs.unity3d.com/Manual/SL-Stencil.html)\n\n#### stencil buffer\n\n对屏幕上的每个像素设置不同的stencil值（0~255），在每个Pass中可以决定只渲染特定stencil值的像素。\n\n在目前的显卡架构中，stencil buffer和depth buffer连在一起，（如8位stencil，24位depth），因此模板测试中可以获取z-test的结果。\n\n```c#\n//shaderlab中配置stencil test\nStencil {\n\t//当前像素stencil值与ref值进行比较\n\tRef 0           //0-255\n\t//测试条件：测试是否相等\n\tComp Equal     //default:always\n\t//如果测试通过对此stencil值进行的写入操作：保持当前stencil值\n\tPass keep       //default:keep\n\t//如果测试失败对此stencil值进行的写入操作：保持当前stencil值\n \tFail keep       //default:keep\n \t//如果深度测试失败对此stencil值进行的写入操作：循环递增\n\tZFail IncrWrap  //default:keep\n}\n```\n\n#### 示例：物体描边\n\n```c#\nShader \"Unlit/StentilOutline\"\n{\n\tProperties\n\t{\n\t\t_MainTex (\"Texture\", 2D) = \"white\" {}\n\t}\n\tSubShader\n\t{\n\t\tTags { \"RenderType\"=\"Opaque\" }\n\t\tLOD 100\n        \n        //将Stencil写在subshader中，对其中的所有pass执行\n        Stencil {\n             Ref 0          //0-255\n             Comp Equal     //default:always\n             Pass IncrSat   //default:keep\n             Fail keep      //default:keep\n             ZFail keep     //default:keep\n        }\n\n        //执行第一个pass时，让其覆盖的所有像素stencil值变为1\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t// make fog work\n\t\t\t#pragma multi_compile_fog\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tUNITY_FOG_COORDS(1)\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\t\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\t\t\t\tUNITY_TRANSFER_FOG(o,o.vertex);\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\t\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\t// sample the texture\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\t\t\t\t// apply fog\n\t\t\t\tUNITY_APPLY_FOG(i.fogCoord, col);\n\t\t\t    //return fixed4(1,1,0,1);\n                return col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\n        //执行第二个pass时，在vert中让顶点向外偏移\n        //原本有物体的像素，stencil值都变成了1，因此pass2只会在外围轮廓处渲染\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            // make fog work\n            #pragma multi_compile_fog\n            \n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float4 normal: NORMAL;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                UNITY_FOG_COORDS(1)\n                float4 vertex : SV_POSITION;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n            \n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex=v.vertex+normalize(v.normal)*0.01f;\n                o.vertex = UnityObjectToClipPos(o.vertex);\n                o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n                UNITY_TRANSFER_FOG(o,o.vertex);\n                return o;\n            }\n            \n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n                // apply fog\n                UNITY_APPLY_FOG(i.fogCoord, col);\n                return fixed4(1,1,1,1);\n            }\n            ENDCG\n        }\n\t}\n}\n```\n\n### 深度测试\n\n#### z-buffer\n\n24位精度存储当前的深度缓冲\n\n不写入深度缓冲的物体**不会遮挡其他物体**\n\n`Always`通过深度缓冲的物体**不会被其他物体遮挡**\n\n通过`Z-test`才会写入深度\n\n* 半透明物体：只测试，不写入，开启混合\n\n#### 深度值\n\n深度缓冲中存储的是**非线性值**0~1\n\n（越接近屏幕值越小）\n\n![image-20241212161633485](../images/image-20241212161633485.png)\n\n#### early-Z\n\n在片元着色器前进行深度测试和写入，提前舍弃片元  \n\nearly-Z失效的情况：\n\n* 开启AlphaTest 或 使用 clip/discard手动丢弃片元的操作\n* 开启Alpha Blend（不会深度写入）\n* 关闭深度测试\n\n#### Z-prepass\n\n使用两个Pass，在第一个pass中只写入深度，第二个pass中用`equal`进行深度测试，并渲染\n\n※多个pass的shader无法进行动态批处理\n\n## 混合模式\n\n$$\nResult = SrcFactor *Src.rgb <Operation> DstFactor *Dst.rgb\n$$\n\nShaderLab中`Blend SrcFactor DstFactor`\n\n常用混合模式：\n\n```c#\n//透明度混合\nBlend SrcAlpha OneMinusSrcAlpha \n//叠加\nBlend One One\n//柔和相加\nBlend One OneMinusDstColor\n//相乘(正片叠底)\nBlend DstColor Zero\n//2倍相乘\nBlend DstColor SrcColor\n//预乘透明度\nBlend One OneMinusSrcAlpha\n```\n\n### 使用Unity自带的枚举\n\n```c#\nProperties{\n    [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (\"SrcBlend\", Float) = 1\n    [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (\"DstBlend\", Float) = 1        \n    [Enum(UnityEngine.Rendering.BlendOp)] _BlendOp (\"BlendOp\", Float) = 0    \n}\nSubShader{\n    Blend [_SrcBlend] [_DstBlend]\n    BlendOp [_BlendOp]\n}\n```\n\n## 剔除\n\n### 法线剔除\n\n根据法线朝向判断背向，正向摄像机的面，用于控制是否**双面渲染**\n\n`Cull Off / Front / Back`\n\n### 面裁切\n\n在片元着色器中判断，将`value<0`的像素丢弃，常用于做溶解等效果。使用Clip的pass最好在`AlphaTest`队列\n\n`Clip(value)`\n\n## 纹理\n\n### Unity纹理坐标\n\n竖直方向**从下到上**（0~1）\n\n### 法线贴图\n\nbump mapping\n\nnormal mapping\n\ndisplacement mapping\n\n->per pixel displacement mapping\n\nparallax mapping\n\nsteep parallax mapping\n\nparallax occlusion mapping\n\n![image-20241215154625129](../images/image-20241215154625129.png)\n\n### Cubemap\n\n用于**天空盒，环境映射**。\n\n#### SkyBox\n\n创建Skybox材质，Shader选择`Skybox/6 Sided`。\n\n#### 环境映射\n\n手动创建，或在脚本中调用`Camera.RenderToCubemap`。\n\n* **反射效果**\n\n​\t\n\n* **折射效果**\n\n### Render Texture\n\n将摄像机的画面渲染到Target Texture中，实现镜子效果\n\n* 需要创建额外相机\n* 效率更高，可以手动控制分辨率，摄像机的开启/隐藏，调整摄像机的渲染层级\n\n### GrabPass\n\n设置为透明队列（\"Queue\"=\"Transparent\"）\n\n* 不需要创建相机\n* 获取的图像分辨率和显示屏幕一致\n* 使用command buffers可以得到类似效果\n\n### Procedural Texture\n\n由脚本生成，可以使用各种参数调整外观\n\n* Substance Designer\n\n### FlowMap\n\n用RG通道表示二维向量场，模拟气体，液体的流动\n\n```c#\n//在片元着色器中：\n\n//采样flowmap，并映射到[-1,1]\nfixed4 flowDir = tex2D(_FlowMap, i.uv) * 2.0 - 1.0;\n\n//强度修正\nflowDir *= _FlowSpeed;\n\n//正负修正\n#ifdef _REVERSE_FLOW_ON\n\tflowDir *= -1;\n#endif\n\n//周期变化\nfloat phase0 = frac(_Time * 0.1 * _TimeSpeed);\nfloat phase1 = frac(_Time * 0.1 * _TimeSpeed + 0.5);\n\nfloat2 tiling_uv = i.uv * _MainTex_ST.xy + _MainTex_ST.zw;\n\nhalf3 tex0 = tex2D(_MainTex, tiling_uv + flowDir.xy * phase0);\nhalf3 tex1 = tex2D(_MainTex, tiling_uv + flowDir.xy * phase1);\n\nfloat flowLerp = abs((0.5 - phase0) / 0.5);\nhalf3 finalColor = lerp(tex0, tex1, flowLerp);\n\nreturn float4(finalColor, 1.0) * _Color;\n```\n\n## 阴影\n\n### 投射或接收阴影\n\n在`Mesh Renderer`组件中：\n\n* `Cast Shadows` ：开启后将该物体加入到光源的阴影映射纹理计算中（需要ShadownCaseter Pass）\n* `Receive Shadows`：调用Unity内置宏和变量时，如果判断没有开启接受阴影，就不会计算。\n\n### ShadowMap技术\n\nUnity使用专门的Pass更新光源的阴影映射纹理，其`LightMode`为`ShadowCaster`。调用该Pass时，Unity会把摄像机放置到光源的位置上。\n\n当开启了光源的阴影效果后，底层渲染引擎会在当前物体的Shader中寻找ShadowCaster Pass，若没有就去Fallback中找，如果还没有找到，**该物体就无法向其他物体投射阴影（但可以接受其他物体的阴影）**。\n\n#### ScreenSpace ShadowMap\n\n※需要显卡支持MRT\n\n## 动画\n\n相关内置变量\n\n| float4          | 描述                                             |\n| --------------- | ------------------------------------------------ |\n| _Time           | 场景开始加载所经过的时间：(t/20, t, 2t, 3t)      |\n| _SinTime        | 时间的正弦值（t/8, t/4, t/2, t）                 |\n| _CosTime        | 时间是余弦值，分量同上                           |\n| unity_DeltaTime | dt是时间增量，（dt, 1/dt, smoothDt, 1/smoothDt） |\n\n### 序列帧\n\n在每个时刻计算该时刻播放的关键帧的位置\n\n```c#\n//fragment shader\n//把time作为行列索引\nfixed4 frag(v2f i) : SV_Target{\n    float time = floor(_Time.y * _Speed);\n    float row = floor(time / _HorizontalAmount);\n    float column = time - row * _VerticalAmount;\n    half2 uv = i.uv + half2(column, -row);\n    uv.x /= _HorizontalAmount;\n    uv.y /= _VerticalAmount;\n    return fixed4(tex2D(_MainTex, uv), 1.0);\n}\n```\n\n### 滚动\n\n```c#\nv2f vert(meshData v){\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    //让贴图采样的uv坐标随时间偏移\n    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0) * _Time.y);\n}\n```\n\n### 顶点动画\n\n※包含模型空间的顶点动画的shader要标注`DisableBatching`，\n\n批处理会合并相关模型，导致各自的模型空间消失\n\n※需自行实现ShadowCasterPass，否则会按照顶点偏移前的模型建立阴影\n\n```c#\nSubShader{\n    Tags {\t\n        \t\"Queue\" = \"Transparent\"\n       \t \t\"IgnoreProjector\" = \"True\"\n        \t\"RenderType\" = \"Transparent\"\n        \t\"DisableBatching\" = \"True\" \t //禁止批处理\n         }\n    Pass {\n        \n        v2f vert(meshData v) {\n            v2f o;\n            //在转换到裁剪空间前进行顶点偏移\n            offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength) * _Magnitude;\n\t\t\to.pos = UnityObjectToClipPos(v.vertex + offset);\n            //.....\n        }\n\n    }\n}\n```\n\n### Billboarding\n\n广告牌技术，根据视角方向来旋转一个被纹理着色的模型，使模型看起来**总是面对摄像机**。多用于渲染烟雾，云朵，闪光效果等。\n\n旋转矩阵：\n\n* 基向量\n  * 表面法线（N）\n  * 向上的方向（UP）\n  * 向右的方向（RIGHT）\n* 锚点：旋转过程中固定不变\n\n计算过程：表面法线和向上的方向，其中之一是固定的。\n\n例如当模拟草丛时，向上的方向为(0,1,0)。\n\n而当模拟粒子效果时，希望粒子正对视角方向，即表面法线=视角方向。\n\n```c#\n//顶点着色器中\n//选择模型空间的原点作为广告牌的锚点\n//获取模型空间下的视角位置\nfloat3 center = float3(0, 0, 0);\nfloat3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));\n\n//计算旋转后的表面法线方向\nfloat3 normalDir = viewer - center;\n//通过_VerticalBillboarding变量控制以UP方向为基准还是以法线方向为基准\n//1：法线方向固定，0：UP方向固定\n\nnormalDir.y =normalDir.y * _VerticalBillboarding;\nnormalDir = normalize(normalDir);\n//为了防止法线方向和UP方向平行，因此在法线方向为向上或向下时，改变UP方向\nfloat3 upDir = abs(normalDir.y) > 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);\n\n//根据法线方向和临时的UP计算出RIGHT，再叉积得到正交的UP方向\nfloat3 rightDir = normalize(cross(upDir, normalDir));\nupDir = normalize(cross(normalDir, rightDir));\n\t\t\t\t\n// 用基向量和锚点旋转模型\nfloat3 centerOffs = v.vertex.xyz - center;\nfloat3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;\n              \no.pos = UnityObjectToClipPos(float4(localPos, 1));\no.uv = TRANSFORM_TEX(v.texcoord,_MainTex);\n\nreturn o;\n```\n\n## 噪声\n\n### 消融效果\n\n噪声纹理+透明度测试\n\nShader：\n\n```c#\n//所需变量\nfixed _BurnAmount;  \t//消融程度：1：完全消融\nfixed _LineWidth;\t\t//控制烧焦边缘的宽度\nfixed4 _BurnFirstColor;\t//烧焦边缘颜色\nfixed4 _BurnSecondColor;//烧焦边缘颜色\n\nsampler2D _MainTex;\t\t\nsampler2D _BumpMap;\nsampler2D _BurnMap;\t\nfloat4 _MainTex_ST;\nfloat4 _BumpMap_ST;\nfloat4 _BurnMap_ST;\n\n//关闭剔除，渲染背面\nCull Off\n    \n//片元着色器\nfixed4 frag(v2f i) : SV_Target{\n    //对噪声纹理采样，剔除burn<BurnAmount的部分\n    fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n    clip(burn.r - _BurnAmount);\n    \n    float3 tangentLightDir = normalize(i.lightDir);\n    fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));\n    \n    fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;\n    \n    fixed3 ambient = UNITY_LILGHTMODEL_AMBIENT.xyz * albedo;\n    \n    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));\n    \n    //混合系数t，t值为1，表明该像素即将消融\n    fixed t = 1 - smoothstep(0, _LineWidth, burn.r - _BurnAmount);\n    //越接近FirstColor，越后消融\n    fixeded3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);\n    //使颜色变暗，更接近烧焦的颜色\n    burnColor = pow(burnColor, 5);\n    \n    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n    fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t* step(0.0001, _BurnAmount));\n    \n    return fixed4(finalColor, 1);\n}\n\n//自定义ShadowCaster\nPass{\n    Tags { \"LightMode\" = \"ShadowCaster\" }\n    \n    CGPROGRAM\n        \n    #pragma multi_compile_shadowcaster //指明所需编译指令\n        \n    fixed _BurnAmount;\n\tsampler2D _BurnMap;\n\tfloat4 _BurnMap_ST; \n    \n    struct v2f {\n\t\tV2F_SHADOW_CASTER;\n\t\tfloat2 uvBurnMap : TEXCOORD1;\n\t};\n    \n\tv2f vert(appdata_base v) {\n\t\tv2f o;\n\t\t\t\t\n\t\tTRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n\t\t\t\t\n\t\to.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\n\t\t\t\t\n\t\treturn o;\n\t}    \n    \n\tfixed4 frag(v2f i) : SV_Target {\n\t\tfixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n\t\t\t\t\n\t\tclip(burn.r - _BurnAmount);\n\t\t\t\t\n\t\tSHADOW_CASTER_FRAGMENT(i)\n\t}\n\tENDCG    \n}\n```\n\n### 水波效果\n\n用噪声纹理修改水面的法线方向\n\n把噪声纹理设为`Normal map`，并选择`Create from grayscale`\n\n```c#\n```\n\n\n\n## Post-processing Effect\n\n屏幕后处理效果，通常指的是渲染完整个场景后，再对图像进行一系列操作，实现各种屏幕特效。使用这种技术可以为游戏画面添加景深（Depth of Field），运动模糊（Mothion Blur）等艺术效果。\n\n屏幕后处理实际上是在场景中绘制了**屏幕大小的四边形，共四个顶点**。\n\n### 深度纹理\n\n深度和纹理在一张渲染纹理中存储了高精度的深度值，范围为[0,1]，通常是非线性分布。\n\n透视投影中，投影矩阵（非线性）对顶点缩放，经过齐次除法后得到NDC（归一化设备坐标normalized device coordinates）：\n\n![image-20241120131052351](../images/image-20241120131052351.png)\n\nNDC中z分量范围在[-1,1]，因此要映射到[0,1]\n\n在Unity中，使用延迟渲染路径可以直接从G-buffer获得深度纹理。当无法直接获得深度缓存时，Unity会使用**着色器替换**，选择`RenderType = Opaque`的物体，判断它们的渲染队列是否`<=2500`。\n\n#### 获取深度纹理\n\n```c#\n//脚本中设置摄像机模式\n//获取深度纹理，在Shader中通过声明_CameraDepthTexture变量访问\ncamera.depthTextureMode = DepthTextureMode.Depth;\n//获取深度+法线纹理，在Shader中通过声明_CameraDepthNormalsTexture变量访问\ncamera.depthTextureMode = DepthTextureMode.DepthNormals;\n```\n\n### 屏幕后处理脚本系统\n\n```c#\n//场景渲染完成的生命周期函数，默认在所有不透明和透明的pass执行完毕后调用\n//添加[ImageEffectOpaque]属性可以让该函数在执行透明物体pass前调用\n//传入当前渲染图像src，最终在屏幕输出dest\nMonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n\n//在OnRenderImage中，通常利用Graphics.Blit函数进行处理\n//src：传入的纹理\n//dest：目标渲染纹理，不填则直接将结果显示在屏幕上\n//mat：进行屏幕后处理操作的shader材质\n//pass：-1为调用所有pass，否则调用指定pass\nBlit(Texture src, RenderTexture dest);\nBlit(Texture src, RenderTexture dest, Material mat, int pass = -1);\nBlit(Texture src, Material mat, int pass = -1);\n```\n\n**后处理基类：**\n\n```c#\nusing UnityEngine;\n\n[ExecuteInEditMode]\n[RequireComponent(typeof(Camera))] //后处理效果必须挂载在摄像机上\npublic class PostEffectsBase : MonoBehaviour\n{   \n    //检测shader支持，并创建材质\n\tprotected Material CheckShaderAndCreateMaterial(Shader shader, Material material)\n\t{\n\t\tif (shader == null) { return null; }\n        \n\t\tif (shader.isSupported && material && material.shader == shader)\n\t\t{ return material; }\n        \n\t\tif (!shader.isSupported)\n\t\t{ return null; }\n\t\telse\n\t\t{\n            material = new Material(shader)\n            {\n                //防止材质被保存，用于动态生成的材质\n                hideFlags = HideFlags.DontSave\n            };\n\t\t\tif (material) return material;\n\t\t\telse return null;\n\t\t}\n\t}\n}\n```\n\n调整亮度，饱和度，对比度的后处理脚本：\n\n```c#\npublic class BrightnessSaturationAndContrast : PostEffectsBase {\n\n\tpublic Shader briSatConShader;\n\tprivate Material briSatConMaterial;\n\tpublic Material material {  \n        //每当获取的时候都会检查材质是否可用\n\t\tget {\n\t\t\tbriSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);\n\t\t\treturn briSatConMaterial;\n\t\t}  \n\t}\n\n\t[Range(0.0f, 3.0f)]\n\tpublic float brightness = 1.0f;\n\n\t[Range(0.0f, 3.0f)]\n\tpublic float saturation = 1.0f;\n\n\t[Range(0.0f, 3.0f)]\n\tpublic float contrast = 1.0f;\n\n\tvoid OnRenderImage(RenderTexture src, RenderTexture dest) {\n\t\tif (material != null) {\n            //设置材质的输入变量\n\t\t\tmaterial.SetFloat(\"_Brightness\", brightness);\n\t\t\tmaterial.SetFloat(\"_Saturation\", saturation);\n\t\t\tmaterial.SetFloat(\"_Contrast\", contrast);\n\t\t\t//将material传递给shader中的_MainTex\n\t\t\tGraphics.Blit(src, dest, material);\n\t\t} else {\n\t\t\tGraphics.Blit(src, dest);\n\t\t}\n\t}\n}\n```\n\nshader：\n\n```c#\nShader \"Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast\" {\n\tProperties {\n\t\t//可以省略，不需要显示在面板中\n\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\n\t\t_Brightness (\"Brightness\", Float) = 1\n\t\t_Saturation(\"Saturation\", Float) = 1\n\t\t_Contrast(\"Contrast\", Float) = 1\n\t}\n\tSubShader {\n\t\tPass {  \n\t\t\t//屏幕后处理实际上是在场景中绘制了屏幕大小的四边形\n\t\t\t//为了防止它对其他物体产生影响，关闭深度写入\n\t\t\tZTest Always Cull Off ZWrite Off\n\t\t\t\n\t\t\tCGPROGRAM  \n\t\t\t#pragma vertex vert  \n\t\t\t#pragma fragment frag  \n\t\t\t  \n\t\t\t#include \"UnityCG.cginc\"  \n\t\t\t  \n\t\t\tsampler2D _MainTex;  \n\t\t\thalf _Brightness;\n\t\t\thalf _Saturation;\n\t\t\thalf _Contrast;\n\t\t\t  \n\t\t\tstruct v2f {\n\t\t\t\tfloat4 pos : SV_POSITION;\n\t\t\t\thalf2 uv: TEXCOORD0;\n\t\t\t};\n\t\t\t  \n\t\t\t//appdata_img 内置结构体，用于屏幕后处理\n\t\t\tv2f vert(appdata_img v) {\n\t\t\t\tv2f o;\n\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = v.texcoord;\t \n\t\t\t\treturn o;\n\t\t\t}\n\t\t\n\t\t\tfixed4 frag(v2f i) : SV_Target {\n\t\t\t\t//...\n\t\t\t}  \n\t\t\t  \n\t\t\tENDCG\n\t\t}  \n\t}\n\t\n\tFallback Off\n}\n```\n\n### 亮度，饱和度，对比度\n\n```c#\nfixed4 frag(v2f i) : SV_Target {\n\tfixed4 renderTex = tex2D(_MainTex, i.uv);  \n\t\t\t\t  \n\t// Apply brightness\n\tfixed3 finalColor = renderTex.rgb * _Brightness;\n\t\t\t\t\n\t// Apply saturation\n\tfixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;\n\tfixed3 luminanceColor = fixed3(luminance, luminance, luminance);\n\tfinalColor = lerp(luminanceColor, finalColor, _Saturation);\n\t\t\t\t\n\t// Apply contrast\n\tfixed3 avgColor = fixed3(0.5, 0.5, 0.5);\n\tfinalColor = lerp(avgColor, finalColor, _Contrast);\n\t\t\t\t\n\treturn fixed4(finalColor, renderTex.a);  \n}  \n```\n\n### 边缘检测\n\n通过**卷积（convolution）**操作实现\n\n![image-20241119173343678](../images/image-20241119173343678.png)\n\n边缘检测使用两个卷积核，分别检测水平方向和竖直方向的边缘信息，再计算整体的梯度。**梯度越大，越可能是边缘点。**\n$$\nG=\\sqrt{G_x^2+G_y^2} \\\\ G=|G_x|+|G_y|\n$$\nShader：\n\n```c#\n//所需变量\nsampler2D _MainTex;\t\t\t//传入的渲染纹理\nhalf4 _MainTex_TexelSize; \t//通过纹素计算相邻区域的纹理坐标\nfixed _EdgeOnly;\t\t\t//是否只显示边缘\nfixed4 _EdgeColor;\t\t\t//边缘颜色\nfixed4 _BackgroundColor;\t//只显示边缘时的背景颜色\n\n//顶点着色器\nv2f vert(appdata_img v) {\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    half2 uv = v.texcoord;\n    \n    //计算卷积所需9个相邻纹理坐标\n    //在顶点着色器中计算可以提高性能\n    o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1,-1);\n    o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0,-1);\n    o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1,-1);\n    o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1,0);\n    o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0,0); //目标点\n    o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1,0);\n    o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1,1);\n    o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0,1);\n    o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1,1);\n    return o;\n}\n\nhalf Sobel(v2f i){\n    const half Gx[9]={-1, -2, -1,\n                     0, 0, 0,\n                     1, 2, 1};\n\tconst half Gy[9]={-1, 0, -1,\n                     -2, 0, 2,\n                     -1, 0, 1};\n    half texColor;\n    half edgeX = 0;\n    half edgeY = 0;\n    for(int it = 0; it < 9; it++){\n        texColor = luminance(tex2D(_MainTex, i.uv[it]));\n        edgeX += texColor * Gx[it];\n        edgeY += texColor * Gy[it];\n    }\n    half edge = 1 - abs(edgeX) - abs(edgeY);\n    return edge;\n}\n\n//片元着色器\nfixed4 frag(v2f i ) : SV_Target {\n    half edge = Sobel(i);\n    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4])， edge);\n    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);\n    return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);\n} \n```\n\n#### 使用深度+法线纹理\n\n利用深度差和法线差判断模型边界，不适合贴的紧的物体，例如桌子上的纸张。\n\nShader：\n\n```c#\n//所需变量\nsampler2D _MainTex;\t\t\t//传入的渲染纹理\nhalf4 _MainTex_TexelSize; \t//通过纹素计算相邻区域的纹理坐标\nfixed _EdgeOnly;\t\t\t//是否只显示边缘\nfixed4 _EdgeColor;\t\t\t//边缘颜色\nfixed4 _BackgroundColor;\t//只显示边缘时的背景颜色\n//NEW:\nfloat _SampleDistance;\t\t//采样距离，值越大，描边越宽\nhalf4 _Sensitivity;\t\t\t//xy为sensitivityNormals,sensitivityDepth\n\t\t\t\t\t\t\t//zw为0,0\nsampler2D _CameraDepthNormalsTexture;\n\n//顶点着色器\nv2f vert(appdata_img v) {\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    half2 uv = v.texcoord;\n    \n    //使用2x2卷积核\n    o.uv[0] = uv;\n    o.uv[1] = uv+_MainTex_TexelSize.xy*half2(1,1)*_SampleDistance;\n    o.uv[2] = uv+_MainTex_TexelSize.xy*half2(-1,-1)*_SampleDistance;\n    o.uv[3] = uv+_MainTex_TexelSize.xy*half2(-1,1)*_SampleDistance;\n    o.uv[4] = uv+_MainTex_TexelSize.xy*half2(1,-1)*_SampleDistance; \n\n    return o;\n}\n\n//片元着色器\nfixed4 fragRobertsCrossDepthAndNormal(v2f i):SV_Tartget{\n    half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);\n    half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);\n    half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);\n    half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);\n    \n    half edge = 1.0;\n    edge *= CheckSame(sample1,sample2);\n    edge *= CheckSame(sample3,sample4);\n    \n    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0])， edge);\n    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);\n    return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);\n}\n\n//CheckSame：计算对角线上纹理值得差值，返回0/1，返回0时表明两点之间存在边界\nhalf CheckSame(half4 center, half4 sample){\n    //没有解码法线，因为只需比较差异度\n    half2 centerNormal = center.xy;\n    float centerDepth = DecodeFloatRG(center.zw);\n    half2 sampleNormal = sample.xy;\n    float sampleDepth = DecodeFloatRG(sample.zw);\n    \n    half2 diffNormal = abs(centerNormal-sampleNormal)*_Sensitivity.x;\n    int isSameNormal = (diffNormal.x + diffNormal.y) < 0.1;\n    \n    float diffDepth = abs(centerDepth - sampleDepth) * _Sensitivity.y;\n    int isSameDepth = diffDepth < 0.1 * centerDepth;\n    \n    //深度或法线有一个差异较大，就视为边界\n    return isSameNormal*isSameDepth ? 1.0 : 0.0;\n}\n```\n\n\n\n### 高斯模糊\n\n卷积核：σ是标准方差，一般取值为1，因为最重要归一化，因此e前面的系数可以忽略。\n$$\nG(x,y)=\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}\n$$\n优化①：通过把N·N高斯滤波分解成两个一维的高斯核，可以将采样次数从 N·N·W·H 降到 2·N·W·H。\n\n![image-20241119183357367](../images/image-20241119183357367.png)\n\n```c#\nvoid OnRenderImage(RenderTexture src, RenderTexture dest) {\n    if(material != null) {\n        //【优化】对图像降采样，减少处理的像素个数\n        int rtW = src.width/dowmSample;\n        int rtH = src.height/dowmSample;\n        \n        //使用降采样的缓冲区保存中间结果\n        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW,rtH,0);\n        buffer0.filterMode = FilterMode.Bilinear;\n        \n        //通过迭代加强效果\n        for (int i = 0; i < iterations; i++) {\n\t\t\tmaterial.SetFloat(\"_BlurSize\", 1.0f + i * blurSpread);\n\n\t\t\tRenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);\n\n        \t//【优化】使用两次一维卷积\n        \t//指定竖直方向pass\n\t\t\tGraphics.Blit(buffer0, buffer1, material, 0);\n\n\t\t\tRenderTexture.ReleaseTemporary(buffer0);\n\t\t\tbuffer0 = buffer1;\n\t\t\tbuffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);\n\n        \t//指定水平方向pass\n\t\t\tGraphics.Blit(buffer0, buffer1, material, 1);\n\n\t\t\tRenderTexture.ReleaseTemporary(buffer0);\n\t\t\tbuffer0 = buffer1;\n\t\t}\n        Graphics.Blit(buffer0, dest);\n        RenderTexture.RelieaseTemporary(buffer);\n    }else{\n        Graphics.Blit(src, dest);\n    }\n}\n```\n\nshader:\n\n```c#\n//所需变量\nsampler2D _MainTex;\nhalf4 _MainTex_TexelSize;\nfloat _BlurSize;\n\n//顶点着色器\nstruct v2f{\n    float4 pos : SV_POSITION;\n    half2 uv[5] : TEXCOORD0;\n}\n\n//竖直方向pass,水平方向类似\n//BlurSize控制采样距离，越大模糊程度越高，同时不改变采样数\nv2f vertBlurVertical(appdata_img v){\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    half2 uv = v.texcoord;\n    o.uv[0] = uv;\n    o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0)* _BlurSize;\n    o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0)* _BlurSize;\n    o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0)* _BlurSize;\n    o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0)* _BlurSize;\n}\n\n//pass共用的片元着色器\nfixed4 fragBlur(v2f i) : SV_Target {\n    float weight[3] = {0.4026, 0.2442, 0.0545};\n    fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];\n    \n    for(int it = 1; it <3; it++){\n        sum += tex2D(_MainTex, i.uv[it]).rgb * weight[1];\n        sum += tex2D(_MainTex, i.uv[2+it]).rgb * weight[2];\n    }\n    return fixed4(sum, 1.0);\n}\n```\n\n### Bloom\n\n* 根据一个阈值，提取原图高亮区域\n\n```c#\nmaterial.SetFloat(\"_LuminanceThreshold\", luminanceThreshold);\nGraphics.Blit(src, buffer0, material, 0);\n```\n\n* 对高亮区域迭代高斯模糊\n\n* 混合原图和高亮区域\n\n```c#\nmaterial.SetTexture(\"_Bloom\",buffer0);//将处理后的高光传入纹理\nGraphics.Blit(src, dest, material, 3);\n```\n\nShader：\n\n```c#\n//所需变量\nsampler2D _MainTex;\nhalf4 _MainTex_TexelSize;\nsampler2D _Bloom;\nfloat _LuminanceThreshold;\nfloat _BlurSize;\n\n//PASS0：提取较量区域\nfixed4 fragExtractBright(v2f i) : SV_Target{\n    fixed4 c = tex2D(_MainTex, i.uv);\n    //根据阈值获取图像的亮度分布信息\n    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0, 1);\n    return c*val;\n}\n\n//PASS1,2：高斯模糊的两个PASS\nUsePass \"../../GAUSSIAN_BLUR_VERTICAL\"\nUsePass \"../../GAUSSIAN_BLUR_HORIZONTAL\"\n    \n//PASS3：混合图像\nv2f vertBloom(appdata_img v){\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.uv.xy = v.texcoord;\n    o.uv.zw = v.texcoord;\n    \n    //平台差异化处理 5.6.1节\n    #if UNITY_UV_STARTS_AT_TOP\n    if(_MainTex_TexelSize.y < 0.0)\n        o.uv.w = 1.0 - o.uv.w;\n    #endif\n        \n    return o;\n}\n\nfixed4 fragBloom(v2f i) : SV_Target{\n    return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);\n}\n```\n\n### 运动模糊\n\n实现：\n\n累积缓存(accumulation buffer)：混合一段时间内的多张图像\n\n速度缓存(velocity buffer)：存储各个像素的运动速度，计算模糊方向和大小（通过深度纹理计算像素速度）\n\n```c#\nvoid OnRenderImage(RenderTexture src, RenderTexture dest){\n    if (material != null){\n        //创建累积纹理\n        if( accumulationTexture == null \n          || accumulationTexture.width != src.width\n          || accumulationTexture.height != src.height ){\n            DestroyImmediate(accumulationTexture);\n            accumulationTexture = new RenderTexture(src.width,src.height.0);\n            accumulationTexture.hideFlags = HideFlags.HideAndDontSave;\n            Graphics.Blit(src, accumulationTexture);\n        }\n        \n        material.SetFloat(\"_BlurAmount\", 1.0f - blurAmount);\n        Graphics.Blit(src, accumulationTexture, material);\n        Graphics.Blit(accumulationTexture, dest);\n    }else{\n        Graphics.Blit(src, dest);\n    }\n}\n```\n\n### 全局雾效\n\n根据深度纹理重建每个像素在世界空间下的位置：\n\n```c#\n//世界空间坐标 = 世界空间下摄像机坐标 + 线性深度值 × 插值后的射线\nworldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay; \n```\n\n#### 计算interpolatedRay\n\n![image-20241120175941773](../images/image-20241120175941773.png)\n\n首先计算`toTop`，`toRight`：\n\n`halfHeight`：Near × tan(FOV/2)\n\n`toTop`：camera.up × halfHeight\n\n`toRight`：camera.right × (halfHeight·aspect)\n\n接着计算四个角相对于摄像机原点的向量：\n\n`TL`：camera.forward·Near + toTop - toRight\n\n由于深度值是**z方向的距离**，要转换为实际距离\n\ndepth/Near = dist/|TL| （仅对于TL射线上的点而言）\n\n#### 计算雾效系数\n\n在简单的雾效实现中，需要一个雾效系数f用于混合图像和雾的颜色：\n\n```\nfloat3 afterFog = f * fogColor + (1-f) * origColor;\n```\n\n在Unity内置的雾效实现中，有三种计算方式：\n\n给定距离Z\n\n线性中的d_min，d_max 为最小距离和最大距离\n\n指数中的d为雾的浓度参数\n$$\n线性:f=\\frac{d_{max}-|z|}{d_{max}-d_{min}} \\\\\n指数:f=e^{-d*|z|} \\\\\n指数平方:f=e^{-(d-|z|)^2}\n$$\n\n```c#\nvoid OnRenderImage(RenderTexture src, RenderTexture dest){\n    if(material != null){\n        Matrix4x4 frustumCorners = Matrix4x4.identity;\n        \n        float fov = camera.fieldOfView;\n        float near = camera.nearClipPlane;\n        float far = camera.farClipPlane;\n        float aspect = camera.aspect;\n        \n        //Deg2Rad:角度转弧度\n        float halfHeight= near * Mathf.Tan(fov*0.5f*Mathf.Deg2Rad);\n        Vector3 toRight= camera.transform.right * halfHeight * aspect;\n        Vector3 toTop= camera.transform.up * halfHeight;\n        \n        Vector3 topLeft= camera.transform.forward*near+toTop-toRight;\n        float scale = topLeft.magnitude / near;\n        \n        topLeft.Normalize();\n        topLeft *= scale;\n        \n        //...对topRight,bottomLeft,bottomRight进行相同操作\n        \n        frustumCorners.SetRow(0, bottomLeft);\n        frustumCorners.SetRow(1, bottomRight);\n        frustumCorners.SetRow(2, topRight);\n        frustumCorners.SetRow(3, topLeft);\n        \n        material.SetMatrix(\"_FrustumCornersRay\", frustumCorners);\n        material.SetMatrix(\"_ViewProjectionInverseMatrix\", \n       \t(camera.projectionMatrix*camera.worldToCameraMatrix).inverse);\n        \n        //...\n    }\n}\n```\n\nShader：\n\n```c#\n//所需变量\nfloat4x4 _FrustumCornersRay;\nsampler2D _MainTex;\nhalf4 _MainTex_TexelSize;\nsampler2D _CameraDepthTexture; //Unity内置的深度纹理访问变量\nhalf _FogDensity;\nfixed4 _FogColor;\nfloat _FogStart;\nfloat _FogEnd;\n\n//顶点着色器\nv2f vert(appdata_img v){\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vetex);\n    o.uv = v.texcoord;\n    o.uv_depth = v.texcoord;\n    \n    //...\n    //...根据v.vertexcoord判断顶点是哪个角，确定index\n    o.interpolatedRay = _FrustumCornersRay[index];\n    \n    return o;\n}\n\n//片元着色器\nfixed frag(v2f i) : SV_Target{\n    //根据内置的函数采样深度纹理，并转换为线性深度值\n    float linearDepth = LinearEyeDepth(\n        SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));\n    \n    //计算世界空间坐标\n    float3 worldPos = _WorldSpaceCameraPos \n        + linearDepth * i.interpolatedRay.xyz;\n    \n    //用世界空间的高度计算线性雾效系数\n    float fogDensity = (_FogEnd - worldPos.y)/(_FogEnd - _FogStart);\n    fogDensity = saturate(fogDensity * _FogDensity);\n    \n    fixed4 finalColor = tex2D(_MainTex, i.uv);\n    finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);\n    \n    return finalColor;\n}\n```\n\n## 风格化渲染\n\n* 基于色调的着色技术（Tone-based shading）\n* 轮廓线渲染\n\n### 轮廓线渲染\n\n检测轮廓边：n_0和n_1为相邻三角面的法向，v是从视角到该边上任意顶点的方向。\n$$\nn_0·v>0 \\ne n_1·v>0\n$$\n\n### 过程式几何轮廓线渲染\n\n对物体背面进行顶点偏移后，单色渲染为轮廓\n\n对物体正面使用tone shading渲染光照\n\nShader：\n\n```c#\n//Pass1:对背面进行轮廓描边\nCull Front\t\t\t\t//剔除正面\n\nfloat _Outline;\t\t\t//描边粗细\nfixed4 _OutlineColor;\n\n//顶点着色器\nv2f vert(meshData v){\n    v2f o;\n    \n    //使用Model-View矩阵转换为视角空间\n\tfloat4 pos = mul(UNITY_MATRIX_MV, v.vertex); \n    \n    //使用Model-View的逆转置矩阵转换法线向量\n    //因为向量无关平移，只需要3x3矩阵\n\tfloat3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal); \n    \n    //使法线z方向统一，扩展后的背面更加扁平，降低遮挡正面的可能性\n\tnormal.z = -0.5;\n    \n    //沿法线方向偏移\n\tpos = pos + float4(normalize(normal), 0) * _Outline;\n    \n    //变换到裁剪空间\n\to.pos = mul(UNITY_MATRIX_P, pos);\n}\n\n//片元着色器直接输出轮廓颜色\nfloat4 frag(v2f i) : SV_Target { \n\treturn float4(_OutlineColor.rgb, 1);               \n}\n```\n\n### 风格化光照\n\nShader：\n\n```c#\nstruct v2f{\n    float4 pos: POSITION;\n    float2 uv: TEXCOORD0;\n    float3 worldNormal: TEXCOORD1;\n    float3 worldPos: TEXCOORD2;\n    SHADOW_COORDS(3)\n}\n\nv2f vert(meshData v){\n    v2f o;\n    o.pos = UnityObjectToClipPos(v.vertex);\n    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\n    o.worldNormal = UnityObjectToWorldNormal(v.normal);\n    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;\n    \n    TRANSFER_SHADOW(o);\n    return o;\n}\n\nfloat4 frag(v2f i) : SV_Target{\n\tfixed3 worldNormal = normalize(i.worldNormal);\n\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\n\tfixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));\n\tfixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);\n    \n    fixed4 c= tex2D(_MainTex, i.uv);\n    fixed3 albedo = c.rgb * _Color.rgb;\n    \n    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\n    \n    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n    \n    fixed diff = dot(worldNormal, worldLightDir);\n    diff = (diff*0.5+0.5) * atten;\n    \n    //使用HalfLambert对渐变纹理采样\n    fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;\n    \n    fixed spec = dot(worldNormal, worldHalfDir);\n    \n    //邻域像素之间的近似导数值\n    fixed w = fwidth(spec) * 2.0;\n    fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);\n    \n    return fixed4(ambient + diffuse + specular ,1);\n}\n```\n\n## Command Buffers\n\n存储渲染命令的缓冲区（如`set render target`，`draw mesh`等），通过在特定时机执行这些指令，扩展渲染管线。\n\n绿色点：可以插入指令的时机\n\n![image-20241216130242486](../images/image-20241216130242486.png)\n\n## 纹理压缩\n\n黄字为常见压缩格式\n\n![image-20241216105605829](../images/image-20241216105605829.png)\n\n| 非压缩格式     |                                  |\n| -------------- | -------------------------------- |\n| RGBA32（8888） |                                  |\n| RGBA16（4444） |                                  |\n| RGB24（888）   |                                  |\n| RGB16（565）   | 人眼对绿光比较敏感，分配较高精度 |\n\n### DXTC\n\n把4x4的像素块压缩为一个64或128位的数据块\n\nDXT1：\n\ncolor_0和color_1为4x4像素中的极端颜色值\n\n再通过插值得到共4个颜色\n\n每个像素存储2bit的索引值，对应4个颜色\n\n![image-20241216110102348](../images/image-20241216110102348.png)\n\n![image-20241216122540780](../images/image-20241216122540780.png)\n"},{"title":"tinyrenderer开源项目学习","url":"/2024/06/24/my-study-tinyrenderer/","content":"\n# tinyrenderer\n\nsource：https://github.com/ssloy/tinyrenderer\n\n## 线段绘制\n\n## .obj 格式\n\n| 顶点数据 |              |\n| -------- | ------------ |\n| v        | 几何体顶点   |\n| vt       | 贴图坐标点   |\n| vn       | 顶点法线     |\n| vp       | 参数空格顶点 |\n\n| 自由形态曲线/表面属性 |                          |\n| --------------------- | ------------------------ |\n| deg                   | 度                       |\n| bmat                  | 基础矩阵（basis matrix） |\n| step                  | 步尺寸                   |\n| cstype                | 曲线或表面类型           |\n\n| 元素  |        |\n| ----- | ------ |\n| p     | 点     |\n| l     | 线     |\n| f     | 面     |\n| curv  | 曲线   |\n| curv2 | 2D曲线 |\n| surf  | 表面   |\n\n```\nf 5/15/7 4/14/6 \n\nf：表示一个面，由三个v/vt/vn的索引形式组成。比如obj文件中f 5/15/7 4/14/6 6/16/8 ，表示由第5、第4、第6这三个顶点组成了一个三角平面,平面的纹理由第15、第14、第16这三个纹理坐标形成，这个平面的朝向是第7、第6、第8这三个顶点的法向量求平均值。\n```\n\n"},{"title":"svg动画制作心得","url":"/2024/05/18/my-first-svg-animation/","content":"\n\n\n## 制作过程\n\n首先用illustrator创建svg文件。\n\n将预计使用不同动画的元素分图层\n\n![image-20240518082245734](../images/image-20240518082245734.png)\n","tags":["编程","设计"],"categories":["个人作品","平面设计"]},{"title":"计算机图形学笔记","url":"/2024/04/28/my-CG-notes/","content":"\n学习图形学相关笔记\n\n<!--more-->\n\n## Linear Algebra\n\n### Dot Product 点积\n\n* 投影\n* 判断两向量方向接近程度\n\n### Cross Product 叉积\n\n* 法向\n\n## Transforms\n\n* Affine map(仿射变换)\n  * 线性变换\n    * scale，reflection，shear，rotate\n  * 平移translation\n\n### homogenous coordinates 齐次坐标\n\n![image-20240428131949285](../images/image-20240428131949285.png)\n\npoint+point=中点\n\n三维坐标：(x, y, z, 1)^T^\n\n三维向量：(x, y, z, 0)^T^\n\n三维仿射变换：\n$$\n\\begin{pmatrix}\nx'\\\\\ny'\\\\\nz'\\\\\n1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na&b&c&t_{x}\\\\\nd&e&f&t_{y}\\\\\ng&h&i&t_{z}\\\\\n0&0&0&1\\\\\n\\end{pmatrix}\n·\n\\begin{pmatrix}\nx\\\\\ny\\\\\nz\\\\\n1\n\\end{pmatrix}\n$$\n![image-20240503155110384](../images/image-20240503155110384.png)\n\n四元数 ：解决旋转插值计算\n\n ### Projection transformation 投影变换\n\n#### Orthographic 正交投影\n\n## 光栅化(Rasterization)\n\n采样问题：锯齿，摩尔纹，车轮效应\n\n本质：信号变化太快，采样速度太慢\n\n### 滤波\n\n模糊操作→采样\n\n![image-20240621100744327](../images/image-20240621100744327.png)\n\n走样：\n\n![image-20240621103544506](../images/image-20240621103544506.png)\n\n卷积操作：\n\n![image-20240621113523346](../images/image-20240621113523346.png)\n\nMSAA（multy sample anti aliasing）：\n\n在一个像素点上取多个采样点\n\n![image-20240621134940537](../images/image-20240621134940537.png)\n\nFXAA（fast approximate AA）：\n\n将有锯齿的图像的边界修改\n\nTAA（Temporal AA）：\n\n与上一帧比较，复用上一帧的结果（MSAA的样本分布到时间上）\n\n### Super resolution（超分辨率）\n\n从低分辨率拉伸到高分辨率\n\nDLSS（deep learning super sampling）\n\n## 三角函数\n\n### 和差公式\n\n$$\nsin(α±β)=sinαcosβ±cosαsinβ \\\\\n\\cos(\\alpha \\pm \\beta) = \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta \\\\\\tan(\\alpha \\pm \\beta) = \\frac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta}\n$$\n\n### 倍角公式\n\n$$\nsin2α=2sinαcosα \\\\\n\\cos 2\\alpha = \\cos^2 \\alpha - \\sin^2 \\alpha = 2\\cos^2 \\alpha - 1 = 1 - 2\\sin^2 \\alpha \\\\\n\\tan 2\\alpha = \\frac{2\\tan \\alpha}{1 - \\tan^2 \\alpha}\n$$\n\n### 积化和差\n\n$$\nsinαsinβ=21[cos(α−β)−cos(α+β)] \\\\\n\\cos \\alpha \\cos \\beta = \\frac{1}{2}[\\cos(\\alpha - \\beta) + \\cos(\\alpha + \\beta)]\\\\\n\\sin \\alpha \\cos \\beta = \\frac{1}{2}[\\sin(\\alpha + \\beta) + \\sin(\\alpha - \\beta)]\n$$\n\n利用和差公式相加、相减\n\n### 和差化积\n\n$$\n\\sin \\alpha + \\sin \\beta = 2 \\sin \\frac{\\alpha + \\beta}{2} \\cos \\frac{\\alpha - \\beta}{2} \\\\\n\\sin \\alpha - \\sin \\beta = 2 \\cos \\frac{\\alpha + \\beta}{2} \\sin \\frac{\\alpha - \\beta}{2}\\\\\n\\cos \\alpha + \\cos \\beta = 2 \\cos \\frac{\\alpha + \\beta}{2} \\cos \\frac{\\alpha - \\beta}{2}\\\\\n\\cos \\alpha - \\cos \\beta = -2 \\sin \\frac{\\alpha + \\beta}{2} \\sin \\frac{\\alpha - \\beta}{2}\n$$\n\n利用`α=u+v`，`β=u-v`，代入和差公式\n\n## 深度缓冲 Z-buffering\n\n画家算法：新画的覆盖旧画的东西\n\n* 给所有三角形排深度\n\n问题：\n\n![image-20240621140940522](../images/image-20240621140940522.png)\n\n### 深度缓冲\n\n在每个**像素点**记录最小的`z`值\n\n同时生成：\n\n\t* frame buffer：包含颜色信息的帧缓冲\n\t* depth buffer：存储每个像素点最小深度的缓冲（越小，离相机越近）\n\n![image-20240621141259865](../images/image-20240621141259865.png)\n\n与渲染的顺序无关\n\n## Shading 着色\n\n基本着色模型(Blinn-Phong Reflectance Model)\n\n![image-20240621150901942](../images/image-20240621150901942.png)\n\n* 高光\n* 漫反射\n* 环境光\n\n计算每个着色点的光照：\n\n![image-20240621151529357](../images/image-20240621151529357.png)\n\n着色具有局部性：不考虑别的物体遮挡形成的影子\n\n### 漫反射\n\n某一点的漫反射光照能量与cosθ正相关\n\n![image-20240621152152115](../images/image-20240621152152115.png)\n\n光强随光源距离的减小情况：\n\n![image-20240621152516916](../images/image-20240621152516916.png)\n\n![image-20240621152748305](../images/image-20240621152748305.png)\n\n※漫反射光照与观测方向没有关系\n\n### 高光\n\n※观察方向和镜面反射方向接近时，可观察到高光\n\n（换句话说，**法线**和**半程向量**接近）\n\n![image-20240621160834949](../images/image-20240621160834949.png)\n\n指数p可以调整阈值（通常在100~200，越大，高光越集中）\n\n![image-20240621161210166](../images/image-20240621161210166.png)\n\n### 环境光\n\n简化为常数（实际考虑全局光照）\n\n![image-20240621161415991](../images/image-20240621161415991.png)\n\n### 着色频率\n\n#### 平面着色\n\n![image-20240621162234380](../images/image-20240621162234380.png)\n\n#### 顶点着色\n\n![image-20240621162320559](../images/image-20240621162320559.png)\n\n### Phong着色\n\n![image-20240621162434145](../images/image-20240621162434145.png)\n\n#### 三角形内部点平滑过渡\n\n在给每个像素着色时，需根据三角形顶点的属性（颜色，法向量等），给内部的属性做线性插值。\n\n**重心坐标**：三角形所在平面的点都可用三个顶点乘一定系数表示，\n\n※α，β，γ非负时，点在三角形内部\n\n![image-20240622091051864](../images/image-20240622091051864.png)\n\nα，β，γ也可用面积比求出：\n\n![image-20240622091455227](../images/image-20240622091455227.png)\n\n※先做插值，再进行透视投影\n\n![image-20240622091921538](../images/image-20240622091921538.png)\n\n### 比较\n\n横向采用相同模型。\n\n当模型面数足够高时，三者效果相差不大\n\n![image-20240621162539852](../images/image-20240621162539852.png)\n\n### 顶点法线\n\n相邻面的法线求平均（加权）\n\n![image-20240621162748412](../images/image-20240621162748412.png)\n\n### 阴影\n\n#### shadow mapping\n\n不在阴影里的点满足：\n\n1. 被（点）光源照射\n2. 被相机观测\n\n记录点光源观测的图像深度，相机观测的深度与点光源观测的深度比较。\n\n## 图形渲染管线\n\n图形输入到显示的一系列过程\n\n![image-20240621175230389](../images/image-20240621175230389.png)\n\n## 纹理映射\n\n![image-20240621183616504](../images/image-20240621183616504.png)\n\n![image-20240621183828955](../images/image-20240621183828955.png)\n\n**texel**：纹理上的一个像素 \n\n### 贴图过小\n\n#### 双线性插值 Bilinear\n\n映射在纹理上的非整数点，采用周围四个点的线性插值，以平滑放大纹理贴图\n\n![image-20240622092937231](../images/image-20240622092937231.png)\n\n#### Bicubic\n\n取16个点，三次线性插值\n\n### 贴图过大\n\nMipmap：范围查询（快速，近似，方形范围） \n\n额外存储：源图像的1/3（1/4+1/16+1/64···）\n\n![image-20240622095059440](../images/image-20240622095059440.png)\n\n![image-20240622100025588](../images/image-20240622100025588.png)\n\n![image-20240622100438789](../images/image-20240622100438789.png)\n\n#### 问题\n\n屏幕空间的矩形区域在纹理空间中对应不规则的区域\n\n![image-20240622101037850](../images/image-20240622101037850.png)\n\n### 各向异性过滤\n\n![image-20240622101114581](../images/image-20240622101114581.png)\n\n### 纹理应用\n\n环境光纹理\n\n![image-20240622115350899](../images/image-20240622115350899.png)\n\n![image-20240622115721817](../images/image-20240622115721817.png)\n\n凹凸贴图：改变任意位置的法线高度\n\n![image-20240622120054431](../images/image-20240622120054431.png)\n\n位移贴图：在凹凸贴图的基础上移动顶点（右图）\n\n![image-20240622121120322](../images/image-20240622121120322.png)\n\n**环境光遮蔽**的计算结果包含在纹理中：\n\n![image-20240622121603329](../images/image-20240622121603329.png)\n\n## 几何\n\n* implicit （隐式）：\n\n  ​\t定义一个几何体的**点所满足的关系**\n\n  ​\tf(x,y,z)=0\n\n* explicit（显示）：\n\n  ​\t直接给出所有点的坐标，或通过参数映射：\n\n  ![image-20240622122844246](../images/image-20240622122844246.png)\n\n### 隐式表示\n\n#### CSG\n\nConstructive Solid Geometry（implicit）\n\n通过基本几何图形的布尔运算定义新图形\n\n![image-20240622130458537](../images/image-20240622130458537.png)\n\n#### 距离函数\n\n<img src=\"../images/image-20240622132528640.png\" alt=\"image-20240622132528640\"  />\n\n#### 水平集\n\n![image-20240622132721425](../images/image-20240622132721425.png)\n\n#### 分形Fractals\n\n![image-20240622132957335](../images/image-20240622132957335.png)\n\n### 显式表示\n\n#### 点云\n\n简单表示所有点的坐标\n\n#### 多边形面Polygon Mesh\n\n#### 贝塞尔曲线\n\n用一系列控制点定义曲线\n\n![image-20240622135219977](../images/image-20240622135219977.png)\n\n![image-20240622135706042](../images/image-20240622135706042.png)\n\n![image-20240622135757216](../images/image-20240622135757216.png)\n\n任意时刻t，贝塞尔曲线上的点都由控制点决定\n\n![image-20240622140108914](../images/image-20240622140108914.png)\n\n![image-20240622140348232](../images/image-20240622140348232.png)\n\n性质：\n\n* **对控制点进行仿射变换**，等价于对贝塞尔曲线进行仿射变换。\n\n* 曲线在控制点形成的凸包（Convex Hull）内\n\n#### 多段贝塞尔曲线\n\nC^0^ 连续：第一段的终点和第二段的起点重合\n\nC^1^ 连续：重合点与前后两点的距离相等（一阶导数相等）\n\n![image-20240622141841377](../images/image-20240622141841377.png)\n\n贝塞尔曲面：\n\n将多个纵向贝塞尔曲线在**t的值**作为横向贝塞尔曲线的控制点\n\n![image-20240622143056496](../images/image-20240622143056496.png)\n\n#### Spline 样条\n\n可控曲线\n\n* Basic-splines 基函数样条\n\n### 网格Mesh\n\n* mesh subdivision\n* mesh simplification\n* mesh regulation \n\n#### 表面细分\n\n##### Loop subdivision\n\n​\t将三角形每条边一分为二（拆成四个三角形），用加权平均调整顶点位置\n\n##### Catmull-Clark subdividion\n\n<img src=\"../images/image-20240622152635801.png\" alt=\"image-20240622152635801\" style=\"zoom:33%;\" />\n\n经过一次细分后，非四边形面消失，增加了相同数量的奇异点。\n\n第二次及以后，奇异点数量不再变\n\n​\t<img src=\"../images/image-20240622152853980.png\" alt=\"image-20240622152853980\" style=\"zoom:33%;\" />\n\n※可以适用于四边形网格\n\n#### 网格简化\n\n边坍缩Edge collapse：\n\n![image-20240622153756363](../images/image-20240622153756363.png)\n\n![image-20240622153818078](../images/image-20240622153818078.png)\n\n从二次误差度量小的边开始坍缩\n\n## 光线追踪\n\n光栅化的局限性：难以表现影响全局的效果（软阴影，磨砂镜面反射，多次反射的间接光照）\n\n光线的定义：\n\n* 光沿直线传播\n* 两束光线互不影响，不会发生碰撞\n* 光从光源传到眼睛（观测）\n\n### 递归光线追踪\n\n* 找出经过反射后到达的所有点\n* shadow rays 判断点是否被遮挡\n* 在原像素点按比例叠加所有点的颜色\n\n![image-20240623115207843](../images/image-20240623115207843.png)\n\n#### 光线\n\n定义：\n\n<img src=\"../images/image-20240623115446379.png\" alt=\"image-20240623115446379\" style=\"zoom: 33%;\" />\n\n求光线与平面（隐式表示）的交点：\n\n<img src=\"../images/image-20240623115917410.png\" alt=\"image-20240623115917410\" style=\"zoom:33%;\" />\n\n求光线与三角形网格（显示表示）的交点：\n\n* 求三角形所在平面与光线的交点\n* 判断交点是否在三角形内\n\n![image-20240623123040874](../images/image-20240623123040874.png)\n\n用重心坐标求：\n\n![image-20240623123226865](../images/image-20240623123226865.png)\n\n### 优化\n\n#### 包围盒（AABB）\n\n※光线碰不到包围盒，一定碰不到物体\n\n※轴向包围盒可以用向量分量计算\n\n![image-20240623123758121](../images/image-20240623123758121.png)\n\n光线离开任何一组对面，离开包围盒\n\n光线进入所有对面，进入包围盒\n\n![image-20240623131028598](../images/image-20240623131028598.png)\n\nt~exit~<0:包围盒在光线背面\n\nt~exit~>=0 && t~enter~<0:光线在包围盒内部，一定相交\n\n#### 预处理\n\n##### 加速网格\n\n![image-20240623133949406](../images/image-20240623133949406.png)\n\n##### 空间划分 Spatial Partitions\n\n![image-20240623134751776](../images/image-20240623134751776.png)\n\n![image-20240623135320457](../images/image-20240623135320457.png)\n\n光线和父节点相交，则继续判断是否和子节点相交。\n\n问题：一个物体可能存在于多个盒子里；三角形和盒子边界求交集很麻烦\n\n##### 物体划分 Object  partition\n\nBVH（bounding volume hierarchy）\n\n![image-20240623140825659](../images/image-20240623140825659.png)\n\n### Basic radiometry 辐射度量学\n\n* radiant flux\n* intensity\n* irradiance\n* radiance\n\n![image-20240623151550414](../images/image-20240623151550414.png)\n\n![image-20240623151822948](../images/image-20240623151822948.png)\n\n立体角\n\n![image-20240623152103942](../images/image-20240623152103942.png)\n\n![image-20240623152349656](../images/image-20240623152349656.png)\n\n<img src=\"../images/image-20240623152616657.png\" alt=\"image-20240623152616657\" style=\"zoom:33%;\" />\n\n![image-20240623160256581](../images/image-20240623160256581.png)\n\nintensity不变化，irradiance会随距离衰减\n\n![image-20240626121234798](../images/image-20240626121234798.png)\n\nradiance：\n\n* irradiance per solid angle：单位立体角的irradiance\n* intensity per projected unit area：单位投影面积的光强\n\n## BRDF\n\nbidirectional reflectance distribution function：表示各个方向反射的能量分布\n\n![image-20240626122927103](../images/image-20240626122927103.png)\n\n![image-20240626125912466](../images/image-20240626125912466.png)\n\n### 渲染方程\n\n![image-20240626130406788](../images/image-20240626130406788.png)\n\nL=E+KL(光源本身+辐射出来的能量，递归定义)\n\n解L：光源本身+光源经过1次，2次...反射后的能量![image-20240626131347498](../images/image-20240626131347498.png)\n\n全局光照：光线经过无数次反射的光照集合\n\n## 概率论\n\n### 蒙特卡洛积分\n\n在积分域[a,b]间随机采样x~i~ ,以f(x~i~)*(b-a)为一个采样面积，多次采样求平均。\n\n![image-20240626140643735](../images/image-20240626140643735.png)\n\n用概率密度计算：\n\n![image-20240626141050572](../images/image-20240626141050572.png)\n\n## 路径追踪Path tracing\n\n利用蒙特卡洛积分计算渲染方程\n\n![image-20240626142925238](../images/image-20240626142925238.png)\n\n改进：物体反射的光照\n\n![image-20240626143219835](../images/image-20240626143219835.png)\n\n改进：一次路径追踪只追踪一根光照（N=1），多次追踪求平均\n\n![image-20240626143548214](../images/image-20240626143548214.png)\n\n问题：递归没有中止\n\n### 俄罗斯轮盘法 RR\n\n以规定的概率决定是否辐射光线\n\n![image-20240626144344445](../images/image-20240626144344445.png)\n\n问题：从着色点均匀采样，会有很多样本浪费\n\n![image-20240626144716970](../images/image-20240626144716970.png)\n\n### 采样光源\n\n渲染方程需对光源积分：找出dω和dA的关系\n\n![image-20240626145150937](../images/image-20240626145150937.png)\n\n![image-20240626145432887](../images/image-20240626145432887.png)\n\npdf：1/A\n\n![image-20240626145903294](../images/image-20240626145903294.png)\n\n## 材质\n\n**BSDF（BRDF+BTDF）**决定了物体的材质。\n\n# Shader\n\n## 基本操作\n\niResolution：shadertoy提供的内置变量，\n\niResolution.xy ==(iResolution.x,iResolution.y)\n\n\t* iResolution.x：画布宽度\n\t* iResolution.y：画布高度\n\t* iResolution.z：画布深度\n\nfragCoord：画布上的每个像素点\n\nfracColor：对应点的颜色\n\n```glsl\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //坐标缩放为[-1,-1]~[1,1]\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n}\n```\n\n### 法线变换\n\n使用原变换矩阵的**逆转置矩阵**\n\n### 坐标轴变换\n\n```c\n//圆点移到中心 uv=[-1,1]\nuv = uv*2.-1.;\n//放大，缩小 (uv变小，画面变大)\nuv *= 0.01;\n```\n\n### 旋转\n\n```c\nmat2 rot2D(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    return mat2(c,-s,s,c); //2x2的旋转矩阵\n}\n\np.xz *= rot2D(0.3) //绕y轴旋转\n```\n\n## texture mapping\n\n在贴图映射时，可以使用本地坐标，也可以使用世界坐标。\n\n```c#\nShader \"Unlit/Textured\"{\n    Properties{\n        _MainTex(\"Texture\",2D) = \"white\" {} //\"white\"为默认值\n    }\n    SubShader{\n        Tags{\n            \"RenderType\" = \"Opaque\", //预处理相关\n            \"Queue\" = \"Geometry\" //渲染顺序相关\n        } \n        Pass{\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"UnityCG.cginc\"\n            \n            struct MeshData{\n            \tfloat4 vertex:POSITION; //网格的本地坐标\n            \tfloat2 uv:TEXCOORD0; //uv\n        \t}\n            \n            struct Interpolators{\n                float4 vertex: SV_POSITION;\n                float2 uv: TEXCOORD0;\n                float3 worldPos: TEXCOORD1;\n            }\n            \n\t\t\t...\n\t\t\t...\n\t\t\tInterpolators vert(MeshData v){\n                Interpolators o;\n                o.worldPos = mul(UNITY_MATRIX_M,v.vertex);//顶点坐标转换到世界坐标\n                o.vertex = UnityObjectToClipPos(v.vertex); //顶点坐标转换到屏幕空间\n                o.uv = v.uv;\n                o.uv.x += _Time.y * 0.1; //随事件偏移uv\n                return o;\n            }\n\n            float4 frag(Interpolators i):SV_Target{\n                float2 topDownProjection = i.worldPos.xz;\n                float4 moss=tex2D(_MainTex,topDownProjection);//根据世界坐标从贴图采样\n                return moss;\n            }\n            ENDCG\n        }\n    }\n}\n```\n\n## Environment Mapping\n\n\n\n## multyPasses(Forward rendering)\n\n```c#\nShader\"...\"{\n    Properties{\n        \n    }\n    SubShader{\n        Tags{\n            '...'\n        }\n        \n        Pass{\n            Tags {\"LightMode\" = \"ForwardBase\"}\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #include \"FGLighting.cginc\"\n            ENDCG\n        }\n        \n        Pass{\n            Tags {\"LightMode\" = \"ForwardAdd\"}\n            Blend One One //混合模式，叠加\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            #pragma multi_compile_fwadd\n            #include \"FGLighting.cginc\"\n            ENDCG\n        }\n    }\n}\n```\n\n## 噪声\n\n### Value Noise\n\n```c\n//首先通过合适的函数，返回分布比较散的[0,1]的值\nfloat hash(vec2 seed){\n    return fract(sin(seed.x*123. + seed.y*231.)*1241.);\n}\n\n//将随机值的分布连续化\n//方法一：ValueNoise\nfloat getNoise(vec2 uv,float gridSize){\n    //将坐标分布在[(0,0),(gridSize,gridSize)]的网格中\n    vec2 currentGrid=vec2(floor(uv.x*gridSize),floor(uv.y*gridSize));\n    //获取网格四个顶点的随机值\n    float value00=hash(currentGrid);\n    float value01=hash(vec2(currentGrid.x,currentGrid.y+1.));\n    float value10=hash(vec2(currentGrid.x+1.,currentGrid.y));\n    float value11=hash(vec2(currentGrid.x+1.,currentGrid.y+1.));\n    \n    //进行线性插值\n    float value0=mix(value00,value01,fract(uv.y*gridSize));\n    float value1=mix(value10,value11,fract(uv.y*gridSize));\n    float value=mix(value0,value1,fract(uv.x*gridSize));\n    \n    //或使用smoothstep让分布更加平滑\n    float value0=mix(value00,value01,smoothstep(0.,1.,fract(uv.y*gridSize)));\n    float value1=mix(value10,value11,smoothstep(0.,1.,fract(uv.y*gridSize)));\n    float value=mix(value0,value1,smoothstep(0.,1.,fract(uv.x*gridSize)));    \n  \n    //可以叠加不同频率，得到更平滑的值(FBM)\n    value+=valueNoise(uv,gridSize*2.)*0.5;\n    value+=valueNoise(uv,gridSize*4.)*0.25;\n    value+=valueNoise(uv,gridSize*8.)*0.125;\n    value+=valueNoise(uv,gridSize*16.)*0.0625;\n    value/=1.9375;\n    return value;\n}\n```\n\n![image-20241105144243678](../images/image-20241105144243678.png)\n\n### Gradient Noise\n\n### voronoi \n\n```c\nvec2 hashPoint(vec2 seed){\n    vec3 a=fract(seed.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z)); \n}\n\nfloat voronoi(vec2 uv,float gridSize){\n    float t=iTime*.2+200.;\n    float minDist=100.; //到随机点最短的距离\n    vec2 cellIndex=vec2(0.); //最短距离所指向的点\n\n    uv*=gridSize;\n    vec2 gv=fract(uv)-.5;\n    vec2 id=floor(uv);\n    for(float y=-1.;y<=1.;y++){\n    \n        for(float x=-1.;x<=1.;x++){\n        \n            vec2 offset=vec2(x,y);\n            vec2 n=hashPoint(id+offset);\n            vec2 p=offset+sin(n*t)*.5; //-1~1的随机向量\n            float d=length(gv-p);\n            if(d<minDist){\n                minDist=d;\n                cellIndex=id+offset;\n            }\n        }\n    }\n    //利用cellIndex可以对特定网格进行操作\n    return minDist;\n}\n```\n\n## 排列\n\n[wiki](https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons)\n\n### Truchet Tiling\n\n```c\n//输入2，输出1的hash函数\nfloat Hash21(vec2 p){\n  \tp=fract(p*vec2(234.34,435.345));\n    p +=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\n\nfloat TruchetTiling(vec2 uv,float gridSize){\n   \tuv *= gridSize;\n    vec2 gv = fract(uv)-.5; //获取在网格内的相对坐标[-0.5,0.5]\n    vec2 id = floor(uv);    //获取所在网格的序号\n    float n = Hash21(id);\n    \n    float width =.1; //线宽\n    if(n<.5) gv.x *= -1; //随即翻转\n    \n    float d = abs(abs(gv.x+gv.y)-.5); //将连线的顶点平移到网格边的中心\n    \n    \n    float mask = smoothstep(.01,-.01,d-width);\n    return mask;\n}\n```\n\n## RayMarching\n\n```c\n#define MAX_STEPS 100 //迭代的最大步数\n#define MAX_DIST 100. //超出该距离视为射线不再碰撞\n#define SURF_DIST .01 //小于该距离视为射线已经碰撞\n\nfloat GetDist(vec3 p){\n    SDF1 = ... //到不同的物体有需要不同的距离函数\n    return min(SDF1,SDF2...,); //选择所有距离中最小的\n}\n\nfloat GetLight(vec3 p){\n    \n}\n\nfloat GetShadow(vec3 p){\n    //从p点进行rayMarch，如果dist<p到lightPos的距离，则为阴影\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){ //ro:rayOrigin rd:rayDistance\n\tfloat d=0;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+d*rd;\n        float dS = GetDist(p);\n        d += dS;\n        if(dS<SURFACE_DIST || d>MAX_DIST) break;\n    }\n    return d;\n}\n```\n\n### 法线方向\n\n对于任意SDF f(p)，f(p)=0的点p将构成一个表面。因此p点的法线向量可以表示为：\n$$\nn=normalize(∇f(p))\n$$\n法线计算：\n$$\n\\frac{df(p)}{d(x)}≈\\frac{f(p+(h,0,0))-f(p-(h,0,0))}{2h}\n$$\n![image-20241109122811807](../images/image-20241109122811807.png)\n\n```c\nvec3 calcNormal(in vec3 p){\n    const float eps = 0.0001; // replace by an appropriate value\n    const vec2 h = vec2(eps,0.);\n    //高精度\n    return normalize(vec3(f(p+h.xyy) - f(p-h.xyy),\n                          f(p+h.yxy) - f(p-h.yxy),\n                          f(p+h.yyx) - f(p-h.yyx)));\n    //简化计算，f(p)=0忽略\n    return normalize(vec3(f(p+h.xyy),\n                          f(p+h.yxy),\n                          f(p+h.yyx)));\n}\n\n//改进版本\nvec3 calcNormal( in vec3 & p ) \n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n```\n\n### FlowMap\n\nvalve 2010 GDC\n\n使用RG通道记录2D向量，模拟流动效果\n\n## 测试\n\n### 模板测试\n\n## 光照\n\n### Fresnel Effect\n\n视角方向和表面法线的夹角越大，反射效果越好\n\nSchlick菲涅尔近似等式（v：视角方向，n：表面法线）：\n$$\nF_{schlick}(v,n) = F_0 + (1-F_0)(1-v \\cdot n)^5\n$$\n\n## PBS-基于物理的渲染技术\n\n### 光\n\n光是一种电磁波，由光源发射，在物体表面**吸收**或**散射**，最终被眼睛吸收成像。\n\n吸收：光被转化成了其他能量\n\n散射：光的传播方向被改变\n\n光在不同介质的边界会被分割乘两个方向：反射和折射。**菲涅尔等式**决定了有多少比例的光被反射。\n\n在**理想模型**中，边界是光滑且无限延伸的：\n\n![image-20241206124454600](../images/image-20241206124454600.png)\n\n在现实中，物体表面不可能是完全光滑的，且被折射的光又有一部分被散射到外部，称为**次表面散射**（蓝色箭头）。\n\n![image-20241206125601367](../images/image-20241206125601367.png)\n\n在次表面散射（subsurface-scattered light）中，如果入射点之间的距离小于像素大小，则可以忽略，视为从同一点发出。\n\n![image-20241206130040870](../images/image-20241206130040870.png)\n\n### BRDF\n\n用辐射率radiance表示**单位面积，单位方向上光源的辐射量**。\n\n在渲染中，我们通常会基于表面的入射光辐射率，计算出射光辐射率。这个过程就需要BRDF（双向反射分布函数）分析。\n\n## 色彩存储与显示\n\n### LDR，HDR\n\n| LDR：Low Dynamic Range      | HDR：High Dynamic Range                      |\n| --------------------------- | -------------------------------------------- |\n| 电视，电脑上看到的范围，0~1 | 现实中的动态范围，约15~10万                  |\n| 8位精度                     | 远高于8位精度                                |\n| jpg，png                    | hdr，tif，exr，raw..                         |\n| 值在0~1之间                 | 可超过1                                      |\n|                             | 渲染速度较慢，需要更多显存，不支持硬件抗锯齿 |\n\nDynamic Range（动态范围）：最高亮度/最低亮度\n\n从HDR映射到LDR的过程叫**ToneMapping**\n\n### ACES\n\nAcamedy Color Encording System，最被广泛使用的ToneMapping曲线\n\n![image-20241210135047137](../images/image-20241210135047137.png)\n\n### HSL&HSV\n\n![undefined](../images/1280px-Hsl-hsv_models.svg.png)\n\n#### HSL转RGB\n\n```glsl\n// c = hue/saturation/lightness\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n```\n\n","tags":["编程","游戏","C++"],"categories":["程序设计","图形学"]},{"title":"UI设计作品汇总","url":"/2024/04/24/my-design-works/","content":"\n## **贝壳指北 移动端APP项目**\n\n>“贝壳指北”是一款运用了image caption技术的智能APP，它可以通过拍照识别出楼宇，并且输出对应的介绍和吐槽，就像一个真人导游一样。不仅如此，它还可以让你了解楼宇内的机器使用方式，实验室介绍等，让你更深入地掌握校园的信息。此外，我们的APP还有地图位置显示，搜索搜楼，地图点击等功能，让你随时随地找到你想去的地方，并且看到实景图。\n\n为配合“贝壳”这一形象，整体采用淡蓝色调，以母校“北科”的谐音“贝壳”作为原型，在中心加上了象征APP功能的指南针。\n\n![软件UI](../images/软件UI.jpg)\n\n<!--more-->\n\n## **Flikwise 影评网站项目**\n\n> “Flikwise” 是一个影评网站，旨在提供一个类似于IMDB的平台，供用户分享、浏览和评价电影，成为电影爱好者之间交流和获取电影信息的热门社交平台。\n\n![image-20240424202021260](../images/image-20240424202021260.png)\n\n![image-20240424202037136](../images/image-20240424202037136.png)\n\n![影评网站4](../images/影评网站4.png)\n\n## Room-327 极简聊天软件\n\n> Room-327是计算机网络课程设计项目，由我使用electro+vue3独自完成。\n>\n> 功能有创建/加入局域网聊天室，可以在聊天室的大厅中发送群体信息，或跟聊天室的任意其他用户私聊。\n\n![room-327](../images/room-327.png)\n\n![room-327（2）](../images/room-327（2）.png)\n","tags":["设计"],"categories":["个人作品","平面设计"]},{"title":"rust学习笔记","url":"/2024/04/24/my-rust-note/","content":"\n# 引言\n\n本文是阅读https://doc.rust-lang.org/book/title-page.html所做的学习笔记。\n\n<!--more-->\n\n## Hello world\n\n```rust\nfn main(){\n\tprintln!(\"Hello World!\");\n}\n```\n\n* main函数是rust可执行文件的入口函数，总是第一个被执行。\n* rust缩进使用4个空格而非tab\n* `println!` 会调用一个宏，去掉`!`表示调用一个函数\n\nRust是一种**预编译静态类型**（ahead-of-time compiled）语言，因此你可以将可执行文件发送给没有安装Rust的人运行。\n\n## Cargo\n\nCargo是rust的构建系统和包管理器，可以给rust程序简单地添加依赖。\n\n`cargo new [filename] ` 可以创建一个代有*Cargo.toml*的项目文件夹。\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n```\n\n`cargo doc --open`可以生成当前依赖的文档，并在一个网页中打开。\n\n### Build\n\n`cargo build` 会在 `./target/debug` 构建一个可执行文件，同时在根目录创建一个*Cargo.lock*文件，这个文件可以自动追踪当前的依赖版本。\n\n`cargo run` 可以在build后直接运行文件。\n\n`cargo check` 可以在不产生exe的情况下检查你的代码是否编译完成。\n\n`cargo build --release` 会在 `./target/release ` 构建release版本可执行文件，这个文件的运行速度会更快，但编译速度更慢。\n\n## use\n\n```rust\nuse std::io;\n```\n\n`use`  关键字可以引入library。默认情况下，rust设定了若干个自动导入的标准库内容称为[预导入（*prelude*）内容](https://doc.rust-lang.org/std/prelude/index.html)\n\n## 变量定义\n\n### let & const\n\n`let` 可以声明一个变量，变量默认是**不可变**的（*immutable*），使用 `mut` 关键字可以使变量可变，但**不可改变数据类型**。\n\n```rust\nlet mut guess = String::new();\n```\n\n`::`表明`new()`是String类型的一个**关联函数**（*associated function*），类似C++中静态方法。\n\n`const` 可以声明一个常量，常量不可使用`mut`，且必须显式声明类型。在声明它的作用域中，常量在整个程序生命周期中都有效，常用来作为全局范围的值。\n\n```rust\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n```\n\n### shadowing\n\n重复声明一个变量会让第一次声明的值被隐藏，直至二次声明的作用域结束。\n\n与`mut`的区别是，shadowing会创建一个新的变量，可以改变值得类型。\n\n```rust\nfn main() {\n    let x = 5;\n    let x = x + 1;\n    {\n    let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n        //x=12\n    }\n        println!(\"The value of x is: {x}\");\n    \t//x=6\n}\n```\n\n## 数据类型\n\nRust是**静态类型**语言，在编译时必须知道所有变量得类型。\n\n* Scalar（标量）：\n  * Integer：`i8` \\~ `i128` , `u8` \\~ `u128` , `isize` , `usize`\n  \n  | 进制           | 例子           |\n  | -------------- | -------------- |\n  | Decimal        | 98_222 (98222) |\n  | Hex            | 0xff           |\n  | Octal          | 0o77           |\n  | Binary         | 0b1111_0000    |\n  | Byte (u8 only) | b'A'           |\n\n  * float：`f32` , `f64` \n  * boolean：`bool`，值为true或false\n  * character：`char`，**4Bytes**，unicode，使用单引号声明\n  \n* Compound 复合类型：\n\n  * tuple 元组：\n\n  ```rust\n  fn main() {\n      let tup: (i32, f64, u8) = (500, 6.4, 1);\n      \n      let temp = tup.0; // 下标访问，temp=500\n      \n      let (x, y, z) = tup;  //元组解构\n      \n      //单元(unit)：空值或空得返回类型\n      let unit: ()=();\n  }\n  ```\n\n  * array 数组：在栈上分配的固定大小的单个内存块，**所有元素类型必须相同，长度固定**。\n\n  ```rust\n  fn main(){\n  \tlet arr: [i32; 5] = [1, 2, 3, 4, 5];\n      let arr2: [1;2]; //arr2=[1,1]\n      \n      let first = arr[0]; //索引访问\n  }\n  ```\n\n## 函数\n\n### 定义\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n    another_function(1);\n}\n\nfn another_function(x: i32，y: char) {\n    println!(\"The values are: {x} {y}\");\n}\n```\n\n`fn`关键字定义，不分前后。\n\n在函数签名中，必须**声明每个参数的类型**。\n\n### 语句和表达式\n\nRust是一门基于表达式（expression-based）的语言，函数体由一系列语句（Statements）和可选的结尾表达式（Expressions）构成。\n\n语句不返回值，表达式会计算并返回一个值。\n\n一个数字（字符），函数调用，宏调用，块作用域 都是表达式，**表达式的结尾没有分号，如果加上分号就变成语句。**\n\n```rust\nfn main() {\n    let y = {\n    let x = 3;\n    x + 1\n    };\n println!(\"The value of y is: {y}\");\n}\n\n//有返回值的函数\nfn plus_one(x: i32) -> i32 {\n x + 1\n}\n```\n\n链式调用\n\n\n```rust\nio::stdin()\n    .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n```\n\nread_line()返回Result类型，Result分为Ok和Err两种值\n\n### println!\n\n```rust\nprintln!(\"you guessed: {guess}\");\n\nprintln!(\"x = {x} and y + 2 = {}\", y + 2);\n//第二个{}值为y+2\n```\n\n{}占位符可以将变量的值打印。\n\n## 控制流\n\n### 条件\n\n```rust\nfn main() {\n    let number = 3;\n\n    if number < 5 {\n        println!(\"condition was a\");\n    } else if number < 10 {\n        println!(\"condition was b\");\n    } else {\n        println!(\"condition was c\");\n    }\n    \n    //使用在语句中，分支返回值类型必须相同\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n}\n```\n\n### 循环\n\n#### loop\n\n```rust\nfn main() {\n    let result = loop {\n        println!(\"again!\");\n        break [返回值]; //退出循环，可选返回值\n        continue; //跳过此轮\n    }\n}\n\n//通过给loop加上label，可以跳出外层循环\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"count = {count}\");\n        let mut remaining = 10;\n\n        loop {\n            println!(\"remaining = {remaining}\");\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"End count = {count}\");\n}\n```\n\n#### while\n\n相当于loop+if\n\n```rust\nfn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(\"{number}!\");\n\n        number -= 1;\n    }\n\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n#### for\n\n用于遍历一个集合\n\n```rust\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n}\n\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{number}!\");\n        //输出 3! 2! 1!\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n## Ownership 所有权\n\n所有权是Rust最与众不同的特性，它让Rust无需垃圾回收即可保障内存安全。\n\n所有权是管理内存的一系列的规则，编译器若发现程序有违这些规则，就会编译失败。因此所有权的内存管理在程序运行中不会有性能损耗。\n\n### 堆&栈\n\n堆栈都是代码在运行时可供使用的内存，但它们的结构不同。\n\n**栈**：先进后出，栈中所有数据都必须占用已知且固定的大小。\n\n**堆**：向堆存放数据时，要先请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到足够大的空位标记并返回一个指针。\n\n### 所有权规则\n\n* Rust中的每个值都有一个*owner*，且在任何时候都唯一。\n* 当*owner*离开作用域，这个值就会被丢弃。\n\n### 作用域\n\n以`String`类型为例，`String`不同于`string`，是分配在堆上的，可用于创建编译阶段未知大小的字符串（例如用户输入）。\n\n这种类型的数据可以在程序运行中发生改变，这意味着：\n\n* *memory allocator*会在运行时申请内存分配。\n* 需要一个方法以在这个变量用完时释放内存。\n\n```rust\nlet mut s = String::from(\"hello\");\n\ns.push_str(\", world!\"); // push_str() appends a literal to a String\n\nprintln!(\"{}\", s); // This will print `hello, world!`\n```\n\n当变量在离开作用域时，Rust会调用一个特殊的函数`drop`，在这个函数中执行内存释放相关的操作。\n\n> 在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取 即初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的 话应该对 Rust 的 drop 函数并不陌生。\n\n### 变量与数据交互\n\n#### Move\n\n1.将x的值赋给y，则x，y的值均被存入栈中。\n\n```rust\nlet x = 5;\nlet y = x;\n```\n\n2.String复制时，只从栈上拷贝了ptr，len，capacity，而没有复制指针指向的数据。为了防止重复释放内存，Rust在发生复制后，认为s1不再有效，在创建s2后使用s1将**报错**。\n\n※Rust永远不会自动创建数据的“深拷贝”，因此任何自动的复制都不会有太大的性能影响。\n\n```\nlet s1 = String::from(\"Hello\");\nlet s2 = s1;\n```\n\n![image-20240425102457409](../images/image-20240425102457409.png)\n\n`copy trait`注解：允许在move后依然有效。（整数，布尔，浮点数，字符，以及只包含上述类型的元组）\n\n#### Clone\n\n使用clone可以人为地复制变量。\n\n```rust\nlet s1 = String::from(\"Hello\");\nlet s2 = s1.clone();\n```\n\n#### 函数调用的move和clone\n\n```rust\nfn main() {\n    let s = String::from(\"hello\"); // s进入作用域\n    takes_ownership(s); // s的值移动到函数里\n                        // s不能再被使用\n    \n    let x = 5; // x 进入作用域\n    makes_copy(x); // x 应该移动函数里，\n                   // 但 i32 是 Copy 的，\n                   // 所以在后面可继续使用 x\n}                  // 这里，x 先移出了作用域，然后是s。但s的值已被移走\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n println!(\"{}\", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。\n // 占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n println!(\"{}\", some_integer);\n} // 这里，some_integer 移出作用域。没有特\n```\n\n```rust\nfn main() {\n    let s1 = gives_ownership();  \n    let s2 = String::from(\"hello\");     \n    let s3 = takes_and_gives_back(s2);  \n} \t\t\t\t\t\t\t\t\t\t//s2被move，s1和s3被drop\n\nfn gives_ownership() -> String {             \n    let some_string = String::from(\"yours\");// some_string comes into scope\n    some_string                             //some_string被返回\n}\n\nfn takes_and_gives_back(a_string: String) -> String { \n    a_string  \n}\n```\n通过元组返回多个值\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let (s2, len) = calculate_length(s1);\n    println!(\"The length of '{}' is {}.\", s2, len);\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() returns the length of a String\n    (s, length)\n}\n```\n\n### Borrowing\n\n引用（*reference*）可以在传递参数的同时不获取其所有权，因此可以让原来的变量继续使用。\n\n创建一个reference的行为称为borrowing。\n\n无效的引用会导致报错，以避免空指针。\n\n**reference不允许修改引用的值。**\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1);\n    //s1可以继续使用\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n![image-20240425125325560](../images/image-20240425125325560.png)\n\n#### 可变引用\n\n通过`&mut`可以创建可变引用，如果作为函数参数，形参也应该声明为可变引用。\n\n**可变引用在同一作用域只能存在一个，以防止数据竞争。**\n\n**不可变引用生效前不能使用可变引用**。\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n#### Slice\n\n字符串slice是String中部分值的引用。\n\n```rust\nlet s = String::from(\"hello world\");\nlet hello = &s[0..5]; //左开右闭（0可省略）\nlet world = &s[6..11];\nlet slice = &s[0..s.len()];\n```\n\n![image-20240425132107322](../images/image-20240425132107322.png)\n\n## struct 结构体\n\n```rust\nstruct User{\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n    active: true,\n    username,  //简化写法，形参与字段重名\n    email,\n    sign_in_count: 1,\n    }\n}\n\nfn main(){\n    //实例化\n    let mut use1 = User{\n        active: true,\n        username: String::from(\"abc\"),\n        email: String::from(\"abc@qq.com\"),\n        sign_in_count: 1,\n    };\n    //访问\n    user1.email = String::from(\"def@qq.com\");\n    //结构体更新语法 move规则与元组相同\n    //如果username或email中至少一个拷贝了user1，user1失效\n    let user2 = User {\n        email: String::from(\"ggg@qq.com\");\n        ..user1\n    }\n}\n```\n\n### tuple structs 元组结构体\n\n※元组结构体的参数类型相同也不能互相传参\n\n```rust\nstruct Color(i32, i32, i32);\n\nfn main(){\n    let black = Color(0, 0, 0);\n}\n```\n\n\n\n### unit-like structs\n\n没有任何字段的结构体\n\n```rust\nstruct AlwaysEqual;\n\nfn main(){\n    let subject = AlwaysEqual;\n}\n```\n\n### 打印struct\n\n```rust\n//加上外部属性\n#[derive(Debug)]\nstruct User{\n    \n}\n\nfn main() {\n    let user = User{\n        \n    };\n    //仅打印\n    println!(\"{:?}\",&user);\n\n    //打印并返回值\n    dbg!(&user);\n    dbg!(user);\n}\n```\n\n### 关联方法&关联函数\n\n关联方法（associated method）以`self`为第一个形参\n\n关联函数（associated functions）不作用于**结构体实例**，类似c++中的静态函数。\n\n`impl`块中用来存放与结构体相关的函数/方法，`impl`块可以存在多个。\n\n```rust\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle{\n    //第一个参数为self/&self/&mut self\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n    //可以在同名方法中使用同名字段\n    fn width(&self) -> bool {\n        self.width > 0 \n    }\n    //传入同类型的参数\n    fn compare(&self, other: &Rectangle) -> bool {\n        self.width > other.width\n    }\n    \n    //关联函数 Self为关联结构体的别名\n    fn new_square(size: u32) -> Self{\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nfn main() {\n\tlet rect1 = Rectangle{\n        \n    }\n    rect1.area();\n}\n```\n\n## 枚举\n\n"},{"title":"《游戏设计艺术》笔记","url":"/2024/04/19/read-the-art-of-game-design/","content":"\n> 真正的发现之旅不在于寻找新风景，而是拥有新眼光。\n> ——马塞尔·普鲁斯特\n\n游戏设计师最终关注的是创造**体验**。\n\n<!--more-->\n\n## 体验\n\n### 1号透镜：情感\n\n* 我希望玩家能够体验到怎样的情感？为什么？\n* 当人们玩游戏时，他们产生了怎样的情感？为什么？\n* 我怎样缩小人们实际体验与我的设想之间的距离？\n\n分析记忆\n\n### 2号透镜：本质体验\n\n* 我想要让玩家获得怎样的体验？\n* 这种体验的本质是什么？\n* 我应该如何让我的游戏抓住这种体验的本质？\n\n如果你对玩家获得的体验有明确的想象，并知道游戏中的哪一部分创造了这种体验，你就能更清楚地知道怎样才能把你的游戏变得更好，因为你知道游戏中哪些元素能够安全地改变，而哪些不行。\n\n### 3号透镜：场景\n\n* 我想要制作的游戏最适合哪种场景？\n* 我的场景中是否有一些特殊的属性会影响到我的游戏？\n* 我的游戏中有哪些元素能够与场景和谐共处，哪些不行？\n\n![image-20240419124003314](../images/image-20240419124003314.png)\n\n炉边设计的游戏系统：wii，与家庭成员一起游玩\n\n工作台：PC（steam），单独更高，更适合单人或在线\n\n读书角：iPad，难度更低，更简单放松\n\n竞技场：体育运动，电子竞技\n\n### 4号透镜：惊喜\n\n* 当玩家们玩我的游戏时，什么会让他们感到惊喜？\n* 我的游戏中的故事，规则，艺术，技术有惊喜吗？\n* 你的规则能够让玩家之间互相带来惊喜吗？\n* 你的规则能够让玩家们给自己带来惊喜吗？\n\n### 5号透镜：乐趣\n\n大多数玩乐活动都是尝试回答这样的问题：\n\n* 当我转动把手时会发生什么？\n\n* 我们能击败这支队伍吗？\n\n* 我能把这些黏土做成什么？\n\n* 我能跳神多少次？\n\n* 完成这个关卡后会发生什么？\n\n### 6号透镜：好奇心\n\n* 我的游戏给玩家的大脑提出了怎样的问题？\n* 我正在做哪些努力让他们在意这些问题？\n* 我能做什么来使他们提出更多的问题？\n\n### 7号透镜：内生价值\n\n* 在我的游戏中哪些东西对玩家很有价值？\n* 怎样让这些东西对玩家更有价值？\n* 游戏中的价值与玩家的动机之间有怎样的关系？\n\n### 8号透镜：解决的问题\n\n* 我的游戏要求玩家解决哪些问题？\n* 是否有一些隐藏的问题作为玩法的一部分出现？\n* 在我的游戏中，怎样产生新的问题来对玩家保持吸引力？\n\n## 元素\n\n### 9号透镜：四种元素\n\n四种基本元素：\n\n\t* 右脑元素：美学，故事\n\t* 左脑元素：机制，技术\n\n### 10号透镜：全息设计\n\n四种元素和玩家体验，以及联系方式。\n\n* 游戏中的哪一种元素产生了令人享受的体验？\n* 游戏中的哪一种元素会让玩家在体验中分心？\n* 怎样改变游戏元素来提高游戏体验？\n\n## 主题\n\n### 11号透镜：统一\n\n* 我的主题是什么？\n* 我已经采用了所有方法来强化这个主题吗？\n\n### 12号透镜：共鸣\n\n* 在我的游戏中，有哪些有力的或者特殊的元素？\n* 我的游戏描述给他人时，那些创意真的能让他们兴奋吗？\n* 如果没有任何限制，这个游戏将会变成什么样？\n* 我对这个游戏的方向有特定的直觉，是什么在驱动这种直觉呢？\n\n## 灵感\n\n> 当你知道如何倾听时，每个人都可以成为大师。\n>\n> ​\t——拉姆·达斯\n\n### 13号透镜：无尽灵感\n\n* 我的生活中有怎样的体验想要与他人分享？\n* 有哪些技巧可以让我捕捉到体验的本质，并把它纳入我的游戏中？\n\n## 约束\n\n### 14号透镜：问题陈述\n\n* 我真正想要解决什么问题？\n* 我是否做过一些与真正目标无关的游戏设定？\n* 游戏是不是这个问题最好的解决方案？\n* 我将怎样分辨出问题是否已经解决了？\n\n## 头脑风暴\n\n* 记下答案\n* 写在纸上\n* 草图\n* 玩具\n* 改变视角\n* 沉浸你自己\n* 开几个玩笑\n* 不要节约材料\n* 写在墙上（白板）（多人）\n* 空间记忆\n* 记下所有东西\n* 为你的清单计数\n* 颠覆你的设定\n* 组合和搭配分类\n* 自言自语（独自）\n* 找一个搭档\n\n### 15号透镜：八项测试\n\n* 艺术冲动：作为设计师，问自己这个游戏是否“感觉不错”。\n* 人群特征：这个设计是否符合目标受众？\n* 体验设计：游戏是否经得起这些透镜的检验？\n* 革新：这个设计是否与众不同？\n* 商业和市场：这个游戏能盈利吗？\n* 工程：这个游戏在技术上是否具备可行性？\n* 社区：这个游戏达到我们的社区/社交目标了吗？\n* 玩法测试：游戏测试者是否享受这个游戏？\n\n## 迭代\n\n### 软件开发螺旋模型\n\n包含三个理念：风险评估，原型，迭代\n\n\t* 想出一个基础设计\n\t* 找出设计中的最大风险\n\t* 建立原型消除这些风险\n\t* 测试这个原型\n\t* 基于你从原型中得出的结论做一个更详细的设计\n\t* 回到第二步\n\n\n\n![image-20240424084946656](../images/image-20240424084946656.png)\n\n### 敏捷宣言\n\n2001年由一群软件工程师提出。\n\n1. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。\n2. 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。\n3. 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。\n4. 业务人员和开发人员必须相互合作，项目中的每一天都不例外。\n5. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。\n6. 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。\n7. 可工作的软件是进度的首要度量标准。\n8. 敏捷过程倡导可持续开发。责任人，开发人员和用户要能够共同维持其步调稳定延续。\n9. 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。\n10. 以简洁为本，它是极力减少不必要工作量的艺术。\n11. 最好的架构，需求和设计出自组织团队。\n12. 团队定期地反思如何能提高成效，并依此调整自身的举止表现。\n\n敏捷开发的核心元素：\n\n* 灵活的目标：迅速适应新的的创意和信息，有计划地改变计划。\n* 优先级列表：给需要完成的特性定优先级，从顶端的开始完成。\n* 冲刺：制定多个短期目标，更多的DDL意味着更多的工作被完成。\n* 争分夺秒会议：10~15分钟的短会，每个成员只解释三件事：昨天完成了什么，今天计划完成什么，面临的问题。会议后与团队成员一对一解决问题。\n* 演示日：每个冲刺阶段的最后，团队观看和测试工作结果，并从新的基准开始工作，分析风险，确定计划。\n\n## 风险评估与原型设计\n\n\n\n152\n","tags":["游戏"],"categories":["游戏制作","读书笔记"]},{"title":"游戏技术笔记","url":"/2024/03/23/my-game-notes/","content":"\n# 游戏技术笔记\n\n## 多人实时对战\n\n|          | 传输内容 | 逻辑计算 | 断线重连 | 回放/观战 |\n| -------- | -------- | -------- | -------- | --------- |\n| 帧同步   | 操作     | 客户端   | 追历史帧 | 天然支持  |\n| 状态同步 | 结果     | 服务器   | 下次同步 | 另外实现  |\n\n不是非此即彼的二选一，最终同步的都是**数据状态**。\n\n<!--more-->\n\n### 同步策略\n\n在有延迟的情况下，给玩家无延迟的体验\n\n* 慢节奏（简单）：\n  * 回合制游戏\n  * 表现层面优化，及时反馈\n* 快节奏：\n  * 无冲突（简单）\n  * 有冲突（困难）\n\n快节奏有冲突的同步策略：\n\n* 预测：服务端同步前先更新客户端的变化\n* 和解：\n* 插值：\n\n### io小游戏举例\n\n移动+击晕其他玩家的小游戏：\n\n* 快节奏\n* 有冲突：被其他人击晕后停止移动\n* 操作及时反馈：帧同步\n* 进入游戏（连接）：状态同步\n\n![image-20240323121914743](../images/image-20240323121914743.png)\n\n## 3D数学\n\n# 游戏企划书\n\n* 在尽可能早的阶段放出游戏画面\n\n\n\n\n\n\n\n# 游戏设计\n\n## SOLID principles\n\n* Single responsibility\n* Open-closed\n* Liskov substitution\n* Interface segregation\n* Dependency inversion\n\n### Single-responsibility\n\n每个类，或模块只负责一个单一的功能，细分类和方法，让它们的功能一目了然。\n\n把**易读性，可扩展性，可复用性**作为实现SRP的标准。\n\n### Open-closed \n\nopen for extension but closed for modification。对扩展开放，对修改关闭。\n\n### Liskov substitution\n\n子类必须实现基类的所有方法。优先考虑组合（interface）而非继承。\n\n### Interface segregation \n\n不要让接口里含有无关的方法，拆分成更细的接口。\n\n### Dependency inversion principle\n\n当两个类之间有关联时，就必然会引入一定程度的风险。不要直接让两个类关联，而是引入一个抽象层。\n\n![image-20241028182559422](../images/image-20241028182559422.png)\n\n### 抽象类和接口\n\n| 抽象类             | 接口             |\n| ------------------ | ---------------- |\n| 有基类方法         | 具体类里具体实现 |\n| 有静态成员         | 没有静态成员     |\n| 使用构造器         | 不能使用构造器   |\n| 可以使用访问修饰符 | 强制public       |\n\n## Design patterns\n\n### Factory pattern\n\n一个用于生成其他对象的中枢对象。\n\n```c#\npublic interface IProduct\n{\n public string ProductName { get; set; }\n public void Initialize();\n}\npublic abstract class Factory : MonoBehaviour\n{\n\tpublic abstract IProduct GetProduct(Vector3 position);\n}\n```\n\n### Object pool\n\n在需要操作大量的对象时，不要不断创建和销毁，而是从提前初始化的对象池里调用。\n\n对象池的中对象的实例化在加载等**玩家无法察觉的时候**进行。\n\nUnity官方的Pool库：[UnityEngine.Pool](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.html)\n\n```c#\npublic class ObjectPool : MonoBehaviour\n{\n    [SerializeField] private int initPoolSize;\n    [SerializeField] private PooledObject objectToPool;\n    // Store the pooled objects in a collection\n    private Stack<PooledObject> stack;\n    private void Start()\n\t{\n \t\t\tSetupPool();\n\t}\n // Creates the pool (invoke when the lag is not noticeable)\n \tprivate void SetupPool()\n\t{\n \t\tstack = new Stack<PooledObject>();\n\t\tPooledObject instance = null;\n \t\tfor (int i = 0; i < initPoolSize; i++)\n \t\t{\n \t\t\tinstance = Instantiate(objectToPool);\n \t\t\tinstance.Pool = this;\n \t\t\tinstance.gameObject.SetActive(false);\n \t\t\tstack.Push(instance);\n \t\t}\n\t}\n    // returns the first active GameObject from the pool\n\tpublic PooledObject GetPooledObject()\n \t{\n \t// if the pool is not large enough, instantiate a new PooledObjects\n \t\tif (stack.Count == 0)\n \t\t{\n\t\t\tPooledObject newInstance = Instantiate(objectToPool);\n\t\t\tnewInstance.Pool = this;\n\t\t\treturn newInstance;\n\t\t}\n        // otherwise, just grab the next one from the list\n\t\tPooledObject nextInstance = stack.Pop();\n\t\tnextInstance.gameObject.SetActive(true);\n\t\treturn nextInstance;\n \t}\n\tpublic void ReturnToPool(PooledObject pooledObject)\n\t{\n\t\tstack.Push(pooledObject);\n\t\tpooledObject.gameObject.SetActive(false);\n    }\n}\n\npublic class PooledObject : MonoBehaviour\n{\n\tprivate ObjectPool pool;\n\tpublic ObjectPool Pool { get => pool; set => pool = value; }\n\tpublic void Release()\n\t{\n\t\tpool.ReturnToPool(this);\n    }\n}\n```\n\n### Singleton\n\n懒加载（在第一次使用时才实例化）\n\n```c#\nprivate static Singleton instance;\npublic static Singleton Instance\n{\n\tget\n\t{\n\t\tif (instance == null)\n\t\t{\n\t\t\tSetupInstance();\n\t\t}\n\t\treturn instance;\n\t}\n}\nprivate void Awake()\n{\n\tif (instance == null)\n\t{\n\t\tinstance = this;\n\t\tDontDestroyOnLoad(this.gameObject);\n\t}\n\telse\n\t{\n\t\tDestroy(gameObject);\n\t}\n}\nprivate static void SetupInstance()\n{\n\tinstance = FindObjectOfType<Singleton>();\n\tif (instance == null)\n\t{\n\t\tGameObject gameObj = new GameObject();\n\t\tgameObj.name = “Singleton”;\n\t\tinstance = gameObj.AddComponent<Singleton>();\n\t\tDontDestroyOnLoad(gameObj);\n\t}\n}\n```\n\n### Command\n\n通过一系列指令栈，实现可撤销操作。\n\n![](../images/1730119449054.png)\n\n### StateMachine\n\n```c#\npublic interface IState{\n    public void Enter();\n    public void Execute();\n    public void Exit();\n}\n```\n\n### Observer\n\n事件的发送者不关心接收者的行为，不同接收者之间也不关心彼此的行为。\n\n![image-20241029093246133](../images/image-20241029093246133.png)\n\n```c#\n//事件的发送者\npublic class Subject: MonoBehaviour\n{\n    public event Action ThingHappened;\n    \n    public void DoThing(){\n        ThingHappened?.Invoke();\n    }\n}\n\n//事件的接收者\npublic class Observer: MonoBehaviour\n{\n    [SerializeField] private Subject subjectToObserve;\n    private void OnEnable()\n    {\n        if(subjectToObserve !=null)\n            subjectToObserve.ThingHappened += OnThingHappened;\n    }\n    private void OnDisable()\n    {\n        if(subjectToObserve !=null)\n            subjectToObserve.ThingHappened -= OnThingHappened;\n    }\n}\n```\n\n※如果没有注销事件而删除了这个对象，在**触发事件时会导致报错**。\n\n※Unity检视器中的UI事件系统会导致运行变慢。\n\n### Model View Presenter\n\nMVC：![image-20241029100928217](../images/image-20241029100928217.png)\n\nMVP：\n\n![image-20241029101515862](../images/image-20241029101515862.png)\n\n### Model-View-ViewModel (Unity6)\n\n在MVC的基础上加了数据绑定，使UI的更新自动化。\n\n### Strategy \n\n### Flyweight\n\n## 碰撞检测\n\n### AABB\n\nAxis-aligned Bounding Box\n\n![img](https://learnopengl-cn.github.io/img/06/Breakout/05/02/collisions_overlap.png)\n\n```c++\nGLboolean CheckCollision(GameObject &one, GameObject &two) // AABB - AABB collision\n{\n    // x轴方向碰撞？\n    bool collisionX = one.Position.x + one.Size.x >= two.Position.x &&\n        two.Position.x + two.Size.x >= one.Position.x;\n    // y轴方向碰撞？\n    bool collisionY = one.Position.y + one.Size.y >= two.Position.y &&\n        two.Position.y + two.Size.y >= one.Position.y;\n    // 只有两个轴向都有碰撞时才碰撞\n    return collisionX && collisionY;\n}  \n```\n\n### 球形\n\n![img](https://learnopengl-cn.github.io/img/06/Breakout/05/02/collisions_aabb_circle.png)\n\n```c++\nGLboolean CheckCollision(BallObject &one, GameObject &two) // AABB - Circle collision\n{u\n    // 获取圆的中心 \n    glm::vec2 center(one.Position + one.Radius);\n    // 计算AABB的信息（中心、半边长）\n    glm::vec2 aabb_half_extents(two.Size.x / 2, two.Size.y / 2);\n    glm::vec2 aabb_center(\n        two.Position.x + aabb_half_extents.x, \n        two.Position.y + aabb_half_extents.y\n    );\n    // 获取两个中心的差矢量\n    glm::vec2 difference = center - aabb_center;\n    glm::vec2 clamped = glm::clamp(difference, -aabb_half_extents, aabb_half_extents);\n    // AABB_center加上clamped这样就得到了碰撞箱上距离圆最近的点closest\n    glm::vec2 closest = aabb_center + clamped;\n    // 获得圆心center和最近点closest的矢量并判断是否 length <= radius\n    difference = closest - center;\n    return glm::length(difference) < one.Radius;\n}      \n```\n\n### 三角形<->球\n\n①计算球心到三角形的距离\n\n②如果球心的投影在三角形内，则距离为**到三角形平面的距离**\n\n③如果在外部，则距离为**到其中一条边的距离**\n\n```c++\n\n```\n\n* 计算球心投影是否在三角形内\n\n```c++\n// v21.cross(normal)得到垂直于[边21]的向三角形内的向量\nfloat d1 = dot(v21.cross(normal), p1);\nfloat d2 = dot(v32.cross(normal), p2);\nfloat d3 = dot(v13.cross(normal), p3);\n// 有一个为负，说明点不在三角形内\nbool outside = (d1 < 0.0f || d2 < 0.0f || d3 < 0.0f);\n```\n\n* 计算到三角形平面的距离\n\n```c++\nd = dot(p-v1, normal) / length(normal);\n```\n\n* 计算到每条边的距离\n\n```c++\n// 拆解\n// 点在线段上的投影比例t： v21.dot(p1) / dot2(v21)\n// 约束到[0,1]： std::clamp(t, 0, 1)\n// 得到线段上的最近点Q： v21 * std::clamp(t, 0, 1)\n// 计算向量PQ长度\nfloat d1 = dot2(v21 * std::clamp(v21.dot(p1) / dot2(v21), 0.0f, 1.0f) - p1);\nfloat d2 = dot2(v32 * std::clamp(v32.dot(p2) / dot2(v32), 0.0f, 1.0f) - p2);\nfloat d3 = dot2(v13 * std::clamp(v13.dot(p3) / dot2(v13), 0.0f, 1.0f) - p3);\nreturn std::sqrt(std::min({ d1, d2, d3 }));\n```\n\n```c++\nfloat calDistance(Point p, Point v1, Point v2, Point v3) {\n\tPoint v21 = v2 - v1;\n\tPoint v13 = v1 - v3;\n\tPoint v32 = v3 - v2;\n\tPoint p1 = p - v1;\n\tPoint p2 = p - v2;\n\tPoint p3 = p - v3;\n\tPoint normal = v21.cross(v13);\n\n\tfloat d1 = dot(v21.cross(normal), p1);\n\tfloat d2 = dot(v32.cross(normal), p2);\n\tfloat d3 = dot(v13.cross(normal), p3);\n\tbool outside = (d1 < 0.0f || d2 < 0.0f || d3 < 0.0f);\n\n\tif (outside) {\n\t\tfloat d1 = dot(v21 * std::clamp(v21.dot(p1) / dot(v21), 0.0f, 1.0f) - p1);\n\t\tfloat d2 = dot(v32 * std::clamp(v32.dot(p2) / dot(v32), 0.0f, 1.0f) - p2);\n\t\tfloat d3 = dot(v13 * std::clamp(v13.dot(p3) / dot(v13), 0.0f, 1.0f) - p3);\n\t\treturn std::sqrt(std::min({ d1, d2, d3 }));\n\t}\n\telse {\n\t\tfloat d = normal.dot(p1);\n\t\treturn std::sqrt(d * d / dot(normal));\n\t}\n}\n```\n\n完整代码：\n\n```c++\nfloat calDistance(Point p, Point v1, Point v2, Point v3) {\n\tPoint v21 = v2 - v1;\n\tPoint v13 = v1 - v3;\n\tPoint v32 = v3 - v2;\n\tPoint p1 = p - v1;\n\tPoint p2 = p - v2;\n\tPoint p3 = p - v3;\n\tPoint normal = v21.cross(v13);\n\n\tfloat d1 = dot(v21.cross(normal), p1);\n\tfloat d2 = dot(v32.cross(normal), p2);\n\tfloat d3 = dot(v13.cross(normal), p3);\n\tbool outside = (d1 < 0.0f || d2 < 0.0f || d3 < 0.0f);\n\n\tif (outside) {\n\t\tfloat d1 = dot(v21 * std::clamp(v21.dot(p1) / dot(v21), 0.0f, 1.0f) - p1);\n\t\tfloat d2 = dot(v32 * std::clamp(v32.dot(p2) / dot(v32), 0.0f, 1.0f) - p2);\n\t\tfloat d3 = dot(v13 * std::clamp(v13.dot(p3) / dot(v13), 0.0f, 1.0f) - p3);\n\t\treturn std::sqrt(std::min({ d1, d2, d3 }));\n\t}\n\telse {\n\t\tfloat d = normal.dot(p1);\n\t\treturn std::sqrt(d * d / dot(normal));\n\t}\n}\n```\n\n## 游戏机制实现\n\n\n\n","tags":["游戏"],"categories":["游戏制作"]},{"title":"MASM X86 汇编笔记","url":"/2023/11/28/MASMx86汇编笔记/","content":"汇编课的笔记\n<!--more-->\n## 关于DOS INT 21H/AH=0ah\n\n该功能为键盘输入缓冲区\n\n使用：\n\n```assembly\ndata segment\n\tbuffer db 20 DUP('$')\nends data\n\ncode segment\n\tmov ax, data \n\tmov ds, ax\t\t\t;初始化数据段 \n\t\n\tmov ah,0ah\n\tmov dx,offset buffer\n\tint 21h\t\t\t\t;输入缓冲区\n\t\n\tmov      ah,9\n    lea      dx,buffer+2\n    int      21h\t\t;输出缓冲区\nends\n```\n\n注意点：\n\n下图7100h~7113h为buffer的20个空间\n\n当输入“helloworld”时，可以看到输入为7101h~710ch\n\n总结：\n\n* 真正用户输入的内容从dx+2开始，\n\n* 输入的结尾为CRET（回车符）\n* 缓冲区的前两个字符为$和随机值\n* 由于输出(AH=9)要靠‘$’判断字符串结束，因此设置缓冲区大小应不小于**N+4**（N为你需要输入的字符数）\n\n![image-20231128205600204](E:\\BlogData\\source\\images\\image-20231128205600204.png)\n\n## 宏定义（函数定义）\n\n使用`macro`关键字\n\n※在macro中使用跳转时，需声明`local label1，label2`\n\n```assembly\n;输出换行符的宏指令\nnextline macro [param1,param2,param3...]\n          mov ah,9\n          lea dx,cret\n          int 21h\nnextline endm\n;调用：\n...\nnextline\n...\n\n;数字转换成ASCII码并输出：\nnum_to_asc macro num \n\t;local label1，label2\n    mov al,num\n    mov ah,0h\n    aam\n    mov bx,ax\n    add bl,30h\n    add bh,30h         \n    mov ah,02h  \n    mov dl,bh\n    int 21h   \n    mov dl,bl\n    int 21h\nnum_to_asc endm  \n```\n\n## LOOP \n\n格式：`LOOP loop标号`\n\n执行loop指令时会有隐式的两步操作：\n\n\t* (cx)=(cx)-1\n\t* 判断(cx)的值为ZERO则停止循环\n\n## 移位指令\n\n* 逻辑移位(无符号)：补0\n  * `SHL`,`SHR`\n* 算术移位：最高位不变\n  * `SAL`,`SAR`","tags":["编程"],"categories":["程序设计"]},{"title":"Javascript与前端算法","url":"/2023/09/08/my-javascript-note/","content":"\n# Javascript\n\n## ES6\n\n### Map\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n\n也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“**值—值**”的对应，是一种更完善的 Hash 结构实现。\n\n<!--more-->\n\n* 实例化\n\n```javascript\n//空map\nconst map = new Map();\n//初始化map，通过数组表示键值对\nconst map = new Map([\n   ['name','Jack'],\n   ['age',16]\n]);\n```\n\n* 方法\n\n```javascript\nmap.size //2\nmap.has('name'); //true\nmap.get('name'); //'Jack'\nmap.set('key','value'); //返回对象本身，可链式调用\nmap.delete(key); //删除成功返回true\nmap.clear(); //清除所有成员，无返回值\n\n<!--遍历:-->\nmap.keys(); //返回键名的遍历器\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nmap.values(); //返回键值的遍历器\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nmap.entries(); //返回所有成员的遍历器\nfor (let [key,value] of map.entries()) {\n  console.log(key, value);\n}\n\n//forEach\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n\n<!--与数组结合:-->\n[...map.keys()];\n[...map.values()];\n[...map];\n[...map.entries()];\n\n//使用数组filter创建新map\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n```\n\n※注意点\n\n```javascript\n//只有对同一个对象的引用，Map结构才将其视为同一个键\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n//同样的值的两个实例，在 Map 结构中被视为两个键\nconst k1 = ['a'];\nconst k2 = ['a'];\nmap.set(k1,1);//两者不同\nmap.set(k2,2);//两者不同\n\n//undefined和null是两个键\n//NaN为同一个键\n//0，-0为同一个键\n```\n\n### Class\n\n```javascript\n//1.基本类语法\nclass Person {\n  constructor( name , age ) {\n    this.name = name;\n    this.age = age;\n  }\n    \n  say() {\n    return '我叫'+this.name+',今年'+this.age+'岁';\n  }\n    \n  static walk(){\n      console.log('我会走路');\n  }\n}\n\nvar p = new Person('小明',18);\np.say(); //成员方法\nPerson.walk(); //静态方法\n\n//2.原型继承\nclass Child extends Parent{\n\tconstructor(name,age,gender){\n        //通过super可以调用父类构造器或方法\n        super(name,age);\n        this.gender=gender;\n        //super作为对象时，指向父类的原型对象\n        console.log(super.func());\n    }\n    //ES6中规定，子类的构造函数必须执行一次super函数。\n}\n\n//3.getter,setter\nclass Person {\n  constructor() {}\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n//使用get和set关键字可设置存值函数和取值函数\n//拦截该属性的存取行为\nlet p = new Person();\np.prop = 666; //setter: 666\n```\n\n虽然引入了关键字，但ES6中并没有真的引入类这个概念，通过class定义的仍然是函数。class仅仅是通过更简单直观的语法去实现原型链继承。这种对语言功能没有影响、但是给程序员带来方便的新语法，被称为**语法糖**。\n\n在 constructor 里面，super 的用法是 super()。它相当于一个函数，调用它等于调用父类的 constructor 。\n\n但在普通方法里面，super 的用法是 super.prop 或者 super.method()，它相当于一个指向对象的 [[Prototype]] 的属性。\n\n## 前端算法\n\n### 链表\n\n#### 双指针\n\n判断链表有无成环\n\n```javascript\nlet slow = head;\nlet fast = head;\nwhile(fast && fast.next){\n\tfast = fast.next.next;\n\tslow = slow.next;\n    //快慢指针相遇说明链表成环\n\tif(slow===fast) return true;\n}\n```\n\n#### LRUcache\n\nleast recently use cache\n\nVue的`<keep-alive>`组件使用了**LRUcache（最少最近使用缓存）**。\n\n```javascript\nclass LRUCache {\n    constructor(capacity){\n\t\tthis.cache = new Map();\n    \tthis.maxSize = capacity; \n    }\n    \n    get(key){\n        //若key对应的value存在，在返回之前将其排在队尾\n        if(this.cache.has(key)){\n            let tmp = this.cache.get(key);\n            this.cache.delete(key);\n            this.cache.set(key,tmp);\n            return tmp;\n        }\n        return -1;\n    }\n    \n    put(key,value){\n        if(this.cache.has(key)){\n            this.cache.delete(key);\n        }else if(this.cache.size>=this.maxSize){\n            //如果新增元素将超过缓存容量，淘汰队首元素\n            this.cache.delete(this.cache.keys().next().value);\n        }\n        this.cache.set(key,value);\n    }\n}\n```\n\n### 位运算\n\n#### 组合权限认证\n\n* 标记：通过二进制位标记某个属性\n* 授权：**或运算**授予一个变量多个属性\n* 校验：**与运算**判断有无该属性\n* 删除：**异或运算**删除一个属性\n\nvue中判断虚拟DOM类型\n\n```javascript\nexport const enum ShapeFlags{\n\tELEMENT = 1,\n    FUNCTIONAL_COMPONENT = 1 << 1,\n    STATEFUL_COMPONENT = 1 << 2,\n    ...\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n}\n```\n\n判断一个数是否为2的整数次幂\n\n```javascript\nn>0 \n&&\nn & (n-1) === 0 \n```\n\n异或去重\n\n```javascript\na^a^b^b^c //c\n```\n\n### 树结构\n\n递归翻转\n\n```javascript\ninvertTree=(root)=>{\n\tif(root==null){\n\t\treturn root;\n\t}\n\t[root.left,root.right]=[invertTree(root.right),invertTree(root.left)];\n    return root;\n}\n```\n\n### 栈\n\n判断html标签是否闭合，简化路径\n\n```javascript\nlet stack=[];\nlet paths=path.split('/');\nfor (let i=0;i<paths.length;i++){\n    const p = paths[i];\n    if(p=='..'){\n        spack.pop();\n    }else if(p && p!=='.'){\n     \tstack.push(p);\n}\nreturn '/'+stack.join('/');\n```\n\n### 排序\n\n#### 快速排序\n\n 每次将数组二分为`比x小的数组`和`比x大的数组`，递归至数组大小为1\n\nO(n*logn）\n\n### leftPad\n\n二分优化\n\n```javascript\nfunction leftpad(str,length,ch){\n    let len = length - str.length ;\n    total = '';\n    while(true){\n        if(len & 1){ //相当于len%2==1\n            total+=ch;\n        }\n        if(len==1){\n            return total+str\n        }\n        ch+=ch;\n        len=len>>1;\n    }\n}\n```\n","tags":["编程"],"categories":["程序设计","前端"]},{"title":"基本乐理与声音设计","url":"/2023/07/19/my-music-note/","content":"音乐学习相关的笔记\n<!--more-->\n# 基本乐理\n\n### 泛音(倍音，倍频)\n![image-20230901164632960](../images/image-20230901164632960.png)\n\n整数次谐波=>基音，倍音\n![image-20230901164700405](../images/image-20230901164700405.png)\n\n和弦和单音在物理学意义上没有区别\n![image-20230901164715003](../images/image-20230901164715003.png)\n\n## 音乐基础\n\n### 三要素\n* 节奏\n* 旋律\n* 和声\n\n### 音程-interval\n\n| **度数名**        | **英語** | **例（ドの場合※）** | **半音数** | **テンションとして見た場合** |\n| ----------------- | -------- | ------------------- | ---------- | ---------------------------- |\n| **完全1度**       | P1/d2    | ド（同じ音）        | 0          |                              |\n| 増1度/短2度       | m2/A1    | ド♯/レ♭             | 1          | ♭9th                         |\n| 長2度/減3度       | M2/d3    | レ/ミ♭♭             | 2          | 9th                          |\n| 増2度/短3度       | m3/A2    | レ#/ミ♭             | 3          | ♯9th                         |\n| 長3度/減4度       | M3/d4    | ミ/ファ♭            | 4          |                              |\n| **完全4度**/増3度 | P4/A3    | ファ/ミ♯            | 5          | 11th                         |\n| 増4度/減5度       | A5/d5    | ファ♯/ソ♭           | 6          | ♯11th                        |\n| **完全5度**       | P5       | ソ                  | 7          |                              |\n| 増5度/短6度       | A5/m6    | ソ♯/ラ♭             | 8          | ♭13th                        |\n| 長6度/減7度       | M6/d7    | ラ/シ♭♭             | 9          | 13th                         |\n| 短7度             | m7       | ラ♯/シ♭             | 10         |                              |\n| 長7度             | M7       | シ                  | 11         |                              |\n| **完全8度**       | P8       | ド（オクターブ上）  | 12         |                              |\n\n- **P**…パーフェクト（完全）\n- **M**…メジャー（長）\n- **m**…マイナー（短）\n- **A**…オーグメンテッド（増）\n- **d**…ディミニッシュト（減）\n\n异名同音(×为##)：\n![image-20230901164732238](../images/image-20230901164732238.png)\n\n### 大小调\n\n与大调有关的三个小调：（只按自然小调标升降号）\n\n* 自然小调：组成音完全相同（C大调/A小调）\n* 和声小调：自然小调升第七个音\n* 旋律小调：下行自然小调，上行自然小调升六七音\n\n12大调，48大小调\n\n### 冠音\n\n最高音，大部分情况下是旋律音\n\n![image-20230829115933572](../images/image-20230829115933572.png)\n\n![image-20230901164746538](../images/image-20230901164746538.png)\n\n### 五度圈\n\n![PNG](../images/co5th.png)\n\n查看基调和弦：以A大调为例，由框内的六个音组成\n    ![1694867599892](../images/1694867599892.png)\n\n## 和弦\n\n五音经常可以被省略，通常不影响和弦判断\n\n三音和七音不能省\n\n### 钢琴指法\n* m：三音左移半音\n* ♯：全部右移半音\n* ♭：全部左移半音\n* dim：三音，五音左移半音\n* sus4：三音右移半音（挂4和弦）\n* aug：五音右移半音\n* -5/b5：五音左移半音（flat five）\n* 6：七音在五音的右侧两个半音位置\n* 7：七音在五音的右侧3个半音位置\n* 9：短七音+九音\n* M7（Δ7）：七音在五音的右侧4个半音位置\n* add9：七音在根音的右侧两个半音位\n\n### cadence/终止\n\n* Authentic/正格终止（Ⅴ→Ⅰ）\n  * perfect authentic（根音=和弦最低音&和弦最高声部为Tonic）\n  * imperfect authentic\n* half/半终止（→Ⅴ）\n* plagal/变格终止（Ⅳ→Ⅰ）\n* deceptive/伪终止（Ⅴ→Ⅵm）\n\n### 和声机能\n\n![1694871651941](../images/1694871651941.png)\n\n![1694872296729](../images/1694872296729.png)\n\nⅢm在有些时候会有**T**的作用\n\n![image-20230917084451373](../images/image-20230917084451373.png)\n\n### 和声韵律(Harmonic rhythm)\n\n\n\n### 常见和声\n\n\n* 丸之内/just the two of us\n\n$$\nⅣM7-Ⅲ7-Ⅵm7-Ⅰ7\n$$\n\n## 人声的范围\n\n![image-20230903194409225](../images/image-20230903194409225.png)\n\n## 转调\n\n![image-20230903194746090](../images/image-20230903194746090.png)\n\n## 旋律\n\n### 五音音阶 Pentatonic\n\n\n### 注意点 \n  ![image-20230903200858730](../images/image-20230903200858730.png)\n\n### 和弦外音\n\n* 经过音：两个和弦音之间的音\n* 相邻音：两个相同的音之间差一个以上相邻的音\n* 先现音：提前出现下一个和弦的音\n* 跳脱音\n* 倚音\n* 悬挂音suspension/retardation\n\n### 付点/切分\n\n## 节奏\n\n### 鼓的构成\n\n* Kick\n* Hi-Hat：通常是将节奏分的最细的部分，根据Hi-hat的节奏，将节奏类型分为8beat，16beat等\n* Snare\n\nghost note\n\n![1694958953650](../images/1694958953650.png)\n\n### Syncopation\n\n![image-20230917220432748](../images/image-20230917220432748.png)\n\n### Anticipation\n\n![image-20230917221947515](../images/image-20230917221947515.png)\n\n# 设计声音\n\n## 物理学系统\n\n* 自由度：物体能够运动的方向的数量（三个平移自由度，三个转动自由度）在声音模型中通常假设仅有一个自由度\n\n* 激励者：把能量带给系统的物体\n\n* 受激：产生振动的物体\n\n  在声音的产生过程中，激励者和受激缺一不可\n\n\n### 材料\n\n* 质量\n* 弹性/塑性\n* 硬度\n* 密度\n* 结构与强度\n\n材料对声音的影响主要体现在质量和弹性两个方面。不同状态(固液气)的物体对声音的传导能力不同\n\n体积模量K（E：杨氏模量；v：泊松比）：\n$$\nK=\\frac{E}{3(1-2v)}\n$$\n\n### 波\n\n* 横波/纵波/扭转波\n\n* 速度（质点速度，相速度，群速度）\n\n* 幅度\n\n**声速**（相速度phase velocity）c近似公式（K：杨氏模量；ρ：密度）：\n$$\nc=\\sqrt{\\frac{K}{ρ}}\n$$\n\n$$\nc=fλ\n$$\n\n**群速度**：取决于介质属性的常量，通常与相速度相等。当相速度和群速度不完全相等时，该介质弥散（dispersive），如水波冲刷海岸的现象。\n\n### 界面\n\n当界面的两种物质相差极大时，声音中有很大一部分会被反射，很小一部分会传导。对于水和空气，这个比率约为99%。\n\n入射角会影响反射波的强度，在布鲁斯特角，反射波会消失。\n\n**固体界面处的弯曲波相位**：对于坚硬界面的材料，波会反相反射；对于弹性界面的材料，波会同相反射。\n\n反射波与入射波具有相同的波长和波速，但幅度较小。\n\n被传导的波在新的介质中有新的波长，频率不变。\n\n**驻波**：持续不断的行波与反射波叠加干涉，形成驻波（在吉他中，第一个是基音，后面的是泛音）\n\n![image-20230901105905563](../images/image-20230901105905563.png)\n\n\n\n### 模拟（analogue）\n\n借由其他类似系统进行推理，达到连续测量的目的。在声音设计中主要考虑“电，力，声”三种系统。\n\n* 流动：\n\n  * 电学：电流\n  * 力学：速度\n  * 声学：体积流动\n\n    ![image-20230901115743564](../images/image-20230901115743564.png)\n\n* 质量：\n\n  * 电学：电感\n\n  * 力学：质量\n\n  * 声学：声质量 *inertance*\n    > （流动介质的质量除以波阵面的横截面积）\n\n* 阻抗：\n\n  * 电学：电阻\n\n  * 力学：摩擦\n\n  * 声学：粘滞力，介质的耗散属性\n\n    > （波阵面上的声波压强除以体积速度）\n\n    ![image-20230901115909642](../images/image-20230901115909642.png)\n\n* 容抗\n\n    * 电学：电容\n    * 力学：柔度，硬度的倒数\n    * 声学：声容，与所施压强的变化相抗的量\n    ![image-20230901115803986](../images/image-20230901115803986.png)\n\n**将被敲打的弦的类比系统**：\n\n![image-20230901120723041](../images/image-20230901120723041.png)\n\n**对钟和小提琴的entity-action解构**：\n\n![image-20230901120828572](../images/image-20230901120828572.png)\n\n### 振动\n\n周期波听起来像有固定的音高，而非周期波听起来很复杂或类似噪声。\n\n* 弛豫振荡relaxation oscillator\n\n* 简谐振荡\n\n弦的固有频率：(L:长度；T:张力；mu:单位长度质量)\n$$\nf=\\frac{1}{2L}\\sqrt{\\frac{T}{m_u}}\n$$\n简单几何形状的物体大致可以分为两类：能够自由振动的物体，和在张力下的物体。琴弦，鼓皮会以与它们所受张力有关的频率振动。\n\n#### 受激振荡与谐振\n\n共振系统在不同阻尼下的响应：\n\n![image-20230901145420644](../images/image-20230901145420644.png)\n\n将驱动振荡器看作是对能量流动的阻抗，随着驱动频率远离固有频率，能量的转移越来越小。\n\n受激系统的行为就像是**滤波器(filter)**。当系统阻尼较小时，系统具有**高谐振，窄带宽**的特性，而受到强烈阻尼的系统具有**低谐振，宽带宽**的特性。\n\n\n\n## 声学系统\n\n在声学中我们仅考虑**纵波**，总体积的行为。\n\n空气中的声速方程：\n$$\nc=\\sqrt{\\frac{γp}{ρ}}=\\sqrt{\\frac{γRT}{M}}\n$$\nR：摩尔气体常数，T：绝对温度，M：摩尔质量\n\n### 声压级&声强级\n\n声压p是单位面积上的一个力，波的峰值声压反比于距离，所以若与声源相距为r，则峰值按1/r减少。\n\n声压级（Sound pressure level）是一个以分贝为单位的比率，设20μN/m^2^作为声学上最小可测量值，则：\n$$\nSPL=20log_{10}\\frac{p(N/m^2)}{2*10^{-5}}\n$$\n※声波的声压级不会超过194dB，这个值意味着疏部压强为真空压强。（在爆炸和闪电中存在压强大于194dB的单极性脉冲）\n\n------\n\n声音强度I是单位面积上的功率，用W(瓦特)/m^2表示，它正比于声压级的平方。\n\n对于谐波平面波：（ρ：密度，c：相速度）\n$$\nI=±\\frac{p^2}{2ρc}\n$$\n声强级(sound intensity level)是以分贝为单位的比率，以10^-12^W/m^2^作为参考值：\n$$\nSIL=10log_{10}{\\frac{I}{10^{-12}}}\n$$\n\n### 位置与相干性\n\n当观察者听到来自不同声源（或是反射波）的**相关**声音时，声音可能被加强或减小。当声源移动，则声音不断地加强或对消，观察者会听到一个扫频的陷波滤波效果。\n\n![image-20230901153530820](../images/image-20230901153530820.png)\n\n如果各个声源相似但由单独的机制产生（如合唱，一团蜜蜂）那么声源之间不具有**相关性**。\n\n对于大量的声源集合，相关与否会导致观察到的平均幅度上的显著差异：\n$$\nA_{相关}=A_a+A_b+A_c\\cdots\\\\\nA_{不相关}=\\sqrt{{A_a^2+A_b^2+A_c^2\\cdots}}\n$$\n\n### 衰减\n\n#### 距离导致的几何损耗\n\n![image-20230901160653650](../images/image-20230901160653650.png)\n\n对于圆柱模型（琴弦，或是繁忙的公路），辐射功率的耗散正比于距离。\n\n对于球模型，功率耗散正比于距离的平方。\n\n#### 吸收导致的能量损耗\n\n声音频率越高，速度越快，吸收损耗越大（斯托克斯定律）\n\n衰减α：(η：粘滞度)\n$$\nα=\\frac{2η2\\pi\\\\f^2}{3ρc^3}(Np/m)\\\\ *8.685889\\rightarrow(dB/m)\n$$\n\n### 传播效应\nP58补\n* 反射\n\n纵向的声波在反射时会保持相同的(压强)相位，我们将听到由直达波和反射波相互叠加所引起的效果，类似的驻波模式图样将出现在房间等声学空间中。\n![image-20230904131043414](../images/image-20230904131043414.png)\n\n* 散射\n\n* 弥散\n* 折射\n* 衍射\n\n### 声学振荡\n\n## 心理声学\n\n\n\n人类听觉的频率范围：20~20kHz\n\n自然声音（语音和音乐）的大部分频率都在300~3kHz之间。\n\n### 定位\n\n三大规律：\n\n* 高频声音比低频声音更容易定位，且声音刚开始的时候比延音更容易定位。\n* 在户外或自由空间中对声音的定位能力好于在具有大量反射的小房间中的定位能力。\n* 倾斜头部能获得更好的仰角感知，更容易定位\n\n#### 耳间强度差IID\n\n抵达每只耳朵的相对幅度（即立体声系统中的**声像定位-panning**）\n\n在频率高于700Hz开始有效，1.5kHz以上时完全工作。\n\n#### 耳间时间差ITD\n\n声音抵达两只耳朵的时间差值。当多于一个完整波长放到两耳之间（15~25cm），就会引起含糊不清。\n\n因此耳间时间差对700Hz以下的声音最有效，在1.5kHz以上时无效。\n\n(r:头部半径；θ：与鼻子方向中线的夹角)\n$$\nITD=r\\frac{(θ+sinθ)}{c}\n$$\n\n### 响度\n\n声音的响度是一个主观数值，单位为sone。\n\n1sone=1kHz的正弦波在40dB SPL的响度。声压级增大10dB SPL，感受到的响度用sone表示会变为原来的2倍。\n\n对于人耳，同声压级的一些频率比另一些频率听上去会更响，因此人们测量得到了等响度曲线，并定义\n\n1phon=1dB SPL的1kHz纯音\n\n![image-20230904140147498](../images/image-20230904140147498.png)\n\n声级表运用“计权滤波器”来补偿频率的相关性，其中A计权标度多用于环境噪声测量，BBC给出的ITU-R468标度用于广播和母带的处理。\n\n#### 时域积分效应\n\n对于200ms以内的持续时间，通过将声音拉长一些毫秒，就可以使它们具有更大的表观音量。\n\n### 音域\n\n* **低音bass**\n  * **次低音sub**：多用于给雷声等音响效果增加深度\n  * **上低音upper bass**：底鼓，贝斯基频，钢琴与吉他较低的八度\n* **中音mid**：人声，弦乐，铜管的最佳音区\n* **高音treble**\n  * **临场感presence**：为人声和乐器增加清晰度\n  * **上方top**：镲片，类噪声音\n  * **空气感air**：所有最高泛音\n\n![image-20230906090620166](../images/image-20230906090620166.png)\n\n### 分辨率\n\n人耳可以区分100Hz和105Hz的区别，但无法区分16000Hz和16005Hz的区别。\n\n### 频谱\n\n**音色timbre**是对频谱的主观感知量，是由一个稳定频谱产生的瞬时的听觉感受。\n\n#### 明亮度\n\n将具有一些较响的高频并不足以让一个声音明亮，声音的明亮度取决于**频谱质心**，以及**起音attack**。\n\n#### 对时域结构的感知\n\n### 包络envelope\n\n在声音设计中通常用四个词描述一个声音的包络：\n\n* 起音attack\n* 衰减decay\n* 延音sustain\n* 释音release\n\n#### Attack\n\n在这个阶段，声音从0开始上升到最大能量处。对于打击型声音，这个起音非常短；对于琴弦，可以长达几秒钟。\n\n从斜面滑落空气的物体可以模拟起音的过程，该物体持续加速，同时摩擦激励产生一个越来越响的声音。\n\n#### Decay\n\n衰减应用于那些在瞬变阶段后有能量持续供应的系统上。\n\n#### Sustain\n\n在这个阶段，系统的输入能量等于输出能量。\n\n#### Release\n\n系统不再接受能量，只通过存储的能量产生一段声音。对于运动物体，这个数值对应于动量，对于流体则对应于存储能力。\n\n### 哈斯效应\n\n又称先入为主效应，决定了我们在何处区分环境与声源。\n\n大约30ms后接受到的反射声将被分配给环境，被听成单独的回声，比如在大厅里击掌产生的回声；发生在30ms内的反射声被融合到这个声音本身中，比如古典吉他的空腔内产生的回声\n\n### Gabor极限\n\nGabor极限标出了一个声音具有音高所需的最小持续时间，大约在10~20ms。\n\n# 吉他\n\n\n\n# 合成器\n\n## 放大器Amplifier\n\n## 振荡器Oscillator\n\n### 音频振荡器\n用于产生音频，不同波形会产生不同音色timbre的声音，振幅影响响度\n### 低频振荡器（LFO）\n用于调制某个音频，让一个参数（音高，音量等）来回振荡，使音频的某些特性随时间变化。\n慢速的调制通常用作改变行为（声音的表现），而快速调制则用来改变音色（声音本身的特征）\n\n## 滤波器Filter\n* Low-Pass Filter低通滤波器\n\n  ![image-20230912205725143](../images/image-20230912205725143.png)\n  \n  * Resonance：共振，增强截止频率周围的振幅\n  * Frequency：滤波器的截止频率\n\n## 合成弹拨贝斯\n<div style='display:flex;width:100%;'>\n<img style='width:50%;' src='../images/image-20230912210218103.png' />\n<img style='width:50%;' src='../images/image-20230912210242942.png' />\n</div>\n\n声音的”弹拨”性是由包络调制滤波器而生成的。 这会导致滤波器快速开合和关闭。\n\n### 音高失谐detune\n\n* cents音分：一音分等于半音的百分之一\n\n* semitone半音\n\n  12semitone=1个八度\n\n## 噪声发生器\n\n噪声发生器会生成没有音高的声音，可以用来模拟风或雨的声音。","tags":["音乐"],"categories":["音乐"]},{"title":"安装与配置MySQL(Ubuntu)","url":"/2023/06/26/MySQL_commands/","content":"## 安装mysql\n\n```shell\nsudo apt update\nsudo apt install mysql-server\t\n```\n<!--more-->\n\n## 查看mysql是否安装成功\n\n```shell\nmysql --version\n```\n\n## 设置root用户的密码\n\n```shell\nsudo mysql #登录mysql服务器\n```\n\n```sql\nsql指令:\n/*将new_password部分替换为你的新密码*/\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new_password';\n/*更新用户权限*/\nFLUSH PRIVILEGES; \n/*退出sql命令行*/\nexit\n```\n\n## 查看mysql服务器运行状态\n\n```shell\nsudo service mysql status\n```\n\n如果MySQL正在运行，将显示\"active (running)\"\n\n## 启动mysql服务器\n\n```shell\nsudo service mysql start\n```\n\n## 本地连接mysql服务器\n\n```shell\nmysql -u <username> -p\n```\n\n将`<username>`替换为用户名(未创建新用户则填root)\n\n## 查看MySQL服务器的ip地址\n\n通常主机外网ip即为服务器ip地址\n\n```shell\nifconfig #linux\n```\n\n## 配置MySQL服务器远程连接\n\n### 编辑配置文件'mysqld.cnf'\n\n```shell\nsudo nano /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在 `mysqld.cnf` 文件中找到 `bind-address` 选项，并将其注释掉或将其值设置为MySQL服务器的IP地址。默认情况下，此选项被设置为 `127.0.0.1`，只允许本地连接。如果要允许远程连接，请将其修改为服务器的实际IP地址或注释掉该行。例如：\n\n```\n#bind-address = 127.0.0.1\n```\n\n保存并关闭`mysqld.cnf`文件（ctrl+x）\n\n### 重启MySQL服务器以应用更改\n\n```shell\nsudo systemctl restart mysql\n```\n\n### 创建或授予远程访问权限\n\n```shell\nsudo mysql\n#或\nmysql -u root -p\n```\n进入sql命令行\n```sql\n/*显示MySQL服务器上所有用户列表*/\nSELECT user, host FROM mysql.user;\n```\n如果有用户拥有`%`主机的访问权限，则该用户可以进行远程访问。如果没有，则授予权限\n\n```sql\n/*替换<password>（包括大小于号）*/\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '<password>' WITH GRANT OPTION;\n\n/*刷新用户权限*/\nFLUSH PRIVILEGES;\n\nexit\n```\n\n或创建新用户：\n\n```sql\n/*替换<username>和<password>（包括大小于号）*/\nCREATE USER '<username>'@'%' IDENTIFIED BY '<password>';\n\n/*授予新用户对所有数据库的完全权限*/\nGRANT ALL PRIVILEGES ON *.* TO '<username>'@'%' WITH GRANT OPTION;\n\n/*刷新用户权限*/\nFLUSH PRIVILEGES;\n\nexit\n```\n\n## 查看MySQL服务器端口\n\n默认为3306，若进行了自定义设置可在**sql命令行**使用以下指令\n\n```sql\nSHOW VARIABLES LIKE 'port';\n```\n\n## 关闭Ubuntu防火墙\n\n```shell\n#关闭防火墙\nsudo ufw disable\n#查看防火墙状态，若显示'Status:inactive'则关闭成功\nsudo ufw status\n```\n\n# MySQL语言\n\n"},{"title":"《献给阿尔吉侬的花束》","url":"/2023/02/25/read-Flowers-for-Algernon/","content":"\n## 引言\n\n>箱子里有迷宫。\n>\n>你在错综复杂的道路上前行。\n>\n>你相信墙的另一侧一定有些什么，\n>\n>时而失道却坚定地向着出口前进。\n>\n>这身影对我有些耀眼。(阿尔吉侬)就是这样的一首曲子。\n>\n><p style=\"text-align:right\">——n-buna</p>\n\n<!--more-->\n\n前段时间听夜鹿新曲[アルジャーノン(阿尔吉侬)](https://music.163.com/#/song?id=2020247157)得知其原型是科幻巨著《献给阿尔吉侬的花束》。\n\n小说从主人公 查理·高登 的自述开始。通过没有逗号、错别字满篇的报告得知，他是一名30多岁的智力障碍者，在面包店做些清扫工作，同时在低能成人学校努力学习。他想变聪明，想让面包店的同事高兴，想理解他的朋友们所谈论的话题，并参与其中。\n\n后来，他被带到声称能改造智力的科学实验室中，在那里遇到了高智商老鼠 阿尔吉侬。阿尔吉侬是唯一一个实验成功的老鼠，它快速走出迷宫的样子令查理感到无比的惊讶和敬佩。\n\n科学家和医生看到查理天性善良，又有上进心，认为他是人体实验的不二之选。查理接受了手术，变成了天才。然而，等待他的不是为他自豪的朋友，而是他不曾体会的复杂世界。\n\n<font color='scarlet'>**※以下涉及剧透**</font>\n\n[^n-buna]: n-buna（ナブナ）音乐组合ヨルシカ（[Yorushika/夜鹿](https://baike.baidu.com/item/Yorushika/61892682?fromModule=lemma_inlink)）成员，负责作词、作曲、编曲。\n\n## 人物关系图\n\n![flowersForAlgernon](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/flowersForAlgernon.png)\n\n## “比拥有高智商更重要的事”\n在智力的飞速发展下，查理很快便掌握多门语言，读通最前沿的科学论文。一开始，他以为这就是正常人的世界，但此时的查理和其他人之间的隔阂却和手术前一样大。查理不能忍受尼姆等人追求名利，他在公开场合说的话虽然理性而正确，但让这些科学家们难堪。\n\n高智商让他察觉人性中的丑恶，但却没有给他宽容这些丑恶的人情。\n\n>但我可以告诉你一件事，在你手术之前，你并不是这个样子。你不会在自己的秽物中打滚，不会沉迷于自怜，不会整天整夜坐在电视机前污染自己的心灵，更不会大声对别人咆哮。你有些令我们尊敬的特质……没错，即使是过去的你。你身上有些我从来没有在其他弱智者身上见过的特别东西。\n>\n><p style=\"text-align:right\">——艾丽斯·纪尼安</p>\n\n## 献给阿尔吉侬\n\n查理得知留给自己的时间不长后，把所有精力花在研究他自身发生的变化上。他并没有用他梦寐以求的聪明去做自己想做的事，而是用昙花一现的人类最高智力，去推进科学发展，为未来其他智障者开辟道路。\n\n>我把阿尔吉侬的尸体放在一个小金属容器里带回家，我不会让他们把它丢进焚化炉。这样做有些愚蠢和伤感，但昨天深夜我把它埋在后院。把一束野花放在坟上时，我哭了起来。\n\n------\n\n## 我\n\n这本小说中会出现很多**错字**，但正是这一巧妙的设计让读者看到一个有血有肉的残疾人的一生。\n\n我和查理没有什么共同点可言，无论是在他做手术前，还是之后。我想象自己如果在书中是个什么样的位置，最后发现可能只是面包店里默默工作的一员。我不会嘲笑和捉弄查理，也不会在他变成高智商时排挤他。但我的篇幅一定不会比金皮或者乔更多。或许查理会主动和我敞开心扉，而我多半对此爱莫能助；或许我从头到尾都不会知道查理对命运的伟大抗争。\n\n全世界有7%左右的残疾人，其中智力残疾比肢体残疾要少一些。在我的20多年人生中，擦肩而过的可能有10来个，但不曾接触过他们中的任何人。我自认为与人交流时有注意不让对方尴尬难堪，但或许我并不比那些为残障机构捐款却从不与他们交流的富豪更有同情心。我自认为对任何人都没有歧视和偏见，但我实际能做到的只是表示理解，却不能提供真正的帮助。\n\n我的心灵是一块开阔却贫瘠的土地，不会拒绝踏入的脚印，但也找不着一束可以献上的花。\n\n","tags":["感想"],"categories":["读书笔记"]},{"title":"并发/并行&同步/异步","url":"/2022/11/05/my-programing-note1/","content":"\n# 并发vs并行\n\n## 并发(Concurrency)\n\n并发是一个宽泛概念，表示计算机同时执行多项任务。\n\n对于单核处理器，可以通过分配时间片的方式（又称上下文切换context switching）\n\n## 并行(Parallelism)\n\n在多核处理器中，真正意义上同时执行多项任务。\n\n<!--more-->\n\n# 同步vs异步\n\n## 同步编程(Synchronous)\n在执行完一项任务后才执行下一项任务，没有并发并行的概念\n## 异步编程(Async)\n\n在**单线程中**同时执行多个任务的编程方式。无需考虑线程同步，线程竞争的问题。\n\n适用于有网络操作，数据库访问等I/O密集的应用程序。如果使用多线程，线程中的大部分时间在等待，反而浪费了线程切换和线程内存的开销。多线程适合计算量大的程序。\n\n### Javascript\n\nJs中实现异步的方法有callback，Promise，async/await\n\n#### async/await\n\nasync将函数标记为异步函数，返回值为Promise对象。在async函数中可以调用await标记的异步函数。\n","tags":["编程"],"categories":["程序设计"]},{"title":"餐厅管理网页练习","url":"/2022/10/16/my-vue-practice1/","content":"\n记录一下这两天用vue模写网页的过程。\n\n成品：\n\n![my-vue-practice1](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/my-vue-practice1.png)\n\n<!--more-->\n\n※设计图来自IQQNIC Design的[免费餐厅管理模板](https://pixso.cn/community/file/iwhOWVDOeICw39kGAlSxrA)\n\n页面最外层：\n\n* sidebar：固定像素，fixed固定在侧边\n\n* navigationBar+router-view：上下结构，这次只做了home界面所以路由不会切换\n\n黄色框内的元素均为响应式渲染，由store里的数据管理。\n\n# 解决的技术问题\n\n## 滚动条显示异常\n\n在写`Home.vue`时，明明页面超出了屏幕，却不显示滚动条，也无法滑动。\n\n```html\n<!--App.vue-->\n<template>\n    <div class=\"APPcontainer\">\n            <SideBar/>\n        <main class=\"APPmain\">\n            <div class=\"navigation\">\n                <NavigationBar />\n            </div>\n            <div class=\"mainView\">\n                <!--这部分超出了界面-->\n                <router-view />\n            </div>\n        </main>\n    </div>\n</template>\n```\n\n**解决方法**：\n\n```css\n<!--在最外层容器添加-->\n.APPcontainer {\n    overflow-y: scroll;\n    width: 100vw;\n    height: 100vh;\n}\n```\n\n原理没搞懂，`height:100vh`比较关键，不加这句的话滚动条长得会比较奇怪。\n\n## CSS简单动效\n\n`transition:[时间]`可以在元素样式产生变化时自动生成补间，像淡出淡入，侧栏展开等。\n\n`filter`属性可以改变元素的颜色，功能繁多。\n\n  \n","tags":["编程"],"categories":["前端"]},{"title":"网页设计学习笔记","url":"/2022/10/13/my-web-design-note/","content":"\n# 页面尺寸的选择\n\n## 网页宽度&有效可视区\n* **网页宽度**：进行页面设计时画板的宽度\n* **有效可视区**：网页内容所占的宽度\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/2107_01.jpg)\n<!--more-->\n[Statcounter Global Stats](https://gs.statcounter.com/screen-resolution-stats/desktop/worldwide)上可以看到当前PC端显示器的流行尺寸，由此得出结论：\n\n> 网页宽度：1920\n>\n> 有效可视区：900~1200\n\n![image-20221013124444439](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221013124444439.png)\n\n\n# 响应式布局\n\n若不希望可视区占比太小，可以采用响应式布局使得网页在不同的尺寸下有不同的布局。\n\n![リキッドレイアウトの簡単な説明：レイアウトは同じでコンテンツの幅がディスプレイの幅に応じて変化する。](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/0117-1.png)\n\n## 百分比\n\n### %\n相对于父元素，或无父元素则相对于视窗\n\n| 属性              | 百分比基准                         |\n| ----------------- | :--------------------------------- |\n| width             | 基于父级的width                    |\n| height            | 基于父级的height                   |\n| margin(四个方向)  | 基于父级的width                    |\n| padding(四个方向) | 基于父级的width                    |\n| left,,right       | 基于**非static定位**的父级的width  |\n| top,bottom        | 基于**非static定位**的父级的height |\n\n### vw&vh\n* 1vw=1%视窗宽度\n* 1vh=1%视窗高度\n* vmin：vw和vh中较小值\n* vmax：vw和vh中较大值\n\n## rem(font size of the root element)\n\nrem为相对于**根元素字体大小**的单位\n\n## 媒体查询\n\n```css\n//页面宽度大于960px小于1200px\n@media screen \nand (min-width:960px) \nand (max-width:1200px){\n        /*---*/\n}\n```\n\n# flex布局\n\nFlex布局中存在main axis(横向)和cross axis(纵向)两个轴，默认将元素在main axis从左向右排列\n\n## `justify-content`\n可以决定容器中元素在**主轴**方向的位置\n* `flex-start`：将元素对齐主轴首端\n* `flex-end`：将元素对齐主轴末端\n* `center`：将元素居中\n* `space-between`：使第一个元素位于主轴首端，最后一个元素位于主轴末端\n* `space-around`：将元素等距排列，且第一个元素和最后一个元素到边界的距离相当于元素间距离的一半\n\n## `align-items`\n可以决定容器中元素在**副轴**方向的位置\n\n- `flex-start`：将元素对齐副轴首端\n- `flex-end`：将元素对齐副轴末端\n- `center`：将元素居中\n- `stretch`：\n- `baseline`：\n\n## `align-self`\n作用于flex布局内的**元素**。选项与`align-items`相同，用于具体修改某个元素的纵向布局。\n\n## `flex-direction`\n可以修改主轴的方向\n\n- `row`：主轴为横向，从左向右\n- `row-reverse`：主轴为横向，从右向左\n- `column`：主轴为纵向，从上向下\n- `column-reverse`：主轴为纵向，从下向上\n\n## `order`\n作用于flex布局内的**元素**。默认值为0，可选择任意**整数值**。数值大的元素将排列在后面。\n\n## flex实现自动填充\n```html\n<div class=\"box\">\n  <div class=\"header\">头部</div>\n  <div class=\"auto-fill\">自动填充</div>\n</div>\n```\n\n```css\n.box {\n  display: flex;\n  flex-flow: column;\n}\n\n.header {\n  height: 30px;\n}\n\n.auto-fill {\n  flex: 1;\n}\n```\n\n## flex自动撑满父元素\n\n```\nflex-grow:1;\n```\n\n## flex防止元素收缩\n\n```\nflex-shrink:0;\n```\n\n# Grid布局\n\n`fr`：grid专有单位，表示比例（fraction）\n\n**Grid布局嵌套时，外层容器设置`overflow:hidden`可防止子元素溢出**\n\n## `grid-template`\n\n**容器属性**，用于定义栅格行列的宽度，数量\n\n* `grid-template-columns`\n* `-rows`\n* 【选项】`repeat(重复次数,值)`：\n\n```less\n//相当于\"100px 100px 100px\"\ngrid-template-columns:repeat(3,100px);\n//自动按照容器宽度填充（响应式）\ngrid-template-columns:repeat(auto-fill,100px);\n```\n\n* 【选项】`minmax(最小值，最大值)`\n* 【选项】`auto`\n* 【选项】`网格线[...]`\n* `-areas`：设定网格区域：\n```less\ngrid-template-areas:'a b c' \n\t\t\t\t\t'd e f'; \n//匿名区域：\".\"\n//在项目上分配区域：\"grid-area:区域名;\"\n//每个区域的起始网格线自动命名为\"区域名-start\"\n//终止网格线自动命名为\"区域名-end\"\n```\n\n## `gap`\n\n**容器属性**，设置行，列的间距。\n\n* `row-gap`\n* `column-gap`\n* `gap`\n\n## `grid-auto`\n\n### `grid-auto-flow`\n\n**容器属性**，设置自动排列的方向\n\n* 【选项1】`row`：按行排放（默认）\n* 【选项1】`column`：按列排放\n* 【选项2】`dense`：用后排项目填补空余部分\n\n![image-20221104105341526](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221104105341526.png)\n\n### `grid-auto-rows/columns`\n\n**容器属性**，设置多出项目的宽(column)和高(row)\n\n## 对齐选项\n\n### `-items`\n\n**容器属性** ：决定项目在**单元格内**的对齐方式\n\n* `justify-items`：水平方向对齐\n* `align-items`：垂直方向对齐\n  * `start|end|center|stretch`：stretch为撑满单元格\n* `place-items`：\\<align-items> \\<justify-items>\n\n### `-content`\n\n**容器属性**：决定网格区域在父元素内的对齐方式\n\n* `justify-content`：水平方向对齐\n* `align-content`：垂直方向对齐\n  * `start|end|center|stretch`\n  * `space-around`\n  * `space-between`\n  * `space-evenly`：等间距分布（包括与边界的距离\n\n## 项目属性\n\n### 指定位置\n\n* `grid-column/row-start/end`\n\n  ※简写:`grid-column:1/3;`\n\n  ※跨行写法：`grid-column-start:span 3;`(占三列)\n\n![image-20221104114016154](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221104114016154.png)\n\n* `grid-area`：指定所在区域\n\n```less\ngrid-area:区域名;\ngrid-area:1/1/3/3;\n//简写 row-start/column-start/row-end/column-end;\n```\n\n### 对齐\n\n* `justify-self/align-self`：设置项目在单元格内对齐方式\n\n\n# CSS技巧\n**box-shadow**: \n\noffset-x(x偏移) offset-y(y偏移) blur(模糊半径) spread(扩展半径) color(颜色) position(inset内阴影);\n\n**透过上层点击到下层元素**：\n\n给上层元素添加{pointer-events:none;}\n\n```\noverflow:hidden;\n\nwhite-space:nowrap; \n\ntext-overflow:ellipsis; \n```\n\ntext-overflow失效：父元素为flex布局\n\n`user-select: none` ：阻止用户选中文本\n\n## Filter\n\n| 选项                                               | 说明                                                         |\n| -------------------------------------------------- | :----------------------------------------------------------- |\n| blur(*px*)                                         | 给图像设置高斯模糊。默认是0；这个参数可设置css长度值，但不接受百分比值。 |\n| brightness(*%*)                                    | 使图片看起来更亮或更暗，默认100%。                           |\n| contrast(*%*)                                      | 调整图像的对比度，默认100%。                                 |\n| drop-shadow(*h-shadow v-shadow blur spread color*) | 给图像设置一个阴影效果。                                     |\n| grayscale(*%*)                                     | 将图像转换为灰度图像，默认为0，值在0%到100%之间。            |\n| hue-rotate(*deg*)                                  | 给图像应用色相旋转，默认值是0deg。                           |\n| invert(*%*)                                        | 反转输入图像。默认为0，100%为完全反转。                      |\n| opacity(*%*)                                       | 转化图像的透明程度，默认为100%。                             |\n| saturate(*%*)                                      | 转换图像饱和度，默认100%。                                   |\n| sepia(*%*)                                         | 将图像转换为深褐色，默认为0。                                |\n| url()                                              | URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：`filter: url(svg-url#element-id)` |\n\n## 混合模式\n\n```\nmix-blend-mode: normal; //正常\nmix-blend-mode: multiply; //正片叠底\nmix-blend-mode: screen; //滤色\nmix-blend-mode: overlay; //叠加\nmix-blend-mode: darken; //变暗\nmix-blend-mode: lighten; //变亮\nmix-blend-mode: color-dodge; //颜色减淡\nmix-blend-mode: color-burn; //颜色加深\nmix-blend-mode: hard-light; //强光\nmix-blend-mode: soft-light; //柔光\nmix-blend-mode: difference; //差值\nmix-blend-mode: exclusion; //排除\nmix-blend-mode: hue; //色相\nmix-blend-mode: saturation; //饱和度\nmix-blend-mode: color; //颜色\nmix-blend-mode: luminosity; //亮度\nmix-blend-mode: initial; //初始\nmix-blend-mode: inherit; //继承\nmix-blend-mode: unset; //复原\n```\n\n## 滚动贴合 Scroll Snap\n\n```\nmain{\n\tscroll-snap-type:y mandatory;\n\toverflow:scroll;\n\theight:100vh;\n}\n\nsection{\n\twidth:100vw;\n\theight:100vh;\n\tscroll-snap-align:start;\n}\n```\n\n## 子元素hover改变父元素css\n\n```css\ndiv.parent {  \n    pointer-events: none;\n}\n\ndiv.child {\n    pointer-events: auto;\n}\n\ndiv.parent:hover {\n    background: yellow;\n}   \n\n```\n\n```html\n<div class=\"parent\">\n  parent - you can hover over here and it won't trigger\n  <div class=\"child\">hover over the child instead!</div>\n</div>\n```\n\n* 内容超出屏幕不显示滚动条：父元素设置`overflow:scroll`\n\n* flex布局单个子元素靠右：`margin-left:auto`\n\n* 绝对定位居中：\n  * `margin:auto`\n  * `top:50%;left:50%`\n  * `transform:translate(-50%,-50%)`\n\n## height auto transition不生效\n\n使用`max-height`代替`height`：\n\n```css\n#menu #list {\n    max-height: 0;\n    transition: max-height 0.15s ease-out;\n    overflow: hidden;\n    background: #d5d5d5;\n}\n\n#menu:hover #list {\n    max-height: 500px;\n    transition: max-height 0.25s ease-in;\n}\n```\n\n# 移动端\n\n![如何构建界面设计框架？4个维度帮你掌握起来！](../images/uisdc-gj-20220824-7.jpg)\n\n![如何构建界面设计框架？4个维度帮你掌握起来！](../images/uisdc-gj-20220824-8.jpg)\n\n# 常用正则表达式\n\n## 手机号码\n\n```javascript\nconst phoneReg = /^[1][3,4,5,6,7,8,9][0-9]{9}$/\n\nconst phoneStr1 = '18886233487'\nconsole.log(phoneReg.test(phoneStr1)) // true\n\nconst phoneStr2 = '17283017203897'\nconsole.log(phoneReg.test(phoneStr2)) // false\n```\n\n## 身份证\n\n```javascript\nconst sfzReg = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/\n\nconst sfzStr1 = '415106199801012130'\nconsole.log(sfzReg.test(sfzStr1)) // true\n\nconst sfzStr2 = '718381298381212183'\nconsole.log(sfzReg.test(sfzStr2)) // false\n```\n\n## 邮箱\n\n```javascript\nconst emailReg = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/\n\nconst emailStrWY = '956666@163.com' // 163邮箱\nconst emailStrQQ = '956666@qq.com' // qq邮箱\nconsole.log(emailReg.test(emailStrWY)) // true\nconsole.log(emailReg.test(emailStrQQ)) // true\n\nconst noEmail = '72873213.com'\nconsole.log(emailReg.test(noEmail)) // false\n```\n\n## URL\n\n```javascript\nconst urlReg = /^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/\n\nconst urlStr1 = 'https://haha.sunshine.com/xxx/xxx'\nconsole.log(urlReg.test(urlStr1)) // true\n\nconst urlStr2 = 'sss://haha.sunshine.com/xxx/xxx'\nconsole.log(urlReg.test(urlStr2)) // false\n```\n\n## IPv4\n\n```javascript\nconst ipv4Reg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\n\nconst ipv4Str1 = '122.12.56.65'\nconsole.log(ipv4Reg.test(ipv4Str1)) // true\n\nconst ipv4Str2 = '122.12.56.655'\nconsole.log(ipv4Reg.test(ipv4Str2)) // false\n```\n\n## 16进制颜色\n\n```javascript\nconst color16Reg = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/\n\nconst color16Str1 = '#fff'\nconsole.log(color16Reg.test(color16Str1)) // true\n\nconst color16Str2 = '#1234567'\nconsole.log(color16Reg.test(color16Str2)) // false\n```\n\n## YYYY-MM-DD\n\n```javascript\nconst dateReg = /^\\d{4}(\\-)\\d{1,2}\\1\\d{1,2}$/\n\nconst dateStr1 = '2021-10-10'\nconsole.log(dateReg.test(dateStr1)) // true\n\nconst dateStr2 = '2021-01-01 1'\nconsole.log(dateReg.test(dateStr2)) // false\n```\n\n## YYYY-MM-DD hh:mm:ss\n\n```javascript\nconst dateReg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2}) (\\d{1,2}):(\\d{1,2}):(\\d{1,2})$/\n\nconst dateStr1 = '2021-10-10 16:16:16'\nconsole.log(dateReg.test(dateStr1)) // true\n\nconst dateStr2 = '2021-10-10 16:'\nconsole.log(dateReg.test(dateStr2)) // false\n```\n\n## 整数\n\n```javascript\nconst intReg = /^[-+]?\\d*$/\n\nconst intNum1 = 12345\nconsole.log(intReg.test(intNum1)) // true\n\nconst intNum2 = 12345.1\nconsole.log(intReg.test(intNum2)) // false\n```\n\n## 小数\n\n```javascript\nconst floatReg = /^[-\\+]?\\d+(\\.\\d+)?$/\n\nconst floatNum = 1234.5\nconsole.log(floatReg.test(floatNum)) // true\n```\n\n## 保留n位小数\n\n```javascript\nfunction checkFloat(n) {\n  return new RegExp(`^([1-9]+[\\d]*(.[0-9]{1,${n}})?)$`)\n}\n// 保留2位小数\nconst floatReg = checkFloat(2)\n\nconst floatNum1 = 1234.5\nconsole.log(floatReg.test(floatNum1)) // true\n\nconst floatNum2 = 1234.55\nconsole.log(floatReg.test(floatNum2)) // true\n\nconst floatNum3 = 1234.555\nconsole.log(floatReg.test(floatNum3)) // false\n```\n\n","tags":["编程","设计"],"categories":["前端"]},{"title":"Vue3应用练习","url":"/2022/10/03/my-first-vue-app/","content":"\n在跟着[Vue3通用后台管理](https://www.bilibili.com/video/BV1QU4y1E7qo/)敲完代码，又对着Vue3文档学了个大概后，做了个应用试手。\n\n<!--more-->\n\n----\n\n# 技术栈\n* Vue3\n* Vite\n* vue-router\n* pinia\n* element-Plus\n\n----\n\n# 实现的功能\n\n* 通过`增加批注`按钮给文章的选定段落增加批注。\n* 批注包括`名称`，`批注内容`，`时间`，`选定段落`\n* 增加的`批注`会显示在文章的侧栏。\n* **点击批注**会标记该批注和选定的段落，且同时只有一个批注会被选定。\n* 在**批注汇总**页显示所有文章的所有批注。\n* 在**批注汇总**页**点击批注**会跳转到目标批注所在的文章及段落，同时使该批注被选定。\n\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221003124743017.png\" alt=\"image-20221003124743017\" style=\"zoom: 25%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221003124822698.png\" alt=\"image-20221003124822698\" style=\"zoom: 25%;\" />\n\n----\n# 遇到的问题\n\n## onClick事件内注册的click侦听器会直接被触发\n```javascript\n//按钮绑定了onclick事件\nconst onClickEvent = () => {\n    //update()会在按钮时直接被触发\n    window.addEventListener('click', update);\n}\n```\n\n**解决方法**：将`click`事件换成`mousedown`\n\n## 在点击批注跳转后使该批注变成选定状态\n\n**解决方法**：`onActivated()`\n```javascript\nimport {onActivated} from 'vue'\nonActivated(()=>{\n\t//每当页面被重新加载就会执行\n});\n```\n\n## 多行文字的截取省略\n\n**解决方法**：找准文字所在的块级元素\n\n```css\np {\n    display: -webkit-box;\n    overflow: hidden;\n    -webkit-line-clamp: 2; //限制的行数\n    -webkit-box-orient: vertical;\n}\n```\n----\n\n# 总结\n\n我的前端学习比较断断续续，缺乏练习和规范，导致实际操作起来试错很多。虽然遇到的问题最终都解决了，但做一个省略了UI的小功能应用还花了将近两天时间。而且这次实践也让我体会到UI设计并不容易，得进行系统的学习。更不要妄想不打设计稿，边敲代码边设计。","tags":["编程"],"categories":["前端"]},{"title":"Vue3","url":"/2022/09/25/Vue3-conclusion/","content":"\n# Vue3\nVue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n\n<!--more-->\n\n----\n\n# 开发步骤\n\n\n## step_0_构建\n\n### Vite脚手架\n\n通过脚手架，可以快速构建项目预设，包含`main.js`，`App.vue`以及`/src`文件夹等。\n\n**※用npm安装插件后若热更新失效，可以用yarn重装一遍**\n\n```shell\n//安装vite脚手架并构建预设vue项目\nyarn[cnpm] create vite my-vue-app --template vue\n\n//进入项目根目录，安装\ncd my-vue-app\nyarn install\n\n//创建本地服务器，进入开发模式\nyarn dev\n```\n### elementPlus引入\n\n```javascript\n//进入根目录，安装element-Plus\ncnpm install element-plus --save\n\n//安装插件\ncnpm install -D unplugin-vue-components unplugin-auto-import\n\n//插入到vite.config.js\nimport { defineConfig } from 'vite'\nimport AutoImport from 'unplugin-auto-import/vite'\nimport Components from 'unplugin-vue-components/vite'\nimport { ElementPlusResolver } from 'unplugin-vue-components/resolvers'\n\nexport default defineConfig({\n  // ...\n  plugins: [\n    // ...\n    AutoImport({\n      resolvers: [ElementPlusResolver()],\n    }),\n    Components({\n      resolvers: [ElementPlusResolver()],\n    }),\n  ],\n})\n```\n\n完整引入Icon\n```javascript\n//main.js\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\nconst app=createApp(App)\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n  app.component(key, component)\n}\n```\n\n### 安装&配置 vue-router\n```javascript\n//项目根目录，安装4.0以上vue-router\nnpm install vue-router@4\n\n//\"src/router/index.js\"\nimport {createRouter,createWebHashHistory} from 'vue-router'\n\n//存储路径\nconst routes=[\n    {\n        path:'/',\n        name:'intro',\n        component: ()=>import('../views/Intro.vue')\n    },\n]\n\n//创建路由实例\nconst router = createRouter({\n    history: createWebHashHistory(),\n    routes\n})\nexport default router\n```\n\n#### Token验证\n\n* 定义需要token验证的页面\n\n### 安装&配置 pinia\n\n```javascript\n//根目录\nnpm install pinia\n\n//\"src/store/index.js\"\nimport {defineStore} from \"pinia\";\nexport const useStore = defineStore('id',{\n    state: () => ({\n        isCollapse:false,\n        currentMenu:null,\n        tabsList:[\n            {\n                path:'/home',\n                name:'home',\n                label:'首页',\n                icon:'home'\n            }\n        ],\n        menu:[\n        ],\n        token:''\n    }),\n})\n```\n\n## step_1_创建应用实例\n\n```javascript\nmain.js//入口文件\n\n<!--1.创建应用实例-->\n//导入createApp，单文件根组件\nimport {createApp} from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport { createPinia } from 'pinia';\n//createApp(根组件,根组件Props[可选])\nconst app = createApp(App)\n/*---外部导入↑或↓内联---*/\nconst app = createApp({\n    /*内联根组件*/\n})\n\n<!--2.引入router,pinia-->\napp.use(router).use(createPinia())\n\n<!--3.将应用实例挂载在一个容器元素中-->\n//mount(DOM元素或CSS选择器)\n//每个应用实例仅能调用一次mount()\napp.mount('#app')\n/*---CSS选择器↑或↓DOM元素---*/\napp.mount(document.body.firstChild)\n```\nApp相关方法，属性\n\n* `unmount()`：卸载一个已挂载的应用\n* [`provide()`](https://cn.vuejs.org/api/application.html#app-provide)：提供一个值，在应用中的所有后代组件中注入使用。\n* [`component()`](https://cn.vuejs.org/api/application.html#app-component)：注册组件\n* [`directive()`](https://cn.vuejs.org/api/application.html#app-directive)：注册指令\n* [`use()`](https://cn.vuejs.org/api/application.html#app-use)：安装一个插件\n* `version`：当前应用所使用的 Vue 版本号\n* [`config`](https://cn.vuejs.org/api/application.html#app-config)：对这个应用的配置设定\n* [`config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties)：注册能够被应用内所有组件访问的全局属性的对象\n\n## step2_组件(component)\n\n命名建议：PascalCase(所有首字母大写)\n\n### pinia的使用\n\n```javascript\nimport { useStore } from '../../store';\nconst store = useStore();\n\n```\n\n### router的使用\n\n```vue\n<script setup>\nimport { useRouter } from 'vue-router';\nconst router = useRouter();\n    \nrouter.push({\n\tpath: '/movieDetail',\n\tquery: {\n\t\tkeyword: movie_id\n\t}\n});\n</script>\n\n<template>\n\t<router-view />\n</template>\n```\n\n\n\n### 创建组件\n\n## step3_测试\n\n### 单元测试\n\n[单元测试](https://cn.vuejs.org/guide/scaling-up/testing.html#unit-testing)侧重于逻辑上的正确性，只关注应用整体功能的一小部分。\n\n----\n\n# 单文件组件\n\n> **前端开发的关注点不是完全基于文件类型分离的**。在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。\n\n将一个Vue组件的模板(html)，逻辑(javascript)，样式(css)封装在单个文件`*.vue`中。\n\n每个文件都由三种顶层语言模块构成：`<template>` `<style>` `<script>` \n\n## \\<template>\n\n* 每个 `*.vue` 文件最多包含一个`<template>`标签。标签中可以使用原生html，`\\<router-view/>`，以及element-Plus等UI框架提供的API等。\n\n## \\<style>\n\n* 每个 `*.vue` 文件可以包含**多个** `<style>` 标签。标签内使用css相关语言\n\n### \\<style scoped>\n带有`scoped`属性的style标签值会影响当前组件内的元素。\n\n```html\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\">hi</div>\n</template>\n-----↓↓↓通过 PostCSS 将内容转化↓↓↓-----\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n※子组件的根元素只有**一个**时<font color=#aaa>(`<template>`内的最外层元素)</font>会附带父组件的`data-v-hash`，同时被父组件的样式和子组件的样式影响。\n\n**当子组件和父组件有同名class的选择器时，父组件样式会覆盖子组件样式**。\n\n子组件设置`inheritAttrs`为`false`，非`props`属性不会应用到子组件根元素上。但父组件使用标签选择器时，子组件样式依然被影响。\n\n#### 选择器\n* `:deep()`\n* `:slotted()`\n* `:global()`\n* **小心递归组件中的后代选择器**！对于一个使用了 `.a .b` 选择器的样式规则来说，如果匹配到 `.a` 的元素包含了一个递归的子组件，那么所有的在那个子组件中的 `.b` 都会匹配到这条样式规则。\n\n### \\<style module>\n编译为CSS Modules([暂略](https://cn.vuejs.org/api/sfc-css-features.html#css-modules))\n\n### v-bind()\n\n```html\n<script>\nexport default {\n  data() {\n    return {\n      color: 'red'\n    }\n  }\n}\n</script>\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n自定义属性会通过内联样式的方式应用到组件的根元素上，并且在源值变更的时候响应式地更新\n\n### 预处理器\n[暂略](https://cn.vuejs.org/api/sfc-spec.html#pre-processors)\n\n## \\<script>\n\n* 每个 `*.vue` 文件最多可以包含一个`<script>`和 `<script setup>`\n\n### 构成\n```html\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n```\n\n### export\n`export`用于导出单文件组件的**选项对象**，以便在其他组件中用`import`引入。`export default`导出为一整个模块，`export`可以分别命名导出的模块。一个js中只能由一个`export default`，但可以有多个`export`。\n\nmain.js在构造根组件时，如果根组件包含其他子组件，那么Vue会通过引入的**选项对象**构造对应的组件。\n\n## 组件使用\n\n### 注册子组件\n\n```html\n//局部组件\n<script setup>\n//注册子组件，可在模板中任意使用\nimport ChildComponent from './ChildComponent.vue'\n</script>\n<template>\n\t<ChildComponent />\n\t<ChildComponent />\n</template>\n\n//全局组件(main.js中)\nimport ChildComponent from './ChildComponent.vue'\napp.component('Child',ChildComponent)\n```\n\n每个组件都是独立的实例，维护独立的属性。\n\n### 组件参数-Props\n* 通过Props属性，子组件可以从父组件接收参数。\n* 当使用对象形式声明props时，值为该prop预期类型的构造函数。该方法可以在prop传入错误类型时抛出警告。\n* 可以用一个`const`变量取接收`defineProps()`返回的对象\n* 所有prop都是可选的，除非声明`required:true`\n* 未传递的prop默认值为`undefined`或Boolean则为`false`\n\n```html\n<!--子组件中-->\n<script setup>\nconst props=defineProps(['title'])\n    <!--或者-->\ndefineProps({\n  title: String,\n  propA: {\n    type: Object,\n    required: true\n    //自定义类型校验\n    validator(value){\n      return { message: 'hello' }\n    }\n  }\n})\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n  </div>\n</template>\n\n<!--父组件中-->\n<div>\n  <BlogPost title=\"Why Vue is so fun\" />\n  <!--也可通过v-bind传递变量-->\n  <BlogPost :title=\"post.title\" />\n  <!--批量传入Props(post对象包含所有props)-->\n  <BlogPost v-bind=\"post\" />\n</div>\n```\n\n所有的 props 都遵循着**单向绑定**原则，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值\n\n<font color=#b00>※prop在子组件中是只读的，当你尝试修改时，vue会抛出警告</font>\n\n>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。\n>\n>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在大多数场景下，子组件应该**抛出一个事件**来通知父组件做出改变。\n\n### 组件事件-Emits\n* 通过Emits属性，子组件可以抛出一个事件，给父组件接收\n\n```html\n<!--子组件中-->\n<script setup>   \ndefineEmits(['enlarge-text'])\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n\n<!--父组件中-->\n<div :style=\"{ fontSize : postFontSize +'em' }\">\n  <BlogPost title=\"Why Vue is so fun\" @enlarge-text=\"postFontSize += 0.1\"/>\n</div>\n```\n\n#### 事件参数&事件校验\n[略](https://cn.vuejs.org/guide/components/events.html#event-arguments)\n\n### 组件向上暴露数据-Expose\n\n```vue\n<!--子组件中-->\n<script setup>   \n    const flag=ref(false);\n\tdefineExpose({\n    \tflag\n\t})\n</script>\n\n<!--父组件中-->\n<div >\n  <Child ref=\"child\"/>\n</div>\n\n<script setup>\nconst child = ref(null);\n//flag暴露为child.vallue.flag\n</script>\n```\n\n### Provide&Inject\n\n在祖先组件通过provide()提供的数据，可供其任何子组件使用。\n\n```vue\n<!--多个子组件中-->\n<script setup>   \n\tconst flag = inject(\"flag\");\n</script>\n\n<!--共同的祖父组件中-->\n<script setup>\n    const flag=ref(false);\n\tprovide(\"flag\", flag);\n</script>\n```\n\n\n### 插槽-slot\n通过slot，父组件可以向子组件传递元素，从而在子组件中完成渲染。\n\n※插槽的内容无法访问到子组件的状态\n\n```html\n<!--父组件中-->\n<AlertBox>\n  Something bad happened.\n</AlertBox>\n\n<!--子组件中,slot部分会被父组件传入的元素取代-->\n<template>\n  <div class=\"alert-box\">\n    <slot>可在此填入默认内容</slot>\n  </div>\n</template>\n```\n\n#### 具名插槽\n\n带 `name` 属性的插槽被称为具名插槽 (named slots)，未提供`name`则隐式地命名为“default”。\n```html\n<!--子组件中-->\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n</div>\n\n<!--父组件中-->\n<BaseLayout>\n  <template v-slot:header>\n  <!--或简写-->\n  <template #header>\n  <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n#### 作用域插槽\n[略](https://cn.vuejs.org/guide/components/slots.html#scoped-slots)\n\n### 动态切换组件\n通过`component`元素和`is`属性可以实现动态组件，`is`的值可以是**被注册的组件名**或**导入的组件对象**。一般情况下，被切换的组件会被销毁。在下次切换回该组件时，会创建一个初始状态的新实例。\n\n通过`<KeepAlive>`内置组件包装动态组件，可以缓存被切换的组件。\n\n可选属性：\n\n* `max`：限制被缓存的数量\n* `include/exclude`：可以筛选需要缓存的组件，传入正则表达式或数组，匹配组件的`name`\n\n```html\n<router-view v-slot=\"{Component}\">\n    <KeepAlive :max=\"3\" :include=\"/a|b/\">\n  \t\t<component :is=\"Component\"/>\n\t</KeepAlive>\n</router-view>\n```\n\n### 透传属性\n当一个属性传递给子组件时，若该属性未被子组件声明为`props`,`emits`,`v-on`事件监听器，则称为**透传attribute**或`Non-props`。\n\n* 当子组件**只含单个根元素**，则透传属性会被自动添加到该元素上，并和元素上原有的属性合并。\n\n* 如果子组件A中是另一个组件B，透传属性会传递给组件B\n* 在组件`export default`中设置`inheritAttrs: false`可以禁用组件透传。\n* 在设为禁用后，在子组件中可以通过`$attrs`[访问](https://cn.vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance)所有透传属性，并通过`v-bind=\"$attrs\"`将透传属性绑定到任意元素上。\n\n```html\n<!--MyButton组件只含一个button元素-->\n<button class=\"child\">click me</button>\n\n<!--父组件中-->\n<MyButton class=\"father\" msg=\"hello\" @click=\"onClick\"/>\n\n<!--最终渲染-->\n<button \nclass=\"child father\" msg=\"hello\" @click=\"onClick\">\nclick me\n</button>\n```\n\n#### 在Js中访问attrs\n以下`attrs`为非响应式。\n```html\n<script setup>\nimport { useAttrs } from 'vue'\nconst attrs = useAttrs()\n</script>\n\n<script>\nexport default {\n  setup(props, ctx) {\n    // 透传 attribute 被暴露为 ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n</script>\n```\n\n# 组合式API\n\n>* 使用函数而不是声明选项的方式书写Vue组件\n>* 包括响应式API，生命周期钩子，依赖注入\n\n## 组合式API的优势\n更灵活地组织代码，让逻辑相关的代码能够集中在一处\n>组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着**你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践**。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。\n\n## 响应式API\n\n### 理解响应性\n[Vue的解释](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#what-is-reactivity)\n> 响应性是可以声明式地处理变化的编程范式，使一个对象发生变化时，与其相关联的对象也能随之发生变化。\n\n响应式对象： Vue 能够跟踪，访问，修改其属性的对象，实际是JavaScript Proxy。\n\n### 定义响应式变量-reactive()\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n```\n#### reactive()规则\n* Proxy和原始对象并非全等，因此使用Vue 的响应式系统应**仅使用你声明对象的代理版本**。\n\n* 已存在的代理对象传入`reactive()`会返回该代理本身。\n\n* 同一个对象传入`reactive()`总是会返回同一个代理对象。\n\n* `reactive()`对原始数据类型无效。\n\n* 将`reactive()`响应式对象解构或传入函数时，失去响应性连接。\n\n* 当一个变量多次接受`reactive()`返回的代理对象，旧的响应式连接会丢失。\n\n```javascript\n  let state = reactive({ count: 0 })\n  // 上面的 ({ count: 0 }) 将不再被追踪\n  state = reactive({ count: 1 })\n```\n### 定义响应式变量-ref()\n`ref()`可以创建任何值类型的响应式，且传给函数或是从一般对象上被解构时，不会丢失响应性，可用于将逻辑提取到 [组合函数](https://cn.vuejs.org/guide/reusability/composables.html) 中\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\nconst object = {foo:ref(1)}\n//ref()将创建一个带value属性的对象\n//count={value:0}\n//count.value=0\n</script>\n```\n\n当ref是模板渲染上下文的顶层属性或文本插值计算的最终值时将自动解包\n```vue\n<template>\n<!-- ↓解包，结果为：0 -->\n{{ count }}\n<!-- ↓解包，结果为：1 -->\n{{object.foo}}\n<!-- ↓不解包，结果为：[object Object]1 -->\n{{object.foo+1}}\n</template>\n```\n\n[ref在响应式对象中的解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref-unwrapping-in-reactive-objects)（略）\n\n### 计算属性 computed()\n`computed()`方法接收一个getter函数，并返回一个计算属性**ref**，与一般ref用法类似。计算属性会自动追踪响应式依赖并随之变化。\n\n```javascript\n//setup内\nimport {computed} from 'vue'\nlet number = ref(1);\nlet sign = computed(()=>{\n    return number>0?'plus':'minus'\n});\n```\n与直接调用方法相比，计算属性会有**缓存**功能，只要其响应式依赖不改变，计算属性就会立即返回先前的结果而不重复计算。\n一般方法会在每次页面重渲染时执行\n<font color='#aaa'>※计算函数不应进行计算以外的作用(如更改DOM或做异步请求)</font>\n\n## 生命周期钩子\n\n在**某一时刻**会**自动执行**的函数\n\n![组件生命周期图示](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/lifecycle.16e4c08e.png)\n\n```javascript\n//在实例生成之前\nbeforeCreate()\n//在实例生成之后\ncreated()\n//组件渲染前\nbeforeMount()\n//在组件被渲染到页面后\nmounted()\n//在数据发生变化前\nbeforeUpdate()\n//在数据发生变化，页面重新渲染后\nupdated()\n//当实例销毁前\nbeforeUnmounted()\n//实例销毁后\nunmounted()\n```\n\n以上API全部在`setup()`阶段被调用\n\nrouter-view切换时调用：\n\n```html\n<script setup>\nimport { onActivated, onDeactivated } from 'vue'\n    \nonActivated(() => {\n  // 调用时机为首次挂载\n  // 以及每次从缓存中被重新插入时\n})\n\nonDeactivated(() => {\n  // 在从 DOM 上移除、进入缓存\n  // 以及组件卸载时调用\n})\n</script>\n```\n\n## 依赖注入\n\n## 使用组合式API\n### setup()\n`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n\n1. 需要在非单文件组件中使用组合式 API 时。\n2. 需要在基于选项式 API 的组件中使用组合式 API 的代码时。\n\n**其他情况下，都应优先使用\\<script setup>语法。**\n\n```vue\n<script>\nimport { ref } from 'vue'\nexport default {\n    props:{    \n    },\n    setup(props,context) {\n    const count = ref(0)\n    // 通过return返回的变量会暴露给模板和其他的选项式API钩子\n    return {\n      count\n    }\n  },\n</script>\n```\n\n>在模板中访问从 `setup` 返回的 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref) 时，它会[自动浅层解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity)，因此你无须再在模板中为它写 `.value`。当通过 `this` 访问时也会同样如此解包。\n>`setup()` 自身并不含对组件实例的访问权，即在 `setup()` 中访问 `this` 会是 `undefined`。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n### \\<script setup>\n\n* `defineProps()`：声明\n\n# Vue指令\n\n## 动态属性\n```html\n<template>\n<input :[name]='message'/>\n</template>\n\n<script setup>\nconst name='title'\nconst message='helloworld'\n</script>\n```\n\n## v-text\n更新文本内容\n```vue\n<span v-text=\"msg\"></span>\n<!-- 等同于 -->\n<span>{{msg}}</span>\n```\n\n## v-show\n设置内联`display`属性\n\n## v-if/v-else-if/v-else\n可用于`<template>`表示仅包含文本或多个元素的条件块。\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n## v-for\n\nv-for中对**对象**迭代时，最多可使用值，键，索引三个相关变量(顺序固定)\n\n```html\n<script setup>\n    const list={\n        key1:value1,\n        key2:value2\n    }\n</script>\n\n<div v-for=\"(value,key,index) in list\"></div>\n//循环十次\n<div v-for=\"item in 10\"></div>\n```\n\n## v-on\n\n### 修饰符\n```\n事件修饰符:stop,prevent,capture,self,once,passive\nclick:left,right,middle...\nkeydown:enter,tab,delete\n精确修饰符:exact\n```\n\n## v-bind\n\n## v-once\n\n## v-model\n\n```html\n<script setup>\nconst message=[];\n</script>\n<template>\n<input \ntype=\"checkbox\" \nv-model=\"message\" \nvalue=\"VALUE\"\n>\n</template>\n```\n### v-model.lazy\n数据同步减慢，当事件不再被触发的时候再更新数据\n\n### v-model.number\n绑定时进行数据类型转换\n\n### v-model.trim\n去除前后空格\n\n\n\n# TIPS\n\n## auto-scroll\n\n```vue\n<div ref=\"autoScroll\">\n需要滚动的元素    \n</div>\n\n<script setup>\nconst autoScroll = ref(null)\nonMounted(() => {\n    nextTick(() => {\n        let scrollElem = autoScroll.value;\n        scrollElem.scrollTo({ top: scrollElem.scrollHeight, behavior: 'smooth' });\n    });\n});\n</script>\n```\n\n## 动态class\n\n```vue\n<div :class=\"{'class1':true,'class2':false}\">\n    \n</div>\n```\n\n## 获取dom元素并修改style\n\n```vue\n<div ref=\"content\" @click=\"changeStyle\">ABC</div>\n\n<script setup>\nconst content = ref()\nconst changeStyle = () => {\n    content.value.style.color=\"red\";\n}\n</script>\n```\n\n\n\n\n\n# 路由切换/router\n\n","tags":["编程"],"categories":["前端"]},{"title":"Java坦克大战个人总结","url":"/2022/04/29/my-TankWar-conclusion/","content":"\n&emsp;&emsp;刚学完Java，为了巩固所学，做了个坦克大战。这次主要挑战了下自定义地图和敌人寻路两个功能。\n\n<!--more-->\n\n## 自定义地图\n\n自定义地图比较简单，只要将地图作为外部文件读取就可以了。\n\n如这么一个txt文件，W是墙壁，P是玩家起始位置，E是敌人起始位置（可以有多个）：\n\n>WWWWWW\n>WPOOOW\n>WOOOEW\n>WWWWWW\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar.png)\n\n读取文件基本结构：\n\n```Java\n\t String filePath=\"../maps/\"+name+\".txt\";//用String生成文件路径，可以根据传入的name读取不同文件\n        InputStream inputStream=getClass().getResourceAsStream(filePath);\n        int data;\n        try {\n            while((data=inputStream.read())!=-1){//read()返回-1，说明读取完毕\n                char ele=(char)data;//将以整数读取的数据转换为字符\n                ......\n            }\n        }\n```\n\n## 敌人寻路\n&emsp;&emsp;常用的寻路算法有广度优先搜索，A-star算法等等。但这次我还是打算自己挑战一下写一个适合这个程序的算法。~~其实是没学会怎么写~~\n最后经舍友启发，写出了一个虽然不是最优路径，但很简短的寻路算法。\n\n### 核心思路\n从起点开始依次遍历相邻方格，并让它们指向起点的方向（好比单向链表），形象点说就是在所有可以行走的方格画上箭头，指向起点。待所有方格填完，再从**终点**沿着箭头寻回起点，就形成了一条唯一的路径。（最后还要反转一下）\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar2.png)\n\n### 地图存储方式\n对于寻路来说，不需要知道地图的所有信息，只要知道每个方格能否通过就行。\n```Java\n//单个结点\npublic class Node {\n    int Px;\n    int Py;\n    boolean canPass;//是否可以通过（水流，墙壁为无法通过的地形）\n    Node last=null;//用于在寻路算法中形成指向起点的链表\n}\n//用Vector存储结点集合\nVector<Node> nodes=new Vector<Node>();\n//用于获取相邻4个结点中可以通过的方格的方法，在后续寻路时起到重要作用\n    Vector<Node> neighbors(int x,int y){\n        Vector<Node> neighborNodes=new Vector<Node>();\n        for(Node n:nodes){\n            if((n.Px-x==-1||n.Px-x==1)&&(n.Py==y)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n            if((n.Px==x)&&(n.Py-y==-1||n.Py-y==1)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n        }\n        return neighborNodes;\n    }\n```\n\n用Graph类存储所有方格的信息，并提供寻路中要用到的算法：\n```Java\npublic class Graph {\n    Vector<Node> nodes=new Vector<Node>();\n     void setGraph();//根据读取的文件初始化所有方格的信息（略）\n     void clearAll();//使所有node的last=null，以便下一轮寻路（略）\n     Node findNode(int x,int y);//根据坐标找到相应的node（略）\n     void setVector(Node now);//核心算法，给所有方格填上箭头\n     void setRoute(Node start,Node goal,Vector<Node> route);//寻回起点，形成路径\n     Vector<Node> reverseRoute(Vector<Node> route);//反转路径【Vector竟然没提供（略）\n}\n```\n\n### 寻路算法\n\n```Java\nvoid findRoute(){\n    Vector<Node> newRoute=new Vector<Node>();\n    int Tx=MyPanel.player1.p_x;\n    int Ty=MyPanel.player1.p_y;\n    Node start=graph.findNode(p_x,p_y);//自身所在位置\n    Node goal=graph.findNode(Tx,Ty);//目标所在位置\n    graph.setVector(start);//“画箭头”的方法\n    graph.setRoute(start,goal,newRoute);//从终点寻回起点，形成路径\n    route=graph.reverseRoute(newRoute);//反转路径，从起点指向终点\n    graph.clearAll();//清除所有箭头\n}\n```\n### 用递归\"画箭头\"\n\n```Java\nvoid setVector(Node now){\n    for(Node n:neighbors(now.Px,now.Py)){\n    \t//对于now相邻的每个方格n，如果还没有画上箭头，就让n.last=now\n        if(n.last==null){\n            n.last=now;\n            setVector(n);//递归，直到其相邻方格均画上箭头就停止\n        }\n    }\n}\n```\n\n### 从终点寻回起点，形成路径\n```Java\nvoid setRoute(Node start,Node goal,Vector<Node> route){\n    Node now=goal;\n    route.add(now);//将now从终点开始沿着箭头位移，并加入到route\n    while(!now.equals(start)){\n        now=now.last;\n        route.add(now);\n    }\n}\n```\n\n## 多线程能做的事\n&emsp;&emsp;本次坦克大战和飞机大战相比，最大的不同还是用到了多线程。在专业的游戏中，渲染引擎，物理引擎等都是在不同线程下以不同频率工作。相比单线程，更加发挥出了硬件的性能，流畅地运行计算量更大的游戏。\n我在坦克大战中，将每个敌人作为一个线程，同时每个敌人的【攻击判断，移动，路径生成】为单独的线程，路径每隔3秒生成一次，攻击判断和移动间隔为30毫秒。\n将行为包装为抽象类，子类行为只要重写job()和canUse()方法就行\n```Java\n//run()为启用线程时执行的方法，job()为抽象方法，子类须重写\n    public void run(){\n        while(KEY!=0){\n            if(canUse()){\n                job();\n            }\n            try {\n                Thread.sleep(30);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    };\n```\n\n刚刚接触多线程，设计还不到位（比如没有把渲染和物理分离），希望在将来的学习中改进。","tags":["编程","大学生活","游戏","Java"],"categories":["游戏制作"]},{"title":"飞机大战-详细流程","url":"/2022/04/09/my-GameMakingProcess/","content":"\n记录一下详细的流程\n<!--more-->\n\n## easyX库\n\n[easyX](https://easyx.cn/)是针对C++的免费绘图库，在制作飞机大战时，需要用该库中的函数来绘制图像。\n**下载安装该库后，使用时需要包含头文件<graphics.h>**\n下面是一定需要用到的函数：\n\n### initgraph(width,height)\n&emsp;&emsp;用于初始化一个宽为width，高为height的绘图窗口\n&emsp;&emsp;默认不会打开控制台，但如下填入第三个参数，可同时打开控制台，用于调试。\n（比如给一个函数加上cout<<\"success\",检测有没有调用这个函数）\ninitgraph(width,height,EW_SHOWCONSOLE)\n&emsp;&emsp;第三个参数还可以填入其他值，详见[文档](https://docs.easyx.cn/zh-cn/initgraph)\n\n### cleardevice()\n&emsp;&emsp;使用当前背景色（默认为黑）清空绘图窗口。在显示新画面前一般都要调用这个函数\n### loadimage(&img,_T(\"./image.png\"))\n&emsp;&emsp;将图片加载到img(该变量名可以自定义)这个对象上。至少填入两个值，前一个为easyX的IMAGE类的对象（要传入其地址），后一个在引号内填图片的路径\n&emsp;&emsp;IMAGE类是easyX这个库自带的对象，用于保存图片的各种数据。\n&emsp;&emsp;其成员函数getwidth()/getheight()返回图片的宽/高\n&emsp;&emsp;为了在其他电脑上也能正确找到图片地址，路径应使用相对路径\n\n### putimage(x,y,&img)\n将先前加载的图片绘制到窗口上。参数为**图像的左上角在窗口上对应的坐标**\n\n### easyX的坐标系\n需要注意的是，easyX的坐标系默认是以**向右为正，向下为负，以窗口左上角为原点**。且所有图片的定位都是看其左上角对应的坐标。\n绘制图像时，坐标可以为负数或超出窗口的宽高，这样的话会绘制一半在窗口中，或完全不显示在窗口中。（但该图像依然存在）\n\n## 文件的结构\n和以往的作业不同，这是一个较大的项目。一方面，代码里包含了许多的类，另一方面，在程序本身之外还有图像等资源文件（统称为assets）。如果把所有类写在一个文件，改写的时候就非常难找，因此最好尝试把各个类分文件写\n大致这样👇\n\n```\nspacewar//根目录\n\t├── main.cpp\n\t└── player.cpp\n\t└── enemy.cpp\n\t└── images//文件夹，用于存放所有图像文件\n```\n\n在包含另一文件时，有以下两种方法：\n\n>#include <graphics.h> //用尖括号表示优先查找系统文件\n>#include \"player.cpp\" //用引号表示优先从当前文件夹查找，自己写的文件都最好用这个方法\n\n\n## 游戏的架构\n\n### 外层结构\n要想做一个画面实时变化的游戏，就要像视频一样，以人眼难以分辨的频率去不断绘制画面，因此，程序的最简结构如下：\n```C++\nint main()\n{\n\tinitgraph();//初始化绘图窗口\n\tinit各种东西();\n\t//初始化需要用到的所有变量，包括但不限于玩家飞机，敌人系统，分数，道具系统等等\n\twhile(1)\n\t{\n\t\t//游戏的主循环，每一轮循环都要画出所有元素，一次循环为一帧\n\t}\n}\n```\n### 主循环\n\n虽然每个人做的游戏规则不同，但在主循环中，大致要做如下的事情（执行顺序要视情况调整）：\n* 判断玩家，敌人，子弹间的碰撞\n* 按照一定频率生成敌人，道具等\n* 接收玩家输入的操作，并处理结果\n* 绘制玩家，敌人，子弹，分数等元素，同时处理移动\n* 控制帧率\n\n其中控制帧率最简单的方法是在循环的结尾加Sleep()\n```C++\n\tSleep(time);//需要头文件<windows.h>\n\t//time为毫秒，例如time=33.3时，帧率(FPS)为30，即每秒刷新30次画面\n```\n实际上在sleep()前执行函数的时间也要计算，但飞机大战这个规模还没有什么影响，就忽略不计了\n\n### 接收玩家指令的方式\n\n\"\\_kbhit()\"函数在用户按下按键时返回true，否则返回false\n\"\\_getch()\"函数**等待并返回**用户按下按键的ASCII码\n只使用\\_getch()，程序需要等待用户输入按键，也就会导致玩家不动，敌人也不动的现象。\n这里专门给玩家设置一个执行指令的函数，是为了后续能清楚地分清与玩家相关的指令和不相关的指令。\n\n```C++\n\tif (_kbhit())\n\t{\n\t\tchar cmd = _getch();\n\t\tswitch (cmd)\n\t\t{\n\t\t//调用玩家对象的command函数\n\t\tdefault:Player.command(cmd); break;\n\t\t}\n\t}\n```\n\n### 试着先让自己的飞机动起来\n我自己在写的时候也不是一次性就加入敌人，子弹等等内容，先别想那么多，让飞机在窗口上动起来🎵\n\n```C++\nclass player{\nprivate:\n\tint m_x;\n\tint m_y;\n\tint m_speed;\n\tIMAGE m_img;\npublic:\n\tplayer()\n\t{\n\t\t//载入图片\n\t\tloadimage(&m_img, _T(\"./images/player.png\"));\n\t\t//先随便给个值，但注意不要超出窗口大小！\n\t\tm_x=100;\n\t\tm_y=100;\n\t\tm_speed=10;\n\t}\n\tvoid drawPlayer()\n\t{\n\t\t//绘制玩家的函数\n\t\tputimage(m_x, m_y, &m_img,);\n\t}\n\tvoid command(char cmd)\n\t{\n\t\t//执行玩家指令的函数\n\t\tswitch (cmd)\n\t\t{\n\t\t//根据指令让对应坐标+或-速度\n\t\tcase 'w':m_y-= m_speed; break;\n\t\tcase 'a':m_x-= m_speed; break;\n\t\tcase 's':m_y+= m_speed; break;\n\t\tcase 'd':m_x+= m_speed; break;\n\t\t}\n\t}\n```\n将它放到main函数中：\n```C++\nint main()\n{\n\tinitgraph(500,800);\n\tplayer Player;\n\twhile(1)\n\t{\n\t\tcleardevice();\n\t\tPlayer.drawPlayer();\n\t\tif (_kbhit())\n\t\t{\n\t\t\tchar cmd = _getch();\n\t\t\tswitch (cmd)\n\t\t\t{\n\t\t\tdefault:Player.command(cmd); break;\n\t\t\t}\n\t\t}\n\t\tSleep(50);\n\t}\n}\n```\n\n## 设计类\n\n以我的做法，最少需要4个类：玩家，子弹，敌人，敌群\n其中【玩家，敌人，子弹】都有共通的属性：坐标，速度，宽高，因此可以继承自一个Object类。\n**敌群**这个类的作用，在于管理所有的敌人。因为所有的敌人都需要和玩家判断碰撞，并且在超出屏幕时及时删除\n敌群类(enemies)和敌人类(enemy)不同于继承，叫做组合，是“A有B”的关系。\n\n#### object类\nobject基类很简洁，只需要记录几个必要信息，并做所有物体通用的碰撞检测\n```C++\nclass object {\nprotected:\n\tint m_x;//横坐标\n\tint m_y;//纵坐标\n\tint m_width;//图像宽度\n\tint m_height;//图像高度\n\tint m_speed;//速度\n\tint map_width=550;//窗口宽度(用于判断越界)\n\tint map_height=850;//窗口高度\npublic:\n\t//判断碰撞的函数，使用时传入子类指针就行。不用static其实也可以\n\tstatic bool isHit(object* ptr1,object* blt);\n```\n\n※isHit()详见[第一次游戏制作](https://ustb-lzm.gitee.io/ustb-lzm/2022/03/26/my-firstGame/)\n\n#### 敌人类&敌群类\n敌人最少只要object所继承的属性外加一张图片就可以。\n敌群要控制敌人的生成，\n```C++\nclass enemy:public object {\n\tfriend class enemies;//将权限给敌群类\nprivate:\n\tIMAGE m_img;//用于保存敌机图片的IMAGE对象\n\t…………\n}\n\nclass enemies {\n\tint enemyCount;//记录敌人数量(但我并没用到)\n\tint interval;//敌人产生的间隔\npublic:\n\tenemy* ePtr[30] = { 0 };//敌人类指针数组,上限为30个敌人\n\tvoid createEnemy();//生成敌人\n\tvoid drawEnemies();//绘制所有敌人\n\tvoid deleteEnemies();//删除死亡/超出屏幕的敌人\n\tint isEnemiesHit();//给每个敌人判断碰撞\n\tvoid shoot();//如果敌人可以发射子弹，最好在敌群类统一管理（要和玩家判断碰撞）\n```\n\n### 子弹类\n```C++\nclass bullet:public object {\nprivate:\n\tIMAGE m_bullet;\n\tdouble m_angle;//发射角度\npublic:\n\tvoid drawBullet()\n\t{\n\t\tputimage(m_x, m_y, &m_bullet);\n\t\tm_x += m_speed * sin(m_angle);//所有子弹通用的移动，只需确定方向和速度\n\t\tm_y += m_speed * cos(m_angle);//但要注意x和y为整数，角度太细会丢失精度\n\t}\n\tbool isOut();//判断子弹是否超出屏幕\n```\n\n### 玩家类\n```C++\nclass player:public object {\nprivate:\n\tIMAGE m_img;\n\tbullet* m_blt[50] = { 0 };\npublic:\n\tvoid shoot();//发射子弹\n\tvoid command(char cmd);//接收指令\n\tbool judgeOverflow(char cmd);//移动时判断防止超出屏幕\n\tvoid drawPlayerAndBullet();//绘制玩家和子弹\n}\n```","tags":["编程","大学生活","游戏","C++"],"categories":["游戏制作"]},{"title":"第一次游戏制作","url":"/2022/03/26/my-firstGame/","content":"\n&emsp;&emsp;因学校程序设计课的作业要求，第一次游戏制作献给了飞机大战。一开始还嫌麻烦，但基本框架打好之后就得心应手了，开始添加各种元素，比玩游戏还上头🤩三天能交的作业硬是拖了一周。\n&emsp;&emsp;本来还有各种主意想要实现，但再做下去也学不到什么新东西了，就暂且割爱了。\n\n<!--more-->\n\n## 起因\n\n>游戏的编写能用到C++学习过程中的很多知识，数组、函数和面向对象。这个练习是一个开放式的练习，你可以在基本要求的基础上进行任何扩充。\n>游戏编写的基本要求，参看附件。\n>\n>>扩充下游戏1定义的飞机大战游戏的功能：\n>>增加多个界面，初始化界面，说明游戏功能；结束界面，提示用户的得分情况，以及是否开始一个新的游戏；\n>>随着积分的增加，可以考虑增加难度，加快敌机的下落速度，和出现的速度；\n>>功能上做更多的性能处理：例如防止玩家操控飞机飞出边界，击中/碰撞检测的处理\n>>增加按Esc键后游戏暂停的功能\n>>增加图形界面（EasyX,Qt, MFC）以及面向对象的程序设计\n\n>要求：提交完成一定功能或性能扩充后的源代码，以及一个word文档，说明你做的功能完善的目标，设计以及程序实现和测试效果。\n\n虽说是作业，但毕竟是值得纪念的第一作，因此我决定发挥自己目前最大水平做个完整的游戏。\n\n## 游戏下载\n\n※有闲空的可以玩玩看，就是普通的飞机大战。\n（Win10应该能正常运行，Win7没试过）\n\n规则：\n* wasd移动，空格切换子弹类型，q使用道具，esc暂停，道具只能存一个\n* 敌人的血量，频率，移速会随着score增加而增加\n\n>链接：https://pan.baidu.com/s/1iB6d0R82fL6XXXTTvJWdIA \n>提取码：0519\n\n## 游戏制作\n### 绘图库的选择\n&emsp;&emsp;使用的是[EasyX](https://easyx.cn/),在上学期刚入门C++的时候正好用过就沿用了，简单易上手。\n\n### 文件结构\n![image-20220326132332034](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20220326132332034.png)\n图中父子结点表示class的继承关系（右继承左）\n其中（itemSystem--itemBlock),(enemies--enemy)是友元关系\n\n* enemies（敌群）用于初始化敌人的类型，速度等参数，并随着得分情况而改变产生敌人频率。\n* itemSystem作用和enemies相同，控制道具的生成类型和生成频率\n* object父类成员为所有和物体位置相关的变量，以及一个处理碰撞的函数\n* player包含一个bullet指针数组，用于一并管理玩家发出的所有子弹，方便和敌人进行碰撞判断(enemies同理)\n\n### 操作输入结构\n\n这个方法一次只能接收一个指令，无法做到斜方向的丝滑移动。希望在今后的学习中找到改进方案\n```C++\n//判断输入暂停还是玩家操作\nif (_kbhit())\n{\n\tchar cmd = _getch();\n\tswitch (cmd)\n\t{\n\t\tcase 27:systemPause(); break;\n\t\tdefault:p1.command(cmd); break;\n\t}\n}\n```\n\n```C++\n//玩家操作输入（judgeOverflow用于判断玩家是否超出窗口）\nvoid command(char cmd)\n{\n\tswitch (cmd)\n\t{\n\tcase 'w':\n            if (judgeYOverflow(cmd))m_y-= m_speed; break;\n\tcase 'a':\n            if (judgeXOverflow(cmd))m_x-= m_speed; break;\n\tcase 's':\n            if (judgeYOverflow(cmd))m_y+= m_speed; break;\n\tcase 'd':\n            if (judgeXOverflow(cmd))m_x+= m_speed; break;\n\tcase 'q':\n            useItem(); break;\n\tcase ' ':\n            //实现在0~3号子弹发射模式中切换\n            bltType = ((bltType == 3) ? 0 : bltType+1); break;\n\t}\n}\n```\n\n\n### 问题-1 解决运行时闪屏问题\n&emsp;&emsp;在绘制图像过多时，EasyX会出现不定时闪屏问题，为此需要使用批量绘图函数\n详见：https://docs.easyx.cn/zh-cn/BeginBatchDraw\n\n```C++\n\tBeginBatchDraw();\n\twhile(1)\n\t{\n\t\t//各种元素的绘制函数\n\t\tFlushBatchDraw();//将之前绘制的图像一并输出倒窗口上\n\t}\n\tEndBatchDraw();\n```\n\n### 问题-2：对不规则物体判断碰撞\n&emsp;&emsp;常规的判断碰撞就是用两物体的x,y,width,height比较，但由于子弹和飞船形状都不是矩形，使用上述方法会导致判定过于宽松，玩家死都不知道怎么死的🐕。\n\n我的改进方案：\n在常规判断法之外，利用EasyX库中getpixel()扫描子弹即将达到的位置区域内有没有背景色以外的颜色。这样的话就可以把误差减小到子弹的方格(大概3px内)\n\n缺点：\n\n* 因判断条件，背景色不能过多(最终我的背景是双色)。\n* 如果子弹面积过大的话边角误差也较大\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/hitRange.png)\n\n```C++\n\tstatic bool isHit(object* ptr1,object* blt)\n\t{\n\t\tif (ptr1 == 0 || blt == 0)\n\t\t\treturn false;\n\t\tif (ptr1->m_x - blt->m_x > blt->m_width || ptr1->m_x+(ptr1->m_width)<blt->m_x)\n\t\t\treturn false;\n\t\tif (ptr1->m_y - blt->m_y > blt->m_height || ptr1->m_y+(ptr1->m_height)< blt->m_y)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < blt->m_width;i++)\n\t\t{\n\t\t\tfor (int j = 0; j < blt->m_height; j++)\n\t\t\t{\n\t\t\t\tif (getpixel(blt->m_x + i, blt->m_y + j) != BLACK\n                    && getpixel(blt->m_x + i, blt->m_y + j) != 0x000033)\n\t\t\t\t{return true;}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n```\n\n### 问题-3：无法输出透明图片\n&emsp;&emsp;EasyX不支持输出带Alpha通道的png图片，但在游戏进行时会出现很多元素重叠的情况，为了防止图片的黑边挡住下面的图片，需要做透明化处理\n解决方案：利用三元光栅操作，对图片进行位运算\n详见：https://blog.csdn.net/q781634081/article/details/108107639\n```C++\n\t//加载图片\n\tloadimage(&m_img, _T(\"./images/enemy_normal.png\"));\n\tloadimage(&m_alpha, _T(\"./images/enemy__normal_alpha.png\"));\n\t//输出图片\n\tputimage(m_x, m_y, &m_alpha, SRCAND);\n\tputimage(m_x, m_y, &m_img, SRCPAINT);\n```\n\n### 问题-4：窗口大小受系统设置影响，显示不全\n&emsp;&emsp;在打包游戏发给室友测试的时候，发现游戏窗口的大小和预想中的不一样，原因是显示设置中修改了缩放比例。为了在不同缩放比例的电脑上都能正常显示，使用了以下方式。\n\n详见[创建一个不受系统缩放设置（DPI）影响的绘图窗口 - CodeBus](https://codebus.cn/yangw/dpi-awareness)\n\n```C++\n#define WINVER 0x0A00\n#define _WIN32_WINNT 0x0A00\n#include <ShellScalingApi.h>\n#pragma comment(lib, \"Shcore.lib\")\n\nSetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE);  \n```\n\n## 心得\n&emsp;&emsp;生涯第一次制作完整的游戏，还是非常兴奋的。此前一直想学Unity，但作为计算机专业还是要加强底层设计能力。耗时一周，共900多行代码，虽然对我来说算是一次不小的挑战，但跟独立游戏的规模比起来，还是“路漫漫其修远兮，任重而道远。”【By初中物理老师\n&emsp;&emsp;除了代码之外，图像制作也是一大麻烦事，而且技术要求也不低。本次游戏只有爆炸效果有3帧的动画，其他元素都是一图流🏳\n\n","tags":["编程","大学生活","游戏","C++"],"categories":["游戏制作"]},{"title":"数据结构与算法·笔记","url":"/2022/03/19/my-algorithm-note/","content":"\n<b><font color='yellow' size=5>施工中</font></b>\n\n<!--more-->\n\n## 基本技巧\n\n* 判断相等：`abs(a-b) < 1e-9`\n* 判断奇数：`x % 2 != 0`，`x & 0x1`\n\n优先使用`vector`而非动态分配的数组\n\n多维数组：\n\n```c++\nvector<vector<int> > arr(row_num, vector<int>(col_num, 0 ));\n```\n\n使用reverse来避免不必要的重新分配\n\n# 数据结构\n\n## 线性表\n\n### Median of Two Sorted Arrays\n\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/\n\n设寻找的元素为整体的第k个元素\n\n※ 每次删除k/2个元素，减小搜索量\n\n递归终止条件：\n\n* A或B为空时，直接返回B[k-1] 或 A[k-1]\n* k=1，返回min(A[0],B[0])\n* 当A[k/2-1]==B[k/2-1]时，返回该值\n\n*O(log(m+n))*\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n\tconst int m = A.size();\n\tconst int n = B.size();\n\tint total = m + n;\n\tif (total & 0x1)\n\t\treturn find_kth(A.begin(), m, B.begin(), n, total / 2 + 1);\n\telse\n\t\treturn (find_kth(A.begin(), m, B.begin(), n, total / 2)\n+ find_kth(A.begin(), m, B.begin(), n, total / 2 + 1)) / 2.0;\n}\n\nstatic int find_kth(std::vector<int>::const_iterator A, int m,\nstd::vector<int>::const_iterator B, int n, int k) {\n\t//always assume that m is equal or smaller than n\n\tif (m > n) return find_kth(B, n, A, m, k);\n\tif (m == 0) return *(B + k - 1);\n\tif (k == 1) return min(*A, *B);\n\t//divide k into two parts\n\tint ia = min(k / 2, m), ib = k - ia;\n\tif (*(A + ia - 1) < *(B + ib - 1))\n\t\treturn find_kth(A + ia, m - ia, B, n, k - ia);\n\telse if (*(A + ia - 1) > *(B + ib - 1))\n\t\treturn find_kth(A, m, B + ib, n - ib, k - ib);\n\telse\n\t\treturn A[ia - 1];\n}\n```\n\n## 哈希表\n\n### Longest Consecutive Sequence\n\nhttps://leetcode.com/problems/longest-consecutive-sequence/description/\n\n用哈希表`unordered_map<int, bool> used`记录使用的元素\n\n*O(n)*\n\n```c++\nint longestConsecutive(const vector<int> &nums) {\n\tunordered_map<int, bool> used;\n\tfor (auto i : nums) used[i] = false;\n    \n\tint longest = 0;\n\tfor (auto i : nums) {\n        // 如果标记true，说明已经记录到当前最大长度\n\t\tif (used[i]) continue;\n\t\tint length = 1;\n\t\tused[i] = true;\n        \n        // 向两边扩散，标记相邻值的元素，并更新最大长度\n\t\tfor (int j = i + 1; used.find(j) != used.end(); ++j) {\n\t\t\tused[j] = true;\n\t\t\t++length;\n\t\t}\n\t\tfor (int j = i - 1; used.find(j) != used.end(); --j) {\n\t\t\tused[j] = true;\n\t\t\t++length;\n\t\t}\n        \n\t\tlongest = max(longest, length);\n\t}\n\treturn longest;\n}\n```\n\n## 夹逼法\n\n### 3Sum\n\nhttps://leetcode.com/problems/3sum/\n\n*O(max{nlogn, n^k-1^})*\n\n```c++\nvector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> result;\n    if (nums.size() < 3)\n        return result;\n    sort(nums.begin(), nums.end());\n    const int target = 0;\n\t\n    auto last = nums.end();\n    for (auto i = nums.begin(); i < last - 2; ++i) {\n        auto j = i + 1;\n        if (i > nums.begin() && *i == *(i - 1))\n            continue;\n        auto k = last - 1;\n        while (j < k) {\n            if (*i + *j + *k < target) {\n                ++j;\n                while (*j == *(j - 1) && j < k)\n                    ++j;\n            } else if (*i + *j + *k > target) {\n                --k;\n                while (*k == *(k + 1) && j < k)\n                    --k;\n            } else {\n                result.emplace_back(vector<int>{*i, *j, *k});\n                ++j;\n                --k;\n                while (*j == *(j - 1) && *k == *(k + 1) && j < k)\n                    ++j;\n            }\n        }\n    }\n    return result;\n}\n```\n\n### Multimap缓存的4Sum\n\n```c++\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> result;\n    if (nums.size() < 4)\n        return result;\n    sort(nums.begin(), nums.end());\n    unordered_multimap<int, pair<int, int>> cache;\n    for (int i = 0; i + 1 < nums.size(); ++i)\n        for (int j = i + 1; j < nums.size(); ++j)\n            cache.insert(make_pair(nums[i] + nums[j], make_pair(i, j)));\n    for (auto i = cache.begin(); i != cache.end(); ++i) {\n        int x = target - i->first;\n        auto range = cache.equal_range(x);\n        for (auto j = range.first; j != range.second; ++j) {\n            auto a = i->second.first;\n            auto b = i->second.second;\n            auto c = j->second.first;\n            auto d = j->second.second;\n            if (a != c && a != d && b != c && b != d) {\n                vector<int> vec = {nums[a], nums[b], nums[c], nums[d]};\n                sort(vec.begin(), vec.end());\n                result.push_back(vec);\n            }\n        }\n    }\n    sort(result.begin(), result.end());\n    result.erase(unique(result.begin(), result.end()), result.end());\n    return result;\n}\n```\n\n## 高精度加法\n\nhttps://leetcode.com/problems/plus-one/description/\n\n```c++\nvoid add(vector<int>& digits, int digit) {\n    int c = digit; \n    for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n        *it += c;\n        c = *it / 10;\n        *it %= 10;\n    }\n    \n    //超过当前位数，再加一位\n    if (c > 0)\n        digits.insert(digits.begin(), 1);\n}\n```\n\n\n\n## 位运算\n\n### 异或 (exclusive or) —— 相同为0，不同为1(无进位相加)\n性质\n\n>0^N=N;\n\t\t1^N=~N;\n\t\tN^N=0;\n\t\t满足**交换律**，**结合律**\n\n```C++\n//利用异或交换两个变量\t\nvoid swap(int &a,int &b){\n\tif(a==b)\n\treturn;//防止传入参数相同导致抹除数据(N^N=0)\n\ta=a^b;\n\tb=a^b;\n\ta=a^b;\n}\n```\n## 排序\n### 插入排序——O(N^2)\n从第二个数开始，依次和前面的数两两比较，如果大于(或小于)就交换，直到不再大于前面的数就跳到下一轮。\n相比于冒泡排序无论在任何情况下都比较相同次数，插入排序根据情况可以提前进入下一轮，实际速度快于冒泡排序。\n```C++\n\tint length=sizeof(arr)/4;\n\tfor(int i=1;i<length;i++)\n    {\n        int j=i;\n        while(j>0)\n        {\n            if(arr[j]>arr[j-1])\n            swap(arr[j],arr[j-1]);\n            else\n            break;//前面已经排好，就不用再比较了\n            j--;\n        }\n    }\n```\n### 归并排序——O(NlogN)\n\n```C++\nvoid merge(int arr[],int L,int M,int R){\n    int temp[R-L+1]={0};\n    int i=0;\n    int p1=L;\n    int p2=M+1;\n    while(p1<=M && p2<=R)\n    {\n        temp[i++]=(arr[p1]>=arr[p2]?arr[p1++]:arr[p2++]);\n    }\n    while(p1<=M)\n    {\n        temp[i++]=arr[p1++];\n    }\n    while(p2<=R)\n    {\n        temp[i++]=arr[p2++];\n    }\n    int h_length=sizeof(help)/4;\n    for(int j=0;j<h_length;j++)\n    {\n        arr[L+j]=temp[j];\n    }\n}\nvoid process(int arr[],int L,int R){\n    if(L==R)\n    return;\n    int mid=L+((R-L)>>1);\n    process(arr,L,mid);\n    process(arr,mid+1,R);\n    merge(arr,L,mid,R);\n}\n```\n### 快速排序\n```C++\nvoid quickSort(int arr[], int L, int R) {\n    if (L >= R)\n        return;\n    int num = arr[R];\n    int p = L;\n    int Lside = L - 1;\n    int Rside = R + 1;\n    while (p < Rside)\n    {\n        if (arr[p] < num)\n        {\n            swap(arr[p], arr[Lside + 1]);\n            Lside++;\n            p++;\n        }\n        else if (arr[p] == num)\n        {\n            p++;\n        }\n        else if (arr[p] > num)\n        {\n            swap(arr[p], arr[Rside - 1]);\n            Rside--;\n        }\n    }\n    quickSort(arr, L, Lside);\n    quickSort(arr, Rside, R);\n}\n```\n### 堆排序\n\n## 查找\n\n### 二分查找\n\n```c++\nint search(const vector<int>& nums, int target) {\n\tint first = 0, last = nums.size();\n\twhile (first != last) {\n\t\tconst int mid = first+ (last - first) / 2;\n\t\tif (nums[mid] == target)\n\t\t\treturn mid;\n        //修改first，last区间\n\t\tif (nums[first] <= nums[mid]) {\n\t\t\t\tif (nums[first] <= target && target < nums[mid])\n\t\t\t\t\tlast = mid;\n\t\t\t\telse\n\t\t\t\t\tfirst = mid + 1;\n\t\t\t} else {\n\t\t\t\tif (nums[mid] < target && target <= nums[last-1])\n\t\t\t\t\tfirst = mid + 1;\n\t\t\t\telse\n\t\t\t\t\tlast = mid;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n","tags":["编程","C++","算法"],"categories":["程序设计"]},{"title":"unsignedchar的学习","url":"/2022/01/27/my-study-UnsignedChar/","content":"\n实际上是借助容量最小的unsigned char类型学习位运算的应用\n\n<!--more-->\n\n## unsigned char 与 char 的区别\n\nchar的最高位为符号位，而unsigned char无符号位，因此：\n>char：-127~127\n>unsigned char：0~255\n\n## unsigned char 闭环\n当unsigned char取得负数**x**时，其值相当于**(256-|x|)**\n\n例：![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201272027432.png)\n<details>\n<summary>答案</summary>\n<b>10 + 246 = 256, C</b>\n</details>\n\n\n## 将unsigned char作为Flag使用 \n```c++\nunsigned char flags = 0; //共8位,每位表示一个Flag\n//用枚举类型保存至多8个flag\n//（实际情况下每个flag都有具体名称表示）\nenum{\n    Flag1,Flag2,Flag3,Flag4,\n    Flag5,Flag6,Flag7,Flag8,\n};\n//检测某个Flag开闭状态的函数\nbool checkFlag(unsigned char f){\n    //\n    unsigned char t = flags;\n    t >>= f;//相当于t = t/(2^f);\n    t <<= 7;//相当于t*128,如果t为奇数，结果为128，否则为0\n    return (t != 0) ? true : false;\n}\n//开启某个Flag的函数\nvoid setFlag(unsigned char f){\n    flags |= (1 << f);\n}\n//关闭某个Flag的函数\nvoid resetFlag(unsigned char f){\n    flags &= ~(1 << f);\n}\n//验证，输出‘success’\nint main(){\n    setFlag(Flag2);\n    if (checkFlag(Flag2))\n    {\n        cout << \"success\";\n    }\n    else\n        cout << \"failure\";\n}\n\n```\n\n上述代码中，enum型的Flag1~8的值为0~7，为了让它们对应到8bit中的每位，在setFlag()和resetFlag()中要进行位移操作：\n```C++\n1<<f //将1向左移动f位,相当于2^f\n```\n","tags":["编程","C++"],"categories":["程序设计"]},{"title":"程序设计题目——整数分治","url":"/2022/01/15/my-programing-Problem/","content":"\n## 题目\n&emsp;&emsp;程序设计专业课期末考试上的一道题：\n>**输入两个整数n，k，将n划分为k个整数，且每份均不能为0。求共有多少种划分方案**\n>※没有顺序之分，比如对于n=4,k=3,(1,1,2)和(2,1,1)只能算一种方案。\n>输入样例：7 3\n>输出样例：4\n\n当时考试还剩20分钟，本想着绰绰有余，但没带草稿纸而本人又是心算苦手，就直接白给 ~~但最后还是抖机灵把样例输出凑上了~~\n\n<!--more-->\n\n## 思路\n&emsp;&emsp;对于每个数据**n**(n>k)，由于每一份都不能为“0”，所以我们可以首先从**n**中拿出**k**个“1”而不改变结果。假设我要使用 **Func(n,k)** 使其输出答案 **A**，则：\n```\n\tA == Func(n,k) == Func(n-k,k) + S\n```\n&emsp;&emsp;在拿出**k**个“1”后，要注意剩下的 **(n-k)** 是可以分出“0”的，所以在 **Func(n-k,k)** 的基础上还要加一个**S**。\n&emsp;&emsp;而S为：将**n-k**分成**k**份，且其中有**1~(k-1)** 个“0”。\n&emsp;&emsp;由此推出，对于给定的 **n**和**k**，：\n\n```\n\tS == Func(n-k,k-1)+Func(n-k,k-2)+…+Func(n-k,1)\n```\n将第一条等式中的S替换，就可以得出：\n```\n\tA == Func(n,k) == Func(n-k,k)+…+Func(n-k,1)\n```\n到这一步，递推关系已经出来了，接下来是寻找结束条件。\n* 首先不难想到，**k==1**时，**Func(n,1)==1**\n* 其次考虑当**n==k**时，**Func(n,k)==1**\n* 当**n<k**时，**Func(n,k)==0**\n\n## 代码\n```cpp\nint Func(int n, int k)\n{\n    if (k == 1||n == k)\n        return 1;\n    else if (n < k)\n        return 0;\n    else\n    {\n        int sum = 0;\n        n = n - k;\n        while (k >= 1)\n        {\n            sum += Func(n,k); \n            k--;\n        }\n        return sum;\n    }\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    cout << Func(n,k);\n}\n```\n递归题虽然思考过程很痛苦，但看到写出来的代码如此简介还是很爽👍\n","tags":["编程","大学生活","C++","算法","递归"],"categories":["程序设计"]},{"title":"【翻译】大学生为了制作一部游戏而经历的地狱","url":"/2022/01/14/trans-make-game-bymyself/","content":">原文链接：\n>[大学生が自作ゲームを1本作るまでに経験した数々の地獄のお話](https://note.com/dom_cob1/n/n8eaf211cba2b?magazine_key=mcaf9d5648d65)\n>原作者：\n>[Matsumoto](https://note.com/dom_cob1/)\n\n## 译者摘要\n\n这篇文章讲述了一位非科班的大学生从学习编程，到最后制作出一款完整的游戏所经历的种种磨难。从他的回忆中，我能感受到作者满溢的创作热情，其中的许多经验，以及最后的话语也给我莫大的鼓励和启发。\n<!--more-->\n\n## 前言\n初次见面。虽然有些唐突，但各位！\n\n一定也有过“人生至少要做一次游戏制作者！”这样的想法吧。\n\n这篇文章讲述的就是我，从大二开始学习制作游戏，到实际完成所经历的种种地狱。\n\n至于为什么把这件事特意写成文章，在最后会解释。\n\n不限于游戏，如果你正想要开始某些事情，请务必看一看。\n\n## 经济学院的地狱\n常说“如果没有想做的事，就先去大学增加未来的选项”,但我想对高中时的自己说，并不是到了大学就会找到想做的事情。\n\n什么都没考虑就选择了经济学。\n\n课程对我而言很无聊不说，还因为看不起经济学院那群逼王，没有交到朋友，大概有一年没去学校。\n\n在那个时期我开始思考就职的事情，而一看同学的求职方向大多都是银行，证券公司，周围的人就像坏掉的机器人一样一天到晚求职咨询。而且大家比起说是对工作内容感兴趣，嘴上聊的都是年收入和头衔的话题。而我，一边觉得他们扯淡，却也找不到自己想做的事。\n\n从这个时候，我开始思考自己真正想做的事情。\n\n## 编程的地狱\n因为觉得编程就像黑客一样酷炫，我决定学习编程。\n\n因为编程的话题根本不好玩，所以我就不展开来谈了，但大约遇到过5次挫折。\n\n看不懂写着“猫也能看懂”的书而对猫肃然起敬；搞不来环境配置而扬言自己的电脑不适合编程；去向工学院的教授问“安装”是什么意思被批了一通等等。\n\n但我想对接下来要学习编程的所有人说一句话。\n\n**就算完全不懂也没关系，尝试着自己去使用它**\n\n这点非常重要，像考试科目那样“先掌握基础，再去理解整体~”这样的学法对编程是不怎么管用的。\n\n还有就是不要去看推特上的大佬。  \n\n经过一段时间后，我就试着用python做了一个2048。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141420300.png' width=60%></span>\n\n当看到程序按照自己所想的一样运作时，我从中第一次感受到了游戏制作的乐趣。\n\n建议在学编程学完函数和类左右的时候，可以试着自己思考做些程序。\n\n## 从Python转到C++的地狱\n\n因为有人说做游戏的话学C更好，我就开始学习C++。\n\n了解过的人应该知道，C++和Python完全不同。差不多就像Wii Sports的保龄球和真实的保龄球那种程度不同。\n\n开始出现指针，变量声明之类从未接触的术语，而且又败在了环境配置这一步。\n\n编程初学者的最大敌人就是环境配置。具体就不展开说了，但如今我更喜欢易阅读的C++。\n\n## Unity的天堂\n\n就算是没有做过游戏的人，想必也听说过Unity。简而言之就是能做游戏的工具。\n\n第一次接触的时候，得知它能演算重力，判定碰撞等等各种事情，让我非常感动。\n\n在Unity中需要用到C#这门语言，但就算没学过也问题不大，在想要实现某种功能时现查就可以了。\n\n就像先前说过的，“尝试着自己去使用它”。我就在按照书本制作游戏的途中记住了编程的方法。\n\n实际看到自己的角色动起来的时候，真的是很有乐趣。\n\n## 实习的地狱\n\n就在这个时期，我看机会难得，就参加了游戏公司的实习。\n\n因为要进行作品评比，我花了一个月左右，从ddl三天前开始熬夜赶工做出了以下这款游戏。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141437310.png' width=60%></span>\n\n游戏机制什么的都比较单薄，而且说实话比看上去还要不好玩，道具按钮也只是个单纯的按钮。\n但毕竟是独立完成的游戏，就自信满满参加了评比会。\n\n轮到我发表的时候，本来还自信满满的，但被问到有趣在哪里，怎么游玩的时候却几乎答不上来。\n\n轮到下一个人——“这是日本游戏大奖的获奖作品……”\n\n再下一个人——“这是我拿去参加韩国的比赛的作品……”\n\n再下一个人——“这是可以在Wii上运行的……”\n\n差不多到这个时候我就感觉社死了，心情非常消沉，觉得自己完全不是一个水平。\n\n轮到最后一个人——“对不起，看了别人的作品我还是决定不拿出来献丑了……”\n\n正当我为找到同伴而稍微安心的时候，评委说就算这样也可以拿出来看一看。确实作为游戏的完成度还不够，但想法非常有创意。很难具体表达，但我感觉像是能火的有趣作品。\n\n那天以后，我想着自己又没技术，又没创意，全都玩完了，过了一段暴饮暴食的日子。\n\n## 想不出创意的地狱\n后来我的精神又恢复了过来，准备再次挑战的时候，却迟迟没法下手。\n\n以往我只是把角色动起来就很满意了，但这次开始觉得如果不好玩的话做出来也没有意义。\n\n无法忘记在评比会上看到的那些游戏专业学生的作品，或是有足够创意的作品，尤其是那个拿了大奖的作品，我还经常想起来，在油管上反复观看。\n\n那个悲惨时期的我就只能跟朋友吹吹“我跟这样的大佬一起参加过实习”。\n\n只是，多亏实习的失败经历，我查阅了很多GameJam，游戏奖，独立游戏等等相关的资料，并认识了很多优秀的游戏。\n\n然后我想着先不管怎么说要做点东西出来，就把想到的主意逐个做成了demo。\n以下是我废弃的辣鸡游戏，追悼。\n\n* 边躲避激光边搬运武器的游戏\n* 移动箭头对战的游戏\n* 数字俄罗斯方块（想法还可以就是没能做出来）\n* 把战车和洗车混合的游戏<font color='gray'>(※日文中战车和洗车发音相同)</font>\n* 通过预知能力躲避攻击的游戏\n* 在自动扶梯上逆行的游戏\n* 让电梯恰好停住的游戏\n* 很多隐藏砖块的坑人游戏\n* 不容易被敌人干掉的游戏\n* 血条和蓝条共用的游戏\n* 改变角色大小的游戏\n* 立体停车场（没想好要怎么玩）\n* 屏幕画面之外非常乱的游戏\n* 变成虫子诱导人（已经有了）\n\n像这样做了很多游戏，虽然大部分都不是很有趣。但是！！最后有两个游戏存活了下来。\n* 关卡会旋转的游戏\n* 和透明的敌人战斗，然后重播后观看自己动作的游戏\n它们会在后文提到。\n\n## 编程的地狱 Part2\n既然做不出创意，就用编程能力一决胜负吧！然而，从结果来看就是我的错觉。在技术上取胜是世界第一难事。\n\n但总之，不能全部依赖引擎！要自己写出重力和画面！！！这么想着，我买了一本书——《在成为游戏工程师之前应该记住的技术》。\n\n真的是地狱。\n\n看了书之后我才发现自己至今的编程都只是图一乐。\n\n必须在完全理解了指针，继承，二进制等等才能看得进去。\n\n现在来看，那个时期学的知识都有很大的帮助，但我也不希望萌新看了这本书而被劝退。\n不过对于学编程比较轻松的人来说，我还是非常推荐这本书。\n\n顺便一提，我因为实在是搞不懂，至少敲了100次桌子，还在阳台大喊“谁tm搞这个”，也因为太过挫败深夜骑自行车去金阁寺，在推特上发过“我真是一无是处”，在麦当劳暴饮暴食吃胖了15kg。\n\n## 自制游戏的地狱\n好不容易看了书，事实后该不用引擎制作游戏了！这么想着，我完成了“关卡会旋转的游戏”。\n别看只有“完成了”这么三个字，过程是真的累死累活。当遇到报错的时候，那个波浪线总是划在不是我写的代码的地方（标准库），让我完全不知道哪里出了错。\n\n就好像是迷路的时候看一眼手机发现导航显示自己在大海上一样。\n\n这样的事情一天至少要发生10次。\n\n或许大佬不同，但我的话至少有70%左右的时间花在了寻找出错原因上面。\n\n这段时间又因为真的搞不懂而经历了暴饮暴食，去银阁寺的路上迷路，无所事事地改改字体大小等等。\n\n结果就完成了这么个游戏。\n\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141716419.jpg' width=60%></span>\n\n图画是朋友帮忙画的，右下角的猫是玩家。\n\n虽然我写的都是怎么怎么受挫，但一旦不用引擎完成了自制游戏，那成就感是非同一般的。\n比如，从菜单到关卡选择的迁移方式都需要自己考虑，还自制了保存制成的关卡名的时候的文本框。\n\n一边怀疑自己是不是走偏了，一边又用谁也想不到的方法制作，运行成功的时候，我是发自内心感到兴奋的。\n\n我真是天才！！（然后30分钟后因为各种报错而崩溃)\n\n可惜最后还是有判定奇怪等种种问题，没能达到发行的质量。\n\n## 虚幻引擎的天国\n\n具体时间有些搞不清了，但我偶然看到这个视频，大受感动，开始使用虚幻引擎。\n\n>[虚幻5技术演示(B站)](https://www.bilibili.com/video/BV1Y5411s7Sa)\n\n就算现在再看也让我起鸡皮疙瘩，让我觉得“可以亲手创造这样美丽而充满激情的世界吗！”\n然后我就回想起纯粹制作游戏的感觉，开始学习虚幻引擎。\n\n虚幻引擎不需要任何编程就可以做游戏，利用一种叫蓝图的可视化脚本语言，让角色动起来，或是制作机关。顺便一提，我用它制作的游戏也一次都没有写代码。\n\n然后我就想，和之前不同，既然用了引擎就一定要做出有趣的游戏，把技术力抛在脑后，一个劲打磨游戏的趣味性。\n\n就在这时，我想到了“和透明的敌人战斗，然后重播后观看自己动作的游戏”，因为重播自己的动作很有趣，从而想到制作一款把自己的动作倒放，然后和倒放的自己合作的游戏。\n\n## 自制游戏的地狱 Part2\n\n虽然写着地狱，但和先前的游戏制作比起来，这次的经历绝对是最让我快乐的。\n\n一方面是自己对这个游戏的有趣程度有自信，一方面是由于引擎而让想法的实现变得简单了。\n但也有一些比较心累的地方：\n\n1. 看到推特上的大佬会无法避免地产生自卑感\n2. 存档和包装等为了游戏发行而不得不考虑的事情\n\n第一点想必对哪个领域都一样。真正厉害的人是真的厉害，不去看他们更好。写Qiita<font color='gray'>(日本一个工程师论坛)</font>的人也都是天才。他们的人生估计已经五周目了，一周目的我就满怀感激地接受教导吧。\n\n第二点应该是大多数人受挫的原因。同样是做游戏，随意制作的人和完整地制作一部的人是完全不同的。就像做意大利面也有买酱回来做的人和从酱开始做的人。除了包装之外，我也考虑了美工和建模等等问题。\n\n即便如此，这也是真的很快乐的事情。\n\n**不用去学会所有的东西**\n\n**只要查阅自己创作所需要的就行**\n\n**制作自己认为有趣的东西**\n\n**想象着自己的游戏大卖然后出名**\n\n以上这些应该就是感到快乐的原因。关于游戏的设计，我也看了不少制作人的演讲，游戏分析博主的视频等等，还疯狂拜托别人去试玩。\n\n## 开始怀疑是否有趣的地狱\n中途开始患上了担心这个游戏实际上没意思的病。不过后来知道这种情况在游戏开发者身上是常有的。\n当时问了朋友们对试玩版的感想，大家可能是比较善良，都说很好玩。我就坚信他们的话坚持了下来。\n顺便一提其中有一个朋友因为太过热衷而把大学考试全翘掉了，学科全挂。\n爱死你了！经济学院！\n\n## 游戏被别人玩的天国\n历经坎坷，游戏终于在steam上公开了试玩版，推特上的宣传也被转发了3742次！当时太过开心，给试玩的朋友门疯狂打电话。\n<font color='gray'>（※游戏名【Relash】steam上可以看到商店界面）</font>\n\n## 想说的话\n在刚刚接触游戏制作时，我觉得那些爆火的都是天选的人。但实际上到现在，我也依然边抱怨搞不懂边做着游戏。\n\n我写这篇文章，就是想让那些今后想要制作游戏的人意识到，“原来大家都会受挫折”，“做出没有意思的作品也是理所当然的”。\n\n我在开始制作游戏时，最想知道的，就是**不知道也没关系**。\n\n就是因为不知道这点，我好几次都差点放弃制作游戏。\n\n我还只是完成了一款游戏，但因为不想被别的开发者认为是在装逼，所以我会马上就说我并不厉害。\n\n但这正是在过去让我痛苦的话语。\n\n因为那些比我厉害的人，摆着一副这种程度理所应当的表情，所以才会觉得“是我不适合”。\n\n正因如此我才要勇敢地说出来，我能制作一款完整的游戏，是一件很厉害的事情，但更多地，是一件非常吃力的事情，充满了未知的事情。\n\n所以我才希望今后想要制作游戏的人意识到**不知道也没关系**，以“做出来就很厉害！”的心态去面对。\n以上就是我制作一款游戏所经历的种种地狱。\n\n## 笔记\n>肩書き(かたがき)：头衔，官衔\n>殆ど(ほとんど)：几乎\n> 垢(あか)：污垢，油泥\n> 遷移(せんい)：变迁，迁移\n> ダントツ：压倒性地出众，领先\n> 語呂合わせ(ごろあわせ)： 双关，谐音\n> 別格(べっかく)：特别处理，特殊待遇\n","tags":["游戏"],"categories":["游戏制作","翻译"]},{"title":"【翻译】古川本铺-聊聊作词的方法","url":"/2022/01/14/trans-hurukawa-lyric/","content":">原文链接：\n>https://sp.uta-net.com/today/news.php?id=12288\n>原作者：\n>古川本铺\n\n## 译者摘要\n古川本铺是我最喜欢的音乐创作者之一，在舒适的旋律之外，他的歌词也总是充满文艺，清新的色彩。本篇文章来自Uta-Net，日本的音乐资讯网站，讲述了古川本人创作歌词的过程。\n<!--more-->\n\n## 正文\n&emsp;&emsp;新年好，我是古川。\n&emsp;&emsp;从去年时隔六年复出，到现在也有一年了。创立个人事务所后打拼至今，还是手忙脚乱的状态。\n&emsp;&emsp;去年11月末，我发行了复出后的第三首曲子[「Ordinaries feat.古川亮」](https://www.bilibili.com/video/BV1X44y1a7f9)。关于歌词，以往我都以让它在乐曲的世界里完结为理想，但大概从这首曲子开始，我逐渐会去思考“如何让歌词和日常生活有所关联”。这首歌在我的作品中也是非常独特新颖的一首，请一定听听看。\n&emsp;&emsp;那么，今天既然是歌词随笔，我就聊一聊我平时作词时的方法和小技巧。\n&emsp;&emsp;作词首先要从确保词曲对应的舒适开始。\n<font color='gray'>※这里原词是**譜割り**，是在歌曲创作中把歌词细分到音符的行为，没找到中文对应的术语，还请谅解</font>\n比如，无论如何都需要4个音符(字)的歌词，却强行填入三个字。\n>⭕おにぎり(饭团，o ni gi ri)\n>❌うどおん(乌冬，原本是 u do n，此处填成：u do o n)\n\n&emsp;&emsp;你可能会吐槽什么鬼歌词，但只是举个例子。这个时候如果一定要用うどん(乌冬)这个词，就必须强行拉长元音以对应音符，但通常在作词过程中我会尽量避免这种情况出现。\n&emsp;&emsp;话虽如此，也不是说从一开始就要考虑这个问题，实际创作过程也没有那么顺利。因此，我的作词过程有一定程度的模式化，并且总是先作曲，再作词。\n1. 先作曲到能进行部分弹唱为止。\n2. 用既不是英文也不是日语的谜之语言弹唱录音。\n3. 挑选出弹唱过程中有意义的单词和句子。\n4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n5. 修改文章，使其能够对应音符。\n6. 尝试用有特色的词句插入或替换。\n7. 加入感叹号、句号等，让歌词更像文章。\n8. 再弹唱，录音，如果没有违和感就OK。\n9. 第二天重新听一遍，然后弃用。\n\n&emsp;&emsp;理想是不达到⑨完成创作，但现实没有这么简单。\n&emsp;&emsp;在上述工序中比较重要的是③。在用比较随便的词句反复哼唱旋律的过程中，总会有那么一两个词跟旋律非常搭配。我把它当成是**歌曲在呼唤的文字**，并从此衍生出整个歌词。所以我通常不会定下主题或对象开始创作。\n\n---\n\n### 1. 先作曲到能进行部分弹唱为止。\n不用说也知道，创作歌词不是写诗，如果最后不成曲调就没有意义。所以首先要确定旋律，到能唱的状态。不过最终可能会优先歌词而改变旋律。\n\n### 2. 用既不是英文也不是日语的谜之语言弹唱录音。\n&emsp;&emsp;这个阶段，我认为用什么语言其实无所谓，最优先的是作为歌词发音的舒适程度。\n&emsp;&emsp;偶尔会有人说英语歌词比较逊，但我想告诉作词者的是，这种意见全部可以无视掉。只是，如果一段歌词能统一语言的话，节奏会更舒适。\n\n### 3. 挑选出弹唱过程中有意义的单词和句子。\n&emsp;&emsp;如果没有做到这点就从1重新开始。实在找不出的话，就弃用。\n\n### 4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n&emsp;&emsp;如果在这个阶段考虑音符的对应，我就感觉会变成所谓“平庸的歌词”。这道工序应该是形成世界观的过程，但我并不是很喜欢“世界观”这个用法，所以也不会特别在意这方面的好坏。我比较关注的是曲子的气氛和文章的气氛是否一致。\n\n### 5. 修改文章，使其能够对应音符。\n&emsp;&emsp;这个过程我做的比较机械，主要是检查字数是否吻合音符，有没有强行延长元音，等等。\n\n### 6. 尝试用有特色的词句插入或替换。\n&emsp;&emsp;这是给歌词添加个性的重要环节，因此我在这个部分会花比较多的时间。比如在「Ordinaries」中，既有“溜息を燃やす”这样的表达，也会刻意加入“ブラリと歩いた”这样比较土的词句。如果让听众在读词的时候感到“哦？”，或者“哦！”就是我的胜利。\n\n### 7. 加入感叹号、句号等，让歌词更像文章。\n&emsp;&emsp;这是我个人特色的部分，也是我每次作词必做的环节。加句号是为了确认歌词是否作为文章产生美感，加感叹号是为了表现出歌曲不足以表达完整的那部分情感。\n&emsp;&emsp;可能也有人认为只用音乐表现就可以了，但在我心中，歌词有歌词，乐曲有乐曲的表现领域，而这两者不一定需要完全一致，也可以从不同的角度表达出深意。\n\n### 8. 再弹唱，录音，如果没有违和感就OK。\n&emsp;&emsp;本来在这一步还会制作**歌词卡**，但因为只是个人兴趣所以不展开谈了。只是检查一下歌词作为文章排版之后是否够帅。至于有什么好坏标准，我自己也不是很清楚。\n\n### 9. 第二天重新听一遍，然后弃用。\n&emsp;&emsp;80%的作品都是这个结局。我会努力不走到这一步。\n\n---\n\n&emsp;&emsp;古川的歌词就是通过上述的方法创作的。要点在于，不是先**决定想要表现的内容**，而是**给想要表现的事物创造轮廓**。\n&emsp;&emsp;在此之后，我会一边思考它究竟适合表现什么事物，一边进行修正，添加。\n&emsp;&emsp;这次，在11月发行的曲子「Ordinaries」表现的是“日常”。并不是像“平凡的日常也非常美丽”这样含蓄的话题，而是说**“今天是普通的，普通的一天”**，仅此而已的曲子。很难说它是美丽或者无趣，但看来至少不是糟糕的一天。我希望这首曲子能为这样的日子增添一抹光亮。\n\n## 笔记\n>段取り：计划，方法\n>手合い(てあい)：小子，家伙/对局/种类\n>お蔵(おくら)：电影戏剧等停止公映，或事物不再使用\n>省く(はぶく)：省略，减去\n","tags":["音乐","古川本铺"],"categories":["翻译"]},{"title":"【翻译】拓宽版面设计的视角","url":"/2022/01/13/trans-LayoutDesign/","content":"\n>原文链接：\n>[レイアウトデザインの視点を増やす 思考＆Tips](https://note.com/harahiroshi/n/n3af079dc17e9)\n>原作者：\n>[ハラヒロシ](https://note.com/harahiroshi/)\n\n## 译者摘要\n本文面向入门设计者，用了图例和很多比喻，生动形象地介绍了布局排版，留白处理的技巧。\n在上一篇文章中，我把“情報”照搬成情报，而后认为翻译成信息更合适，因此在这篇文章中全部采用了后者。\n\n<!--more-->\n\n## 形似水流\n&emsp;&emsp;在布局的时候，通常先决定信息的优先级，再用板块面积区分主次。光到这一步，还只是单纯地堆在一起，而没有流动感。为了让视线能平滑地浏览内容，在创造留白的时候可以想象河流的感觉。\n![picture_pc_519942b46e253091dc646bfcf05c209d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131539348.jpg)\n\n<details>\n<summary>原文</summary>\n<b>川の流れのように</b>\n<p>レイアウトするにあたっては、情報の優先順位を決めてそれをボリュームで割り当てるのが基本です。ただし、これだけだと単に積み重ねているだけで流れが悪いので、視線が滑らかに移動するように“川の流れ”を意識して余白を作っていきます。流れが明確であれば、左右入れ替えてもOKです。\n</details>\n\n## 画面要有纵深感\n&emsp;&emsp;网页虽然只是一个平面，但也和实景一样，人们通常会先识别最吸引眼球的地方，再按顺序获取信息。作为设计者，必须有意识地利用这点去调整画面的纵深。\n&emsp;&emsp;在下面的例子中，文字标题和橙色的方块是最抢眼的，然后再是绿色区域，蓝色区域。所以并不是说全都从上往下排列就ok了。\n&emsp;&emsp;刚上手的时候，思路可能容易局限于单纯地将元素上下堆积。内容之间的关联，视线的动向，下一步的响应都考虑到的同时，从纵深，左右，时间等多重角度审视设计，就可以拓宽思路。\n![picture_pc_d2eb1880b7c33ee76cd1ffeb82a2e56a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131603983.jpg)\n\n<details>\n<summary>原文</summary>\n<b>画面には「奥行き」がある</b>\n<p>webは画面という「平面」に対してだいたい同じ距離感で見るものですが、実は景色と同じで、誘目性の高いものから認識し、順を追って情報を得ていきます。つまりそこには「奥行き」があります。\n<br>作り手としてはそれを意識し、利用しながら、画面から離れたり近づいたりしながらデザインを調整していくことが大事です。\n<p>以下の例では、文字とともにその下のオレンジ色が誘目性が高く、次に緑、青と順を追って認識していきます。決して「上から順に」配置していけばいいというわけではありませんね。\n<p>最初のうちは上下にブロックを積みあげていくだけの思考に留まってしまう場合が多いです。コンテンツの関係性や視線の流れ、次へのアクションなどをしっかりおさえつつ、奥行き、左右、時間…という複数の重なりの視点を持つとそこから抜け出せると思います。\n</details>\n\n## “通风透气”\n&emsp;&emsp;留白可以诱导视线，让用户注意力转向设计者期望的内容。在布局的时候，不是将元素填入空间，而是通过制作留白让画面“通风透气”。要点在于，制造一条通道，让气流能刚好触碰到重要的信息。\n以下的例子中，如果用户的视线跟着留白走，就能自然地注意到文字内容。\n![picture_pc_0adf0b12355d3a0c60b166110560dc00](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131611974.jpg)\n&emsp;&emsp;要想验证是否做到有效的视线诱导，可以试着在自己的设计上画箭头，如果画箭头的时候感到犹豫，就可以说没有起到很好的诱导效果。\n![picture_pc_df8185ba06f7e71cc1de7c63a66954f5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131613870.jpg)\n\n<details>\n<summary>原文</summary>\n<b>空気の流れを良くする</b>\n<p>「余白」は視線誘導し、意図した情報に注目させることに利用できます。レイアウトするとき、要素をスペースに埋めようとするのではなく、余白を作って「風通しよく」してあげます。ポイントは、逃げ道をつくり、重要な情報を空気の流れに触れさせてあげること。余白がなく、息が詰まるな、と思ったら空気の流れがしっかり通っているかチェックするとよいでしょう。\n<p>以下は、余白を追っていくとコピーが自然と視界に入ってくるレイアウト例です。\n<p>なお、ちゃんと視線誘導できているかは、自分のデザインに矢印を描きこんでみるとよいです。矢印に迷いがあれば、誘導が上手くいっていないといえます。\n</details>\n\n## 从树干衍生出枝叶\n&emsp;&emsp;就拿刚才的素材，这次将关注点从留白转向构图。在布局的时候，要决定一条轴线。扎实的轴线可以增强可读性，也可以在引入变化时不让整体垮掉\n![picture_pc_9a28de0112cc45b698575e7f97b26591](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131655643.jpg)\n&emsp;&emsp;要点在于把轴线当成树干，像衍生出旁支一样布局。（轴线可以不在画面中心)在枝叶上可以自由变换。\n\n<details>\n<summary>原文</summary>\n<b>「木の幹」を意識して枝を作っていく</b>\n<p>では同じ素材で、今度は「余白」ではなく「図」に目を向けてみましょう。レイアウトするとき「軸」を決めます。軸がしっかりしていると読みやすいし、崩しを入れても破綻しにくいのです。\n<p>ポイントは「木の幹」を意識して枝を作っていくことです（軸は真ん中でなくてもよいです）。枝で変化つけると自由さが広がります。\n</details>\n\n## 重心意识\n&emsp;&emsp;进行有动向的布局时，需要有重心意识。以对角线作为辅助线就一目了然。通过调整元素的大小和位置，让重心不偏向画面的一边，就可以平衡地布局。\n![picture_pc_e7811a7a4d67d790ecc87bd05be51a17](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131702816.jpg)\n\n<details>\n<summary>原文</summary>\n<b>重心を意識する</b>\n<p>上下・左右に要素を散らすなど、動きのあるレイアウトを行うときは「重心」を意識することが重要です。その際、対角線などの補助線を描くとわかりやすいです。重心がどちらかに傾かないようにオブジェクトのサイズと位置を調整するとバランスよく配置できます。\n</details>\n\n## 布局要整齐划一\n&emsp;&emsp;**对齐**是设计的四大原则之一，但通常在设计中会要引入**变化**和**强调**，以吸引用户的注意力。但这个变化必须建立在保持协调之上，设计者应该牢记先整齐布局后再加入变化。\n![picture_pc_0a13a8c3767ee3bf1db201fc5603def5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131731290.jpg)\n\n<details>\n<summary>原文</summary>\n<b>レイアウトは整理整頓</b>\n<p>デザイン四原則には「整列」がありますが、それだけだと注意を引きつけられない場合があるので「変化」「強調」という引っかかりをつける必要があります。ただし、その変化は、あくまでも調和を守ったうえでのことです。調和の中でしか変化は成り立ちません。まずはしっかりと整理整頓したうえで、変化をつけるように心がけたいものです。\n</details>\n\n## 检验分组好坏的技巧\n&emsp;&emsp;当担心分组恰当与否时，可以采取模糊全图，看看期望的分组是否形成一个整体。\n![picture_pc_0eda9846d1b9f6bf79685cbe5c0a625d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131745255.png)\n\n<details>\n<summary>原文</summary>\n<b>グルーピングを確認するためのTips</b>\n<p>整列に関連して。グルーピングがうまくいっているか迷ったときは、全体をぼかしてみて、意図したグループが塊として見えるかどうかを試してみるとよいです。\n</details>\n\n## 从正反两面观察\n&emsp;&emsp;对于难以制造留白的场合，试着调换留白和信息所占的区域。通过这个方法，可以更清楚地捕捉留白的形状，从而判断留白究竟是杂乱的还是协调的。要点在于能否同时从正反两种视角去调整。\n\n![picture_pc_ea7c171d1905b0e31e46373735059369](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131813323.jpg)\n\n<details>\n<summary>原文</summary>\n<b>ポジとネガで見てみる</b>\n<p>余白つくるのが苦手な場合は、ポジとネガの視点切り替えを意識するとよいです。ネガ（余白）の形をしっかり捉えてみると、ネガとの対比でポジ（図）が見えていることや、余白がバラバラになっていることなどに気づけます。ポジとネガ、両方見てコントロールできるかがポイントです。\n</details>\n\n## 地平线的位置\n&emsp;&emsp;有时在叠加背景和图像时会拉一条地平线，而地平线的位置也会改变整体的印象。\n![picture_pc_d9b0d3264d28589dabe43c913a7186d4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131818593.png)\n左：图像与背景重叠部分较多，体现安定感，一体感。\n中：地平线在图像下方，使图像突出，更有动感。\n右：让背景渐变，加强纵深感。\n\n<details>\n<summary>原文</summary>\n<b>地平線をどこに引くか</b>\n<p>図と背景を重ねるときの「地平線」を引くことがあると思いますが、その地平線の位置で随分印象は変わります。安定させるか、動きを感じさせたいか、なじませたいか、など。相手の視点を決める重要なポイントです。\n<p>上のほう：図と背景の重なりが多い分、安定感、一体感があります\n<br>下のほう：逆に関わりが薄くなる分、不安定となり動きを感じます\n<br>グラデーションを引くと馴染んで、奥行きを感じさせるレイアウトになります。\n</details>\n\n## 点，线，面\n&emsp;&emsp;在需要体现出叙事性，或强弱区分的时候，可以将分散的点排布到轨迹上，构造动作或流向。\n\n![picture_pc_dccfb3714b3f0665908d90c378196831](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132002194.png)\n\n<details>\n<summary>原文</summary>\n<b>点、線、面に展開していく</b>\n<p>ストーリー性を出したい場合や強弱を意識する際に、バラバラの点を軌跡に並べて動きや流れを作り、ひとつひとつの大小つけて大きなものは面にし、変化や奥行きを出します。webの場合、手前と奥、上下、左右の流れをうまく活用したいですね。\n</details>\n\n## 俯瞰全体\n&emsp;&emsp;网页通常在纵向较长，但同一时刻只有一部分会展示在显示屏上。为了保障用户在滚动网页的过程中的观感，需要俯瞰网页整体的设计。\n&emsp;&emsp;这是我自己过去做的案例，有意识地连成一体的设计比较多。交互，交叉，重叠，突出，反复，等等，要考虑怎样让网页能够有序，有节奏地连续呈现。\n![picture_pc_75e7292ef3e7335a5a7dee406a5e1d9b](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132009352.jpg)\n\n<details>\n<summary>原文</summary>\n<b>俯瞰してみて、リズムがあるかどうかを確認する</b>\n<p>Webサイトは縦に長くても、視界に入るのは画面の面積のごく一部。しかし、スクロールしていく中で心地よく見せられるかどうか、それには俯瞰の視点も必要です。デザイン全体をみたときに美しくレイアウトされているかはチェックしたほうがいいでしょう。\n<p>自身の過去案件の事例ですが、「ひとつながり」を意識することが多いです。交互、交差、重なり、押し出し、繰り返し…など。ページ全体を見たときに、どうやってリズムよく、秩序を保ちながら連続的に見せるかを考えます。\n</details>\n\n## 结语\n&emsp;&emsp;通过效仿设计原则，就可以做出表面上优美的设计，但是如果没有属于自己的美的标准，就很难对其认定。像上文提到的一样，拓宽视角去审视设计，我认为也对启发自身美的标准有所帮助。\n&emsp;&emsp;多设计，多欣赏，在积累经验的途中就会逐渐对美的基准有手感。如果能在绘制一个单纯的矩形时感受到美，那就最好不过了。\n\n<details>\n<summary>原文</summary>\n<b>さいごに</b>\n<p>「デザインの原則」で語られる「美しさ」は真似すれば表面上は会得できるますが、やはり自分の中に「美しさ」の基準がないとなかなか定着しないと思います。その基準は、この記事でまとめたような「見方」にヒントがあるでしょう。\n<p>たくさんデザインして、いいものを見て、経験を積むことで「これが基準」の手応えを感じられるようになるはずです。ただ一つの矩形を描く手の感覚の中に「美しい」を感じられたら最高だな、と思うのです。\n</details>\n\n## 笔记\n\n>* 奥行き(おくゆき)：纵深，进深\n>* 木の幹(きのみき)：树木的茎\n>* 破綻(はたん)：失败，破裂，破产\n>* 際立つ(きわだつ)：显著，突出\n\n","tags":["设计"],"categories":["翻译"]},{"title":"【翻译】设计留白","url":"/2022/01/12/trans-WhiteSpaceDesign/","content":">原文链接：\n>https://note.com/toffy_bon/n/na73bb66846a2#OJ1BV\n>https://note.com/toffy_bon/n/n38475f161c31\n>原作者：\n>[assassin@Web屋](https://note.com/toffy_bon/)\n\n## 译者摘要\n本文面向入门设计者，简明扼要地介绍了留白的概念，作用，和部分应用场景。\n<!--more-->\n\n## 何为留白\n\n“留白”顾名思义就是空白的空间，英文又称WhiteSpace或NegativeSpace。乍一看可能会觉得它起不到任何作用，但留白绝不等同于多余的空间。留白是在设计中非常重要的元素，通过让其起到应有的作用，可以提高设计档次，改善用户体验。\n\n<details>\n<summary>原文</summary>\n<b>「余白」とはなにか。</b>\n<p>「余白」とは文字通り「空白のスペース」のことで、ホワイト・スペースやネガティブ・スペースとも呼ばれたりします。\n一見すると、何の役割も成さないものと捉えがちですが、「余白」＝「余分な空間」では決してありません。「余白」はデザインにおいて重要な要素であり、しっかり意味や役割を持たせてあげることで、デザインをグッと良くしてくれたり、UXの向上に一役買ってくれたりします。\n</details>\n\n## 设计师的一项重要任务\n\n“不让用户感到压力的设计” 是设计师的任务之一，而用户主要的压力因素如下：\n\n* 难以阅读\n* 难以理解\n* 看着会感到疲劳，烦乱\n* 难以找到想要的情报\n* 难以使用\n……etc.  \n除此之外，根据实际情况会有各种各样的因素，但通过适当地引入留白，可以有效缓和，甚至消解上述压力。\n\n<details>\n<summary>原文</summary>\n<b>デザイナーにとっての重要なミッション</b>\n<p>この大きなテーマの一つとして、「ユーザーにストレスを感じさせないデザインをすること」が挙げられると思います。<p>考えられるユーザーの主なストレス要因は以下の通りです。\n<br>・読みづらい\n<br>・分かりづらい\n<br>・見ていると疲れる（ざわざわする）\n<br>・目的の情報がなかなか見つからない\n<br>・使いづらい<br>…などなど。\n<p>他にもシチュエーションによって様々な要因があると思いますが、余白を上手くデザインに取り入れることで、これらのストレス要因を解消してくれたり、緩和する力を持っています。\n</details>\n\n## 留白的效果和职责\n留白的主要效果和职责大致分为五项。\n* 缓和情报间的干涉\n* 对情报进行分组\n* 层次体现\n* 诱导视线\n* 给用户留下特定的印象  \n\n<details>\n<summary>原文</summary>\n<b>「余白」の効果と役割</b>\n<p>先ず肝心なのは、余白の効果と役割について理解しておくことです。\n<p>余白の主な効果と役割は、大きく分けて5つあります。\n<br>・情報の干渉緩和\n<br>・情報の区分け（グルーピング）\n<br>・階層表現\n<br>・視線誘導\n<br>・印象操作\n</details>\n\n### 1.缓和情报间的干涉\n\n可以加强文字情报的可读性，或刻意孤立重要情报，起到强调作用。![picture_pc_8c188bf741c0f521a474f4a26635e9fc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130801361.png)\n图中举了两个例子。  \n\n图右通过在区块内添加适度的留白，消除了**拥挤感**，给人清爽的印象。\n\n![picture_pc_4d8f6abb7f3bb979c737d4cf462f167a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130808625.png)\n除此之外，行间距也是留白的一种，尤其在文字情报中需要注意。\n\n通常行间距是字体大小的1.5~1.6倍，但近年来也有网站采用2倍左右的宽松行距。虽然相同范围内的情报量减少了，但行距的宽松也给整体设计带来了宽裕舒适感。\n\n<details>\n<summary>原文</summary>\n<b>１．情報の干渉緩和</b>\n<p>コンテンツ内の文字情報を読みやすく（可読性向上）したり、または重要な情報をあえて孤立させて強調させたりすることが出来ます。\n<p>上に例を２つ挙げました。\n<br>どちらが「見やすい」と感じるでしょうか。\n<br>右下はブロック内に適度な余白が設けられていることで、「窮<br>屈さ」が無くなり、スッキリした印象になっていると思います。\n<p>また、「行間」も「余白」の一つです。\n<br>文字情報は特に注意が必要で、一般的な行間はフォントサイズの1.5～1.6倍程度と言われていますが、近年では、2倍程度までゆったり行間を取っているサイトも多く見かけます。同範囲内の情報量は減ってしまいますが、行間にゆとりを持たせると、デザインにも「ゆとり」が生まれるのです。\n</details>\n\n### 对情报进行分组\n\n通过适度的间隔，可以明确情报间的从属关系。\n![picture_pc_065874a10a1b4d75dc032103685d99e2](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130823526.png)\n\n乍一看左右两图都有整齐的感觉，但实际在读取情报的时候，图左的标题和文章内容的位置区分显得有些模糊。相比之下，图右中标题与文章内容就一目了然。\n\n<details>\n<summary>原文</summary>\n<b>２．情報の区分け（グルーピング）</b>\n<p>間隔を適度に取ることで、情報がどこに属するのか明確にしてくれます。\n<p>上の例を見比べてみてください。\n<p>一見すると、どちらも整っているように感じるかも知れませんが、情報を読み取ろうとしたとき、左上はタイトルと文章の位置付けが曖昧だと感じないでしょうか。対して右下は、どれがタイトルでどれがタイトルに属する文章なのかが、すぐに把握できるのではないかと思います。\n</details>\n\n### 层次体现\n\n当情报之间有嵌套关系，通过使用缩进可以清楚地表现层次。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130831718.png'></span>\n\n需要注意的是，使用缩进的时候不能半半拉拉。至少要缩进一个字距左右，让人一眼就能看出的程度，否则用户在阅读的时候反而会产生没有对齐的不适感。\n\n<details>\n<summary>原文</summary>\n<b>３．階層表現</b>\n<p>情報が入れ子になっているものは、インデントを使うことで階層を分かりやすく表現してくれます。\n<p>良く見かける例がこれですね。\n<p>この階層表現を使うことで、情報整理にもなります。\n<br>ただ、インデントで余白を取る時は、中途半端は禁物です。最低一文字分くらい、パッと見で分かる程度の余白を持たせておかないと、ユーザーが見たとき、逆に「ズレている？」と見られ兼ねませんので、ご注意を。\n</details>\n\n### 诱导视线\n通过在纵向采取更多的留白，可以起到诱导视线的作用。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130840369.png'></span>\n\n大多数人在看到上图时，视线应该是从左向右，Z型移动。\n\n如果图片间的留白没有规律，用户的视线就会犹疑。在某些随机展览的网站中可能不限于此，但如果希望用户按照顺序阅读，这个手法就显得尤为重要。\n\n<details>\n<summary>原文</summary>\n<b>４．視線誘導</b>\n<p>「前へ」「次へ」「下へ」「上へ」や、横より縦の余白を多く取ることも視線誘導の一つです。\n<p>上のような画面を見たとき、視線はどのように動くでしょうか。\n<br>恐らく多くは左から右へ、Z型に移動していくものと思います。\nこの余白の取り方がバラバラだと、視線は迷い、自由に画面を見ようとします。ランダムなギャラリーサイトのような例においてはこの限りではありませんが、一般的にはユーザーに順序正しく見せたいのであれば、この手法は鉄則と言えると思います。\n</details>\n\n### 给用户留下特定的印象\n\n使用留白，可以制造高级感，宁静感，实惠感，繁华感等印象。\n![picture_pc_4a8c8e615e7acd8dc1aa5d57d4a0b4f8](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130853272.png)\n\n为画像准备的空间也是留白的一种。\n\n使用较多留白，可以体现高级感，宁静感，清爽感。而采取较少的留白可以体现紧迫感或实惠感。\n因此，有关酒店或奢华商品，会多采取留白，而促销广告，或网络商场等需要成列大量商品时，会使用较窄的留白。\n\n<details>\n<summary>原文</summary>\n<b>５．印象操作</b>\n<p>余白を上手に扱うことで、「高級感」「静けさ」「お得感」「賑やかさ」などの印象を持たせてくれます。\n<p>上に挙げたサイトは一例です。\n<br>ちなみに、画像に設ける空間も「余白」です。\n<br>余白を多く取っているものは、「高級感」や「清潔感」「静けさ」などが演出できます。逆に取らずにレイアウトすると「緊迫感」や「お得感」「賑やかさ」などが演出できます。\nなので、ホテルやラグジュアリーな商材を取り扱う場合は余白を多く取り、特売の広告媒体やインターネットモールなど多くの商品を取り扱う場合は、余白を狭くレイアウトすることで有効な訴求ができるかも知れません。\n</details>\n\n## 应用留白\n\n在设计之前，**充分理解内容**显得尤为重要。面向的用户群体，产品的种类，情报说明的对象等等，都应把握到位。  \n\n<details>\n<summary>原文</summary>\n<b>余白を上手に扱うコツ</b>\n<p>まずはじめにデザインを行う前提として、「コンテンツを十分に理解すること」がとても重要になります。どんなユーザーに向けた、どんなクリエイティブ（制作物）なのか、この情報はどれに対する説明なのか…など、内容をしっかり把握しておきましょう。\n<p>「土台」が理解できていなければ、良いものは生まれません。\n</details>\n\n### 1.了解适合的留白量\n\n如同前面提到的一样，留白有着制造印象的作用。虽然具体情况要具体分析，但基本可以按照以下思路进行\n![picture_pc_eaaab23be1d54ebaf1a80a1112b8b275](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130926768.png)\n<font color='gray'>从左到右分别是：电商·情报网站；博客，画廊；企业网站；品牌网站</font>\n\n需要注意的是情报量。情报量和留白量基本呈反比例，例如电子商务平台（淘宝，京东等）需要一次性展示大量商品，如果采取大量留白，会导致商品界面的页数大涨，用户也难以找到心怡的产品，影响销售额。\n\n而品牌网站需要将少量商品的魅力完整地展现出来，如果采用较少留白，虽然能一次性展示更多的情报，但难以给用户留下深刻的印象。\n\n<details>\n<summary>原文</summary>\n<b>ポイント１：適切な余白量の目安を知る</b>\n<p>余白にクリエイティブの印象を左右する効果があるのは、前半でもお話した通りです。そのものの背景によって断言できない部分もありますが、基本的には以下のような考え方で分類できます。\n<p>チェックすべきポイントは「情報量」です。\n<br>情報量と余白の割合は反比例しており、情報が多いほど余白は小さく、情報が少ないほど余白を大きく取るのが効果的と言われています。\n<p>たとえばウェブサイトを例に挙げるとすると、膨大な商品数を扱うECサイトと、高級ブランドの公式サイトを見比べるとどうでしょうか？\n<p>全く余白の取り方が違っていると思います。\n<p>想像してみてください。\n<p>もし、これが真逆の状態になったら、どのようになるでしょう。\n<p>ECサイトの場合は、余白が大きくなることで一度に閲覧できる商品数が減ってしまい、そのぶんサイト全体のページ数も更に膨れ上がり、ユーザーが目的の商品を見付けにくくなったりと、売上げにも影響を及ぼしかねません。\n<p>ブランディングサイトなどの場合は、余白が小さくなることで一度に閲覧できる情報量は増えますが、本来伝えたいイメージがユーザー側に伝わりにくくなったり、商品の魅力が損なわれることすらあるのです。\n</details>\n\n### 2.对各部分的留白设定规则\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130945808.png)\n\n上图中，将相同规则的留白用相同颜色做了标记。  \n\n像这样，对同属性的元素制定统一的规则，不光美观，还能让用户产生安心感。\n![picture_pc_d6184179795c17511a43c77501254abb](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951631.png)\n\n反过来，就算只相差几个像素，或者只有一处的留白不同，也会很明显地让用户感到混乱，违和。\n![picture_pc_4742ef42919cc939f6c8d1cb5b91f437](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951323.png)\n\n通过调整其中的规则，也可以像前面提到的一样发挥视线诱导的效果，使内容之间产生阅读顺序。\n\n<details>\n<summary>原文</summary>\n<b>ポイント２：セグメント内の余白にルールを設ける</b>\n<p>上の図は、同じルールで配置された余白を色分けしたものです。（テキストが英文のため、左右の余白が違って見えてしまっていますが…；）\n<p>分かりやすく少し大袈裟な例を挙げてみましたが、たとえこれが数pxの違いだったり、1箇所だけ余白の取り方が違っているだけでも、ユーザーを混乱させてしまったり、意外に違和感を覚えるものです。見た目にもまとまりがないだけでなく、見ている側のストレス要因にもなります。\n<br>このルールを調整すると、前半でもお話した通り、視線誘導の効果が発揮され、コンテンツの見方に順序が生まれるわけです。\n<p>数px単位でも印象は微妙に変わって来ますので、デザインを俯瞰で眺めてみると気付くことが多いと思います。\n</details>\n\n### 3.片段中的留白要有层次\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131001801.png)\n\n\n通过使内侧的留白比外侧的留白小，整体布局会显得更加清楚。就像俄罗斯套娃一样，把一个内容块想象成一个盒子。如果里盒的留白和外盒一样，或更多，就会丧失平衡感。\n\n<details>\n<summary>原文</summary>\n<b>ポイント３：セグメント内の余白は入れ子にする</b>\n<p>基本的に、内側は外側の余白より小さくすることで、全体的にまとまりが出てスッキリしたレイアウトになります。マトリョーシカのような要領で、各コンテンツブロックを１つの箱として考えてみましょう。\n<br>内ブロックの余白が外ブロックと同じ、または外ブロックより大きかったりすると、アンバランスで、見ている側は何だか落ち着かない（ざわざわした）気持ちになるものです。\n</details>\n\n### 思考内容和留白之间的关系\n![picture_pc_cd1383153dd33cf247bbcd55fbd04da4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131007174.png)\n\n左右两边的内容完全相同，但第一眼看过去，通常图左会把“Sweets”看作图片的标题，而图右会把它看作文章的标题。\n\n元素之间距离越近，越能体现从属关系。因此如果希望“Sweets”和图片分为一组，就让它们之间的间距减小，而与下方文章的间距增大就行，反之亦然。在上图中，无论采取哪种都可，但根据具体内容，有些情况下其中一种会是更优解。\n\n![picture_pc_534608440f345b0583c71615176e28dc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131021666.png)\n<font color='gray'>标题是“多彩的甜点”</font>\n\n在改变标题内容后，图左的布局就更合适了。因为图像和“多彩的甜点”搭配更自然，而与文章内容的关联不大。\n\n<details>\n<summary>原文</summary>\n<b>ポイント4：内容と余白の関係を意識する</b>\n<p>上の２つをパッと見たとき、どのように読み取ったでしょうか。\nどちらも内容は同じですが、左は「Sweets」が画像のタイトル、右は<br>文章のタイトルに見えたのではないかと思います。\n<p>これは前半でお話した「情報の区分け（グルーピング）」効果に属しますが、違いは余白の取り方にあります。距離が近い方に属しているように見えるので、画像とセットで見せたければ、画像間の余白を小さくし文章との余白を大きく、文章とセットで見せたければ、逆にするだけで良いのです。\n<br>なので、内容によって「余白のあり方」は変わってきます。\n<p>さて、テキスト情報を変更してみました。\n<br>どちらの余白の取り方が適切だと思いますか？\n<br>答えは左です。この場合「カラフルなスイーツ」の文言は、画像に所属させる方が自然です。文章寄りにしてしまうと、本文内容と噛み合わずチグハグな印象を与えてしまいます。\n</details>\n\n## 总结\n设计的基础遵循[格式塔组织原则](https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%A1%94%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99/10544754)。\n\n设计没有正确答案，正因为如此，设计师自身在制作中要有明确的意向。当被问到“为什么这么设计”时，如果能明确地说出理由，就能提高产品设计的说服力。留白的应用很难一概而论，但如果你之前没有过多留意，不妨根据上面的介绍实践一下。\n\n<details>\n<summary>原文</summary>\n<b>まとめ</b>\n<p>いかがでしたか。\n<br>デザインのイロハはゲシュタルトの法則に基づいています。\n<p>デザインに正解はありません。だからこそ、デザイナー自身がしっかりとした意向を持って制作に取り組むことが重要です。「なぜこうしたの？」と聞かれたら、明確に理由を説明できるとクリエイティブの説得力も増します。余白の取り方はデザインによって変わりますので一概には言えませんが、「今まで特に意識したことなかった」という方は、前半と後半でご紹介したポイントを念頭において、ぜひ実践してみてください。\n</details>\n\n## 笔记\n>* 一役買う(ひとやく かう)：主动承担任务，主动帮助\n>* 挙げる(あげる)：逮捕/举行/**举例**/扬名/尽力\n>* ゆとり：宽裕，余地\n>* 入れ子(いれこ)：套盒，套匣\n>* 賑やか(にぎやか)：热闹，繁华\n>* 設ける(もうける)：准备，设立\n>* ラグジュアリー(luxury)：奢华的，豪华的\n>* 商材(しょうざい)：商品\n>* ECサイト(electronic commerce)：电子商务平台\n>* コーポレートサイト(corporate website)：企业网站\n>* ブランディングサイト(branding website)：品牌网站\n>* セグメント(segment)：切片，部分，程序段\n>* ちぐはぐ：不配对，不协调，龃龉\n>* 基づく(もとづく)：根据，按照\n\n","tags":["设计"],"categories":["翻译"]},{"title":"网站图标","url":"/2022/01/12/my-AvatarIcon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121316093.png\" width=40%>\n</span>\n<!--more-->\n\n\n初版是在小学4年级左右的时候设计的，长这个样子👇\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121141859.jpg\" width=60%>\n</span>\n还取了个名字叫**魔鬼的讴歌**🙈（中二爆棚）\n\n之前正愁博客logo用什么好的时候突然想起来，就直接用了，所以其实没什么内涵💦\n\n","tags":["设计"],"categories":["个人作品","平面设计"]},{"title":"欢迎光临🎉","url":"/2022/01/11/my-first-blog/","content":"\n## 📃Intro\n2021级大学本科生，计算机科学专业。此前在QQ空间写一些感想，但是感觉发挥受限，也不好排版和整理。于是趁大一时间充裕，建了一个博客用来记录我的学习成果和思考。\n\n<!--more-->\n\n## 🎮兴趣\n* 音乐：J-POP听的比较多，沉迷于Vaundy。\n\n    [#古川本铺]()  [#真夜中]()  [#夜鹿]()  [#匹老板]()  [#Vaundy]()  [#KingGnu]()\n* 番剧：虽然是老二次元，但看番比较挑，很多经典都没看过。心中的神作是三月的狮子。（但是不出续集💔\n\n    [#三月的狮子]()  [#Sonny Boy]()  [#扳机社]()  [#冰菓]()  [#春物]()\n* 游戏：手游端游主机各种类型都玩。\n\n    [#Hades]()  [#Jonathan Blow]()  [#传说之下]() [#神之天平]()\n\n* 电影：了解的不是很多，兴致来了就看。\n\n    [#韦斯·安德森]()  [#汤浅政明]() \n\n* 书：卡尔维诺，神。\n\t[#卡尔维诺]()  [#毛姆]()  [#塞林格]() \n\n最近开始有目的地去欣赏作品，提高审美，欢迎朋友们推荐🙏。\n\n## 💡个人能力\n终极目标是做独立游戏，所以各方面都在努力中，大学期间主要以提高编程能力为主。\n\n大一上学期给班级做了班徽，班服设计，个人参加了学院的明信片设计大赛拿了三等奖。还做了个微电影的导演和后期，虽然很喜欢做视频，但作为非影视专业未来也不打算再接触这些了。\n\n从大一下学期自学Vue3，现已熟练网页编写，能还原主流的UI界面和交互功能。在一次Web应用项目中使用过Websocket，对其前后端通信有一定了解。\n\n在参加比赛项目时制作过安卓app，在小组担任UI设计和前端界面（用uni-app编写）。\n\n2023年7月通过N1考试，178/180分。\n\n## 📫联系方式\n* QQ：499061152\n* Bilibili：[@神秘的哇哇](https://space.bilibili.com/1394852578)\n"},{"title":"年末总结——2021","url":"/2021/12/31/conclusion-2021/","content":"2021，无论是对我，还是对我的同学们来说想必都是意义重大的一年。\n<!--more-->\n大学里也有乱七八糟的事务和浪费时间的水课，但至少我们有了选择的权利。可以选择放下冗杂的一切去钻研自己所热爱的，也可以发挥江苏学生的应试能力，杀出一条保研道路。\n\n## 来到大学觉得比较香的地方\n\n首先是食堂，总体价钱和初高中差不多，更不必说还有烤腿饭这种神的存在。（不过感觉没高中那么耐吃😭怀念芝士焗饭）\n\n然后是图书馆。从宿舍走路5分钟就能到。虽然装修得像个仓库一样，但藏书还是相当齐全。座位和研修室的预约管理系统也很完善，很抢手，不过井井有条。👍\n\n还有本学期加了两个技术社团，培训了一学期，学到了一些课外的知识，也认识了很多优秀学长。\n\n## 今年的收获\n\n看网课把C++，java，Js，html和css入了个门，本来想两个月学会web前端但发现想多了，现在处于知识非常零散的状态😫（其实就是屁都不会)希望利用寒假能把它融会贯通。\n\n参加了学院的明信片设计，班徽班服设计，宿舍风采，微电影制作，还有摇篮杯这几个比赛，有的拿了不错的名次，有的不是我一人能决定结果，有的主办方拉垮，但总的来说还行，也得到了同学们的肯定。👌\n\n因为一些原因开始时隔多年写“空间非主流文案”🐷虽然有些羞耻，实际写起来发现是个整理思绪的好方法。\n\n今年想通了很多事情，但随着思考深入，也更加意识到自己的不足。我不追星，但也不禁会仰望那些在舞台发光的人，也免不了为自己太过遥远的理想焦虑。💦\n>做不了天才，那就大器晚成。\n\n2022，请多指教。(^^ゞ\n","tags":["大学生活"],"categories":["总结","年末总结"]},{"title":"【The Witness】","url":"/2021/12/12/game-The-Witness/","content":"\n起初，它们只是有着固定规则的符号，只是一个个死的谜题。\n<!--more-->\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120987.jpeg)\n\n有些谜题很难，能卡我好几天。有些谜题需要先去其他区域，掌握新的规则再做。\n有些谜题，我用上了手机摄像头的彩色滤镜，或是录视频后逐帧播放，才能破解。\n还有圆柱上的，树荫下的，映在水里的谜题，我一笔一画将它铺开来，呈现在纸上才能破解。\n花了16小时，破解400多道谜题后，我以为的终点却只是把我带回起点。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120536.jpeg)\n\n然后我才发现，这不是充满谜题的世界，而是谜题组成的世界。\n是生起第一把火，点亮第一盏灯的人，他们眼里的世界。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120069.jpeg)\n","tags":["Jonathan Blow","游戏","感想"],"categories":["游戏鉴赏","解谜"]},{"title":"班徽设计","url":"/2021/10/26/my-class-icon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121648261.jpg\" width=60%>\n</span>\n<!--more-->\n据同学说黑底背景更有感觉\n但现在看右下角那缺了一块好不爽ヾ(≧へ≦)〃\n\n## 弃用方案：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121651470.png\" width=60%>\n</span>\n只有一个8实在是太单调了（说不定可以用在球服？）\n\n\n\n## 中途版本：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121709946.png\" width=60%>\n</span>\n一开始那个“计”放在头顶上像是要寄了x，后来做成表盘就不那么容易联想🐕\n\n","tags":["大学生活","设计"],"categories":["个人作品","平面设计"]}]