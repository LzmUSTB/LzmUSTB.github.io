[{"title":"Vue路由","url":"/2022/09/27/Vue3-vue-router/","content":"\n# Vue-router\n\n>通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。\n\n## 安装\n\nVue需要4.0以上版本的vue-router\n```sh\n//在vue应用根目录中：\nnpm install vue-router\n```\n\n## 配置路由\n\n### ./router/index.js\n\n```javascript\nimport {createRouter,createWebHashHistory} from 'vue-router'\n\nconst routes=[\n    {\n        path: '/',\n        component: ()=>import('../views/Main.vue'),\n        redirect:'/home',\n        children:[\n            {\n                 path:'/home',\n                 name:'home',\n                 component: ()=>import('../views/home/Home.vue')\n            }\n        ]\n    }\n]\n//创建路由实例\nconst router = createRouter({\n    history: createWebHashHistory(),\n    routes\n})\nexport default router\n```\n\n### ./main.js\n\n```javascript\nimport { createApp } from 'vue'\nimport router from './router'\nimport App from './App.vue'\ncreateApp(App)\n.use(router);\n.mount('#app')\n```\n","tags":["编程"],"categories":["前端"]},{"title":"Vue指令","url":"/2022/09/25/Vue3-Commands/","content":"\n# Vuecommand\n<!--more-->\n----\n## v-text\n更新文本内容\n```vue\n<span v-text=\"msg\"></span>\n<!-- 等同于 -->\n<span>{{msg}}</span>\n```\n\n## v-show\n设置内联`display`属性\n\n## v-if/v-else-if/v-else\n可用于`<template>`表示仅包含文本或多个元素的条件块。\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n## v-for\n进行列表渲染\n## v-on\n\n## v-bind\n","tags":["编程"],"categories":["前端"]},{"title":"Vue-组合式API","url":"/2022/09/25/Vue3-Composition-API/","content":"\n-----\n\n使用函数而不是声明选项的方式书写Vue组件\n\n包括响应式API，生命周期钩子，依赖注入\n\n----\n\n<!--more-->\n\n## 组合式API的优势\n更灵活地组织代码，让逻辑相关的代码能够集中在一处\n>组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着**你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践**。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。\n\n----\n\n## 响应式API\n\n### 理解响应性\n[Vue的解释](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#what-is-reactivity)\n> 响应性是可以声明式地处理变化的编程范式，使一个对象发生变化时，与其相关联的对象也能随之发生变化。\n\n响应式对象： Vue 能够跟踪，访问，修改其属性的对象，实际是JavaScript Proxy。\n\n### 定义响应式变量-reactive()\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n```\n#### reactive()规则\n* Proxy和原始对象并非全等，因此使用Vue 的响应式系统应**仅使用你声明对象的代理版本**。\n\n* 已存在的代理对象传入`reactive()`会返回该代理本身。\n\n* 同一个对象传入`reactive()`总是会返回同一个代理对象。\n\n* `reactive()`对原始数据类型无效。\n\n* 将`reactive()`响应式对象解构或传入函数时，失去响应性连接。\n\n* 当一个变量多次接受`reactive()`返回的代理对象，旧的响应式连接会丢失。\n\n```javascript\n  let state = reactive({ count: 0 })\n  // 上面的 ({ count: 0 }) 将不再被追踪\n  state = reactive({ count: 1 })\n```\n### 定义响应式变量-ref()\n`ref()`可以创建任何值类型的响应式，且传给函数或是从一般对象上被解构时，不会丢失响应性，可用于将逻辑提取到 [组合函数](https://cn.vuejs.org/guide/reusability/composables.html) 中\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\nconst object = {foo:ref(1)}\n//ref()将创建一个带value属性的对象\n//count={value:0}\n//count.value=0\n</script>\n```\n\n当ref是模板渲染上下文的顶层属性或文本插值计算的最终值时将自动解包\n```vue\n<template>\n<!-- ↓解包，结果为：0 -->\n{{ count }}\n<!-- ↓解包，结果为：1 -->\n{{object.foo}}\n<!-- ↓不解包，结果为：[object Object]1 -->\n{{object.foo+1}}\n</template>\n```\n\n[ref在响应式对象中的解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref-unwrapping-in-reactive-objects)（略）\n\n### 计算属性\n`computed()`方法接收一个getter函数，并返回一个计算属性**ref**，与一般ref用法类似。计算属性会自动追踪响应式依赖并随之变化。\n\n```javascript\n//setup内\nimport {computed} from 'vue'\nlet number = ref(1);\nlet sign = computed(()=>{\n    return number>0?'plus':'minus'\n});\n```\n与直接调用方法相比，计算属性会有**缓存**功能，只要其响应式依赖不改变，计算属性就会立即返回先前的结果而不重复计算。\n&emsp;&emsp;<font color='#aaa'>※计算函数不应进行计算以外的作用(如更改DOM或做异步请求)</font>\n\n----\n\n## 生命周期钩子\n以下API全部在`setup()`阶段被调用\n\n```vue\n<script setup>\nimport { onActivated, onDeactivated } from 'vue'\n\nonActivated(() => {\n  // 调用时机为首次挂载\n  // 以及每次从缓存中被重新插入时\n})\n\nonDeactivated(() => {\n  // 在从 DOM 上移除、进入缓存\n  // 以及组件卸载时调用\n})\n</script>\n```\n\n----\n## 依赖注入\n----\n## 使用组合式API\n### setup()\n`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n\n1. 需要在非单文件组件中使用组合式 API 时。\n2. 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。\n\n**其他情况下，都应优先使用\\<script setup>语法。**\n\n```vue\n<script>\nimport { ref } from 'vue'\nexport default {\n    props:{    \n    },\n    setup(props,context) {\n    const count = ref(0)\n    // 通过return返回的变量会暴露给模板和其他的选项式API钩子\n    return {\n      count\n    }\n  },\n</script>\n```\n\n>在模板中访问从 `setup` 返回的 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref) 时，它会[自动浅层解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity)，因此你无须再在模板中为它写 `.value`。当通过 `this` 访问时也会同样如此解包。\n>`setup()` 自身并不含对组件实例的访问权，即在 `setup()` 中访问 `this` 会是 `undefined`。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n### \\<script setup>\n\n* `defineProps()`：声明\n","tags":["编程"],"categories":["前端"]},{"title":"Vue单文件组件","url":"/2022/09/25/Vue3-Single-File-Component/","content":"# Single-File Component\n\n----\n\n> **前端开发的关注点不是完全基于文件类型分离的**。在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。\n\n<!--more-->\n\n将一个Vue组件的模板(html)，逻辑(javascript)，样式(css)封装在单个文件`*.vue`中。\n\n每个文件都由三种顶层语言模块构成：`<template>` `<style>` `<script>` \n\n-----\n## \\<template>\n\n* 每个 `*.vue` 文件最多包含一个`<template>`，模块中可以\n\n----\n\n\n## \\<style>\n* 每个 `*.vue` 文件可以包含**多个** `<style>` 标签。\n\n### \\<style scoped>\n​\t\t带有`scoped`属性的style标签值会影响当前组件内的元素。\n\n```html\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\">hi</div>\n</template>\n-----↓↓↓通过 PostCSS 将内容转化↓↓↓-----\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n​\t\t※子组件的根元素只有**一个**时<font color=#aaa>(`<template>`内的最外层元素)</font>会附带父组件的`data-v-hash`，同时被父组件的样式和子组件的样式影响。\n​\t\t**当子组件和父组件有同名class的选择器时，父组件样式会覆盖子组件样式**。\n​\t\t子组件设置`inheritAttrs`为`false`，非`props`属性不会应用到子组件根元素上。但父组件使用标签选择器时，子组件样式依然被影响。\n\n#### 选择器\n* `:deep()`\n* `:slotted()`\n* `:global()`\n* **小心递归组件中的后代选择器**！对于一个使用了 `.a .b` 选择器的样式规则来说，如果匹配到 `.a` 的元素包含了一个递归的子组件，那么所有的在那个子组件中的 `.b` 都会匹配到这条样式规则。\n\n### \\<style module>\n编译为CSS Modules([暂略](https://cn.vuejs.org/api/sfc-css-features.html#css-modules))\n\n### v-bind()\n\n```html\n<script>\nexport default {\n  data() {\n    return {\n      color: 'red'\n    }\n  }\n}\n</script>\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n自定义属性会通过内联样式的方式应用到组件的根元素上，并且在源值变更的时候响应式地更新\n\n### 预处理器\n[暂略](https://cn.vuejs.org/api/sfc-spec.html#pre-processors)\n\n----\n## \\<script>\n\n* 每个 `*.vue` 文件最多可以包含一个`<script>`和 `<script setup>`\n\n### 构成\n```html\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n```\n\n### export\n`export`用于导出单文件组件的**选项对象**，以便在其他组件中用`import`引入。`export default`导出为一整个模块，`export`可以分别命名导出的模块。一个js中只能由一个`export default`，但可以有多个`export`。\n\nmain.js在构造根组件时，如果根组件包含其他子组件，那么Vue会通过引入的**选项对象**构造对应的组件。\n\n----\n## 组件使用\n\n### 注册子组件\n\n```html\n<script setup>\n//注册子组件，可在模板中任意使用\nimport ChildComponent from './ChildComponent.vue'\n</script>\n<template>\n\t<ChildComponent />\n\t<ChildComponent />\n</template>\n```\n\n每个组件都是独立的实例，维护独立的属性。\n\n### 组件参数-Props\n* 通过Props属性，子组件可以从父组件接收参数。\n* 当使用对象形式声明props时，值为该prop预期类型的构造函数。该方法可以在prop传入错误类型时抛出警告。\n* 可以用一个`const`变量取接收`defineProps()`返回的对象\n* 所有prop都是可选的，除非声明`required:true`\n* 未传递的prop默认值为`undefined`或Boolean则为`false`\n\n```html\n<!--子组件中-->\n<script setup>\ndefineProps(['title'])\n    <!--或者-->\ndefineProps({\n  title: String,\n  propA: {\n    type: Object,\n    required: true\n    //自定义类型校验\n    validator(value){\n      return { message: 'hello' }\n    }\n  }\n})\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n  </div>\n</template>\n\n<!--父组件中-->\n<div>\n  <BlogPost title=\"Why Vue is so fun\" />\n  <!--也可通过v-bind传递变量-->\n  <BlogPost :title=\"post.title\" />\n  <!--批量传入Props(post对象包含所有props)-->\n  <BlogPost v-bind=\"post\" />\n</div>\n```\n\n所有的 props 都遵循着**单向绑定**原则，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值\n\n<font color=#b00>※prop在子组件中是只读的，当你尝试修改时，vue会抛出警告</font>\n\n>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。\n>\n>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在大多数场景下，子组件应该**抛出一个事件**来通知父组件做出改变。\n\n### 组件事件-Emits\n* 通过Emits属性，子组件可以从父组件接收事件，并且这些事件可从子组件抛出。\n\n```html\n<!--子组件中-->\n<script setup>   \ndefineEmits(['enlarge-text'])\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n\n<!--父组件中-->\n<div :style=\"{ fontSize : postFontSize +'em' }\">\n  <BlogPost title=\"Why Vue is so fun\" @enlarge-text=\"postFontSize += 0.1\"/>\n</div>\n```\n\n#### 事件参数&事件校验\n[略](https://cn.vuejs.org/guide/components/events.html#event-arguments)\n\n\n### 插槽-slot\n通过slot，父组件可以向子组件传递元素，从而在子组件中完成渲染。\n\n※插槽的内容无法访问到子组件的状态\n\n```html\n<!--父组件中-->\n<AlertBox>\n  Something bad happened.\n</AlertBox>\n\n<!--子组件中,slot部分会被父组件传入的元素取代-->\n<template>\n  <div class=\"alert-box\">\n    <slot>可在此填入默认内容</slot>\n  </div>\n</template>\n```\n\n#### 具名插槽\n\n带 `name` 属性的插槽被称为具名插槽 (named slots)，未提供`name`则隐式地命名为“default”。\n```html\n<!--子组件中-->\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n</div>\n\n<!--父组件中-->\n<BaseLayout>\n  <template v-slot:header>\n  <!--或简写-->\n  <template #header>\n  <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n#### 作用域插槽\n[略](https://cn.vuejs.org/guide/components/slots.html#scoped-slots)\n\n### 动态切换组件\n通过`component`元素和`is`属性可以实现动态组件，`is`的值可以是**被注册的组件名**或**导入的组件对象**。一般情况下，被切换的组件会被销毁。在下次切换回该组件时，会创建一个初始状态的新实例。\n\n通过`<KeepAlive>`内置组件包装动态组件，可以缓存被切换的组件。\n\n可选属性：\n\n* `max`：限制被缓存的数量\n* `include/exclude`：可以筛选需要缓存的组件，传入正则表达式或数组，匹配组件的`name`\n\n```html\n<KeepAlive :max=\"3\" :include=\"/a|b/\">\n  <component :is=\"tabs[currentTab]\"></component>\n</KeepAlive>\n```\n\n### 透传属性\n当一个属性传递给子组件时，若该属性未被子组件声明为`props`,`emits`,`v-on`事件监听器，则称为**透传attribute**。\n\n* 当子组件**只含单个根元素**，则透传属性会被自动添加到该元素上，并和元素上原有的属性合并。\n\n* 如果子组件A中是另一个组件B，透传属性会传递给组件B\n* 在组件`export default`中设置`inheritAttrs: false`可以禁用组件透传。\n* 在设为禁用后，在子组件中可以通过`$attrs`[访问](https://cn.vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance)所有透传属性，并通过`v-bind=\"$attrs\"`将透传属性绑定到任意元素上。\n\n```html\n<!--子组件只含一个button元素-->\n<button class=\"child\">click me</button>\n\n<!--父组件中-->\n<MyButton class=\"father\" @click=\"onClick\"/>\n\n<!--最终渲染-->\n<button \nclass=\"child father\" @click=\"onClick\">\nclick me\n</button>\n```\n\n#### 在Js中访问attrs\n以下`attrs`为非响应式。\n```html\n<script setup>\nimport { useAttrs } from 'vue'\nconst attrs = useAttrs()\n</script>\n\n<script>\nexport default {\n  setup(props, ctx) {\n    // 透传 attribute 被暴露为 ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n</script>\n```\n","tags":["编程"],"categories":["前端"]},{"title":"Vue3","url":"/2022/09/25/Vue3-conclusion/","content":"\n# Vue3\n----\n\n## 概念\n* 指令：`v-for`,`v-model`,`v-bind`\n\n<!--more-->\n\n## step0_构建\n\n### Vite-项目脚手架\n\n\n## step1_创建应用实例\n```javascript\nmain.js//入口文件\n\n<!--1.创建应用实例-->\n//导入createApp，单文件根组件\nimport {createApp} from 'vue'\nimport App from './App.vue'\n\n//createApp(根组件,根组件Props[可选])\nconst app = createApp(App)\n/*---外部导入↑或↓内联---*/\nconst app = createApp({\n    /*内联根组件*/\n})\n\n<!--2.将应用实例挂载在一个容器元素中-->\n//mount(DOM元素或CSS选择器)\n//每个应用实例仅能调用一次mount()\napp.mount('#app')\n/*---CSS选择器↑或↓DOM元素---*/\napp.mount(document.body.firstChild)\n```\nApp相关方法，属性\n\n* `unmount()`：卸载一个已挂载的应用\n* [`provide()`](https://cn.vuejs.org/api/application.html#app-provide)：提供一个值，在应用中的所有后代组件中注入使用。\n* [`component()`](https://cn.vuejs.org/api/application.html#app-component)：注册组件\n* [`directive()`](https://cn.vuejs.org/api/application.html#app-directive)：注册指令\n* [`use()`](https://cn.vuejs.org/api/application.html#app-use)：安装一个插件\n* `version`：当前应用所使用的 Vue 版本号\n* [`config`](https://cn.vuejs.org/api/application.html#app-config)：对这个应用的配置设定\n* [`config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties)：注册能够被应用内所有组件访问的全局属性的对象\n\n## step2_组件(component)\n\n命名建议：PascalCase(所有首字母大写)\n\n### 创建组件\n\n## step3_测试\n\n### 单元测试\n\n[单元测试](https://cn.vuejs.org/guide/scaling-up/testing.html#unit-testing)侧重于逻辑上的正确性，只关注应用整体功能的一小部分。\n\n","tags":["编程"],"categories":["前端"]},{"title":"Forge1.18-Effect","url":"/2022/05/31/my-forge-learning-effect/","content":"\n# Effect\n\n## 注册\n与item大致相同\n```java\n//创建注册器\npublic static final DeferredRegister<MobEffect> MOB_EFFECTS=DeferredRegister.create(ForgeRegistries.MOB_EFFECTS, Deathspiral.MOD_ID);\n//注册Custom_Effect\npublic static final RegistryObject<MobEffect> Custom_Effect=MOB_EFFECTS.register(\"custom_effect\",()->new CustomEffect());\n```\n\n## 自定义效果类\n```java\npublic class VigilanceEffect extends MobEffect implements IForgeMobEffect {\n    protected VigilanceEffect() {\n    super(MobEffectCategory.BENEFICIAL,0);\n    addAttributeModifier(Attributes.MOVEMENT_SPEED,\"UUID\",0.1F, AttributeModifier.Operation.MULTIPLY_TOTAL);\n    }\n    //应用的效果\n    @Override\n    public void applyEffectTick(LivingEntity entity, int amplifier) {\n        if(!entity.level.isClientSide()){\n            if(entity instanceof Player){\n                Player player=(Player)entity;\n                player.sendMessage(new TranslatableComponent(\"test_message\"),player.getUUID());\n            }\n        }\n    }\n    //每隔多久应用一次效果(如果为20，就代表每隔20ticks即1秒)\n    @Override\n    public boolean isDurationEffectTick(int remainingTicks, int level) {\n        return remainingTicks%20==0;\n    }\n}\n```\n\n[AttributeModifier相关资料](https://minecraft.fandom.com/zh/wiki/%E5%B1%9E%E6%80%A7)","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Blocks-Entity","url":"/2022/05/30/my-forge-learning-entity/","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Sounds","url":"/2022/05/29/my-forge-learning-sounds/","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-粒子效果","url":"/2022/05/19/my-forge-learning-particles/","content":"\n# Particles\n\n<!--more-->\n\n## 创建粒子效果\nParticles的实现包含了客户端限定的类和通用的类。客户端限定的类用于展现粒子效果，通用的类用于同步数据等\n|  Class   | Side  | 描述 |\n|  ----  | :---  |  ----  |\n| ParticleType  | BOTH | 用于注册 |\n| ParticleOptions  | BOTH | 用于同步信息 |\n| ParticleProvider | CLIENT | 用于构造粒子 |\n| Particle | CLIENT | 粒子的渲染逻辑 |\n\n## ParticleType\n`ParticleType`是决定粒子种类，并为客户端和服务器提供参考的`RegistryObject`，因此，所有的`ParticleType`须被注册。\n每个`ParticleType`接收两个参数：\n`overrideLimiter`决定了粒子是否无论远近都渲染\n`ParticleOptions$Deserializer`读取客户端的`ParticleOption`\n`ParticleType`是抽象类，其`#codec`方法须被重写。\n\n在大多数情况下，粒子数据不需要发送到客户端。对于这些实例，创建一个`SimpleParticleType`实例更加容易。\n\n## TextureSheetParticle\n实际自定义Particle时，可继承该类\n```java\npublic class CustomParticle extends TextureSheetParticle{\n//构造器\n\tprotected CustomParticle(ClientLevel level,double xCoord,double yCoord,double zCoord,SpriteSet spriteSet,double xd,double yd,double zd){\n    super(level,xCoord,yCoord,zCoord,xd,yd,zd);\n    this.friction=0.8F;\n    this.xd=xd;\n    this.yd=yd;\n    this.zd=zd;\n    this.qu\n\t}\n}\n```","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-data","url":"/2022/05/17/my-forge-learning-data/","content":"\n# Data\n\n```\nresources\n└── data\n    └── MOD_ID\n        ├── recipes\n        ├── tags\n        ├── structures\n        ├── advancements\n        └── loot_tables\n```\n在`Gradle:net.minecraft:client:extra:版本号`中可以看到原版的data文件夹\n\n<!--more-->\n\n## recipes-合成表\n```json\n//arrow.json 箭的合成配方\n{\n  \"type\": \"minecraft:crafting_shaped\",\n  \"pattern\": [\n    \"X\",\n    \"#\",\n    \"Y\"\n  ],\n  \"key\": {\n    \"#\": {\n      \"item\": \"minecraft:stick\"\n    },\n    \"X\": {\n      \"item\": \"minecraft:flint\"\n    },\n    \"Y\": {\n      \"item\": \"minecraft:feather\"\n    }\n  },\n  \"result\": {\n    \"item\": \"minecraft:arrow\",\n    \"count\": 4\n  }\n}\n```\n\n`type`：\n* `minecraft:blasting`\n* `minecraft:crafting_shaped`\n* `minecraft:smelting`\n* `minecraft:crafting_shapeless`\n* `minecraft:stonecutting`\n* `minecraft:smoking`\n* `minecraft:crafting_special_mapcloning`\n* `minecraft:smithing`\n* `minecraft:crafting_special_repairitem`\n* `minecraft:campfire_cooking`\n\n## loot_table-战利品表\n\n\n## tags-标签\n\n## NBT Data\n\n```\nItemStack.hasTag()\nItemStack.setTag(new CompoundTag())\nItemStack.getTag().getString(\"key\")\n\nCompoundTag.putString(\"key\",\"value\")\n```\n","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-player","url":"/2022/05/17/my-forge-learning-player&world/","content":"\n# Player\n\n<!--more-->\n\n## 常用方法\n```java\npublic boolean hasEffect(MobEffect effect) {\n    return this.activeEffects.containsKey(effect);\n}\n\npublic ItemStack getItemInHand(InteractionHand hand){\n    //返回玩家当前手中的道具\n}\n\n//遍历玩家的物品栏\nfor(int i=0;i<player.getInventory().getContainerSize();i++){\n    ItemStack currentStack=player.getInventory().getItem(i);\n}\n```\n\n## 向玩家的对话框发送消息\n```java\nplayer.sendMessage(new TranslatableComponent(\"message_ID\"),player.getUUID());\n```\n`message_ID`通常为调用该方法的物品ID+messageID，例如`item.MOD_ID.customItem.message`\n\n```json\n{\n  \"message_ID\": \"显示的文字\"\n}\n```\n※补充阅读：[格式化代码](https://minecraft.fandom.com/zh/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81)\n\n# Level\n\n## 常用方法\n```java\n//制造爆炸（须在服务器端调用）\npublic Explosion explode(@Nullable Entity entity, @Nullable DamageSource source, @Nullable ExplosionDamageCalculator damage, double posX, double posY, double posZ, float radius, boolean fire, Explosion.BlockInteraction blockInteraction);\n//BlockInteraction可选：Explosion.BlockInteraction.DESTROY/BREAK/NO\n```","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-网络","url":"/2022/05/13/my-forge-learning-networking/","content":"\n## Networking","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Block Entities","url":"/2022/05/09/my-forge-learning-block_entity/","content":"\n#  Block Entities\n`BlockEntities`是简化的`Entities`，并和一个Block绑定。它们用于存储动态数据，执行任务（tick based tasks），和动态渲染。原版mc中，箱子的存储功能，熔炉的燃烧，信标的buff效果等等都是通过`Block Entities`实现的。\n<!--more-->\n\n## Registering\n为创建一个`BlockEntity`，你需要继承该类。Block Entities 是动态创建或移除的，因此其本身并不需要注册。而作为替代，`BlockEntityType`会被注册。\n\n一个`BlockEntityType`的注册和其他注册方式相同。\n通过`BlockEntityType$Builder#of`可以创建一个该Type对应的BlockEntity实例。\n\n>This takes in a `Type` which represents the type-safe reference used to refer to this registry object in a `DataFixer`. `DataFixer`为可选选项，build()中可传入null\n\n```Java\npublic class BlockEntityRegistry {\n    //创建注册器\n    public static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITIES=DeferredRegister.create(ForgeRegistries.BLOCK_ENTITIES, MOD_ID);\n\n    //注册TestBlockEntity为例\n    public static final RegistryObject<BlockEntityType<TestBlockEntity>> TEST_BLOCK_ENTITY=BLOCK_ENTITIES.register(\"test_block_entity\",()->BlockEntityType.Builder.of(TestBlockEntity::new,BlockRegistry.TEST_BLOCK.get()).build(null));\n}\n\n// TestBlockEntity为继承了BlockEntity的自定义类\n    //构造器\n    public TestBlockEntity(BlockPos pos, BlockState state) {\n    super(BlockEntityRegistry.TEST_BLOCK_ENTITY.get(), pos, state);\n}\n```\n\n## 绑定BlockEntitiy&Block\n为了给Block绑定一个BlockEntity，`Block`子类需要实现`EntityBlock`接口。`EntitiyBlock#newBlockEntity(BlockPos,BlockState)`需要被实现并返回一个`BlockEntitiy`实例。\n(或继承`BaseEntityBlock`)\n在`Block`类中，须重写的方法：\n\n```java\n//使方块被渲染为模型\n@Override\npublic RenderShape getRenderShape(BlockState state) {\n    return RenderShape.MODEL;\n}\n```\n\n## 存储数据\n为了实现保存数据需要重写以下两个方法。\n```java\n@Override\nprotected void saveAdditional(@NotNull CompoundTag tag) {\n    tag.put(\"inventory\", itemHandler.serializeNBT());\n    super.saveAdditional(tag);\n}\n\n@Override\npublic void load(CompoundTag nbt) {\n    super.load(nbt);\n    itemHandler.deserializeNBT(nbt.getCompound(\"inventory\"));\n}\n```\n每当包含该`BlockEntity`的`LevelChunk`从一个tag保存或读取时，这些方法会被调用。用这些方法可以读写你的block entity class中的变量。\n\n※每当你的数据改变，都需要调用`BlockEntity#setChanged`，否则在level被保存的时候，包含该`BlockEntity`的`LevelChunk`可能会被跳过。\n\n※It is important that you call the `super` methods!\nThe tag names `id`, `x`, `y`, `z`, `ForgeData` and `ForgeCaps` are reserved by the `super` methods.\n\n## 添加计时\n如果你需要一个计时的`BlockEntity`，比如追踪熔炼时的进程，就需要实现并重写另一个方法：`EntityBlock#getTicker(Level, BlockState, BlockEntityType)`\n\n※This can implement different tickers depending on which logical side the user is on, or just implement one general ticker. In either case, a `BlockEntityTicker` must be returned. Since this is a functional interface, it can just take in a method representing the ticker instead:\n```Java\n// Inside some Block subclass\n@Nullable\n@Override\npublic <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> type) {\n  return type == MyBlockEntityTypes.MYBE.get() ? MyBlockEntity::tick : null;\n}\n\n// Inside MyBlockEntity\npublic static void tick(Level level, BlockPos pos, BlockState state, T blockEntity) {\n  // Do stuff\n}\n```\n\n※该方法会在每tick都调用一次，因此不应该进行过于复杂的运算。你应当在每隔Xticks进行一次复杂的运算。\n（每秒包含的tick数可能低于20，但不会更高）\n\n## Synchronizing the Data to the Client\n同步数据又三种方法：\n* synchronizing on chunk load\n* on block updates\n* custom network message\n\n# MenuProvider\n","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Items","url":"/2022/05/08/my-forge-learning-item/","content":"\n# Items\n\n<!--more-->\n\n## Creating an Item-创建物品\n### Basic Items\nBasic items是没有特殊功能的，（如木棒或白糖），不需要专门的类。可以通过实例化带有`Item$Properties`的`Item`类创建一个基本的Item。\n```Java\npublic class customItem extends Item {\n    public customItem() {\n        super(new Properties().);\n    }\n}\n```\n\n※以上方法均可以链式调用。\n\n## Properties-属性\n\n### Properties方法一览\n`food(FoodProperties)`：设置[食物]()相关的属性\n`stacksTo(int)`：设置最大存储量(StackSize,默认为64)\n`durability(int)`：设置耐久度(调用后StackSize固定为1)\n`craftRemainder(Item)`：设置该item的容器item，用于倒出岩浆后返还铁桶。\n`tab(CreativeModeTab)`：设定该道具属于哪个`CreativeModeTab`目录\n`rarity(Rarity)`：稀有度，有`COMMON`(默认)，`UNCOMMON`，`RARE`，`EPIC`\n`fireResistant()`：设置为抗火(不会被岩浆烧掉)\n`setNoRepair()`：使道具无法被修复，即使有耐久属性。\n\n[effect一览](null)\n\n### tab()\n`TAB_BUILDING_BLOCKS`：建筑方块\n`TAB_DECORATIONS`：装饰性方块\n`TAB_REDSTONE`：红石\n`TAB_TRANSPORTATION`：交通运输\n`TAB_MISC`：杂项\n`TAB_FOOD`：食物\n`TAB_TOOLS`：工具\n`TAB_COMBAT`：战斗用品\n`TAB_BREWING`：酿造\n`TAB_MATERIALS`：(=`TAB_MISC`)\n\n调用：\n```java\nProperties().tab(CreativeModeTab.TAB_BREWING)\n```\n\n#### 自定义Tab\n```java\npublic class CustomTab extends CreativeModeTab{\n\t//实例化并录入ID\n\tpublic static final CustomTab customTab =new CustomTab(\"customTab_ID\");\n\t\n\t//返回一个物品，并作为自定义Tab的图标\n\t@Override\n\tpublic ItemStack makeIcon() {\n\t\treturn new ItemStack(ItemRegistry.test_Item.get());\n    }\n}\n```\n本地化：\n```\n{\n\titemGroup.customTab_ID:\"Tab名称\"\n}\n```\n\n## Food-食物\n\n### food()--FoodProperties\n※mc除了可见的饱食度条以外，还有隐藏饱食度(float)。隐藏饱食度的最大值为当前饱食度。玩家的行为会消耗隐藏饱食度，当隐藏饱食度为0时，饱食条会开始抖动。\n详见：[wiki:Hunger](https://minecraft.fandom.com/wiki/Hunger#Mechanics)\n\n`nutrition(int)`：设置回复的饱食度\n`saturationMod(float)`：设置回复的隐藏饱食度\n`isMeat()`：设为肉类\n`alwaysEat()`：设为在任意场合都能吃(即使在满腹时)\n`fast()`：设为fastFood(进食速度加快)\n`effect(Supplier<>)`：设置食用获得的效果以及概率\n\nFoodProperties需要通过Builder()创建，且在最后调用build()完成创建。effect中的三个参数为持续时间，等级，概率。\n\n```Java\nProperties().food(new FoodProperties.Builder()\n             .nutrition(4)\n             .saturationMod(2)\n\t\t\t.effect(()->new MobEffectInstance(MobEffects.FIRE_RESISTANCE, 200, 0), 0.5F))\n             .build());\n```\n\n### Item#getUseDuration(ItemStack)\n可以自定义吃东西花费的时间\n```java\n@Override\npublic int getUseDuration(ItemStack itemstack){\n//通常的食物为32,fastFood为16\n    return 1;\n}\n```\n\n## 其他method\n```java\n//添加物品提示\n@Override\npublic void appendHoverText(ItemStack itemStack, @Nullable Level level_, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced){\n\tpTooltipComponents.add(new TranslatableComponent(\"message_ID\"));\n}\n```\n\n* `useOn`：当使用道具右键方块时调用\n* `interactLivingEntity`：当右键一个实体时调用\n* `hurtEnemy`：当玩家用物品攻击一个实体时调用\n* `onCraftedBy`：当从工作台拿下物品时调用\n* `inventoryTick`：当物品在物品栏时每tick调用\n* `isValidRepairItem`：第二个物品能否用于在铁砧修复第一个物品\n\n\n## ItemStack-物品堆\n### ItemStack#getItem()\n返回当前物品格中的物品，如果为空则返回`Items.AIR`\n### ItemStack#hurtAndBreak(int , T , Consumer\\<T> )\n\n\n## IForgeItem接口\n该接口包含许多供制作者重写的方法。\n```java\n//判断能否禁用盾牌5秒(原版中斧类武器可以)\nboolean canDisableShield(ItemStack stack, ItemStack shield, LivingEntity entity, LivingEntity attacker)\n{\n    return this instanceof AxeItem;\n}\n\n//返回燃烧时间(tick)，0为非燃料，-1将交给原版逻辑判断\nint getBurnTime(ItemStack itemStack, @Nullable RecipeType<?> recipeType)\n{\n    return -1;\n}\n```\n\n## Register-注册\n注册有两种主要方法，这里选择在item目录下创建一个item注册器类。\n\n注册时，register()的第一个参数为item_ID，唯一且**不能出现大写字母**。\n\n第二个参数为一个item的实例。\n\n```java\npublic class ItemRegistry {\n//创建注册器\n    public static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS, MOD_ID);\n//注册有自定义类的物品\n    public static final RegistryObject<Item> testItem = ITEMS.register(\"test_item1\", ()->new TestItem()));\n}\n//也可以在注册时临时创建一个物品\npublic static final RegistryObject<Item> testItem = ITEMS.register(\"test_item2\", ()->new Item(new Properties()));\n}\n//在主类中调用注册器的注册事件\npublic class CustomMod{\n\t/.../\n\tpublic CustomMod(){\n\tIEventBus eventBus = FMLJavaModLoadingContext.get().getModEventBus();\n\tItemRegistry.ITEMS.register(eventBus);\n\t}\n\t/.../\n}\n```\n\n## 材质和模型\n在`src/main/resources`目录下，需要创建如下结构，来给物品附上材质和模型。\n```\nresources\n├── assets\n│   └── MOD_ID\n│       ├── models\n│       │   └── item\n│       │       └── item_ID.json\n│       └── textures\n│           └── item\n│               └── item_ID.png\n├── lang\n│   └── en_us.json\n```\n\n### models / item_ID.json\n```json\n{\n  \"parent\": \"item/generated\",\n  \"textures\": {\n    \"layer0\": \"MOD_ID:item/item_ID\"\n  }\n}\n```\n`parent`指定了该模型的父模型，`textures`指定了具体的材质，材质放在`assets/textures/item`下。\n\n### 本地化\n```json\n{\n  \"item.MOD_ID.item_ID\": \"物品名称\"\n}\n```\n\n## Tools-工具\n\nTools继承了`Item`类。它们的实现主要依赖继承特定类，`TierSortingRegistry`，和tags。\n\n### Tier（品质）\n原版的Tiers有六种[品质]([品质 - Minecraft Wiki，最详细的我的世界百科 (fandom.com)](https://minecraft.fandom.com/zh/wiki/品质))\n`Wood`,`Stone`,`Iron`,`Diamond`,`Netherite`,`Gold`\n你可以实例化ForgeTier创建自定义的工具品质：\n\n```java\npublic class CustomTier{\n    //前四个参数为挖掘等级,耐久度,挖掘倍率,伤害加成,附魔能力\n    public static final ForgeTier CUSTOMTIER=new ForgeTier(\n        1,100,1.5f,2f,22,\n        BlockTags.NEEDS_DIAMOND_TOOL,\n        ()->Ingredient.of(ItemRegistry.test_Item.get()));\n}\n```\n\n你也可以实现`Tier`接口自定义工具品质：\n```java\npublic enum CustomTier implements Tier{\n\tEXAMPLE_TIER(1, 1, 1.0F, 1.0F, 1, () -> {\n        return Ingredient.of(Items.Custom_Ingredient);\n    });\n}\n\nprivate final int level;\nprivate final int uses;\nprivate final float speed;\nprivate final float damage;\nprivate final int enchantmentValue;\nprivate final LazyValue<Ingredient> repairIngredient;\n\nCustomTier(int level, int durability, float miningSpeed, float damage, int enchantability, Supplier<Ingredient> repairIngredient) {\n        this.level = level;\n        this.uses = durability;\n        this.speed = miningSpeed;\n        this.damage = damage;\n        this.enchantmentValue = enchantability;\n        this.repairIngredient = new LazyValue<>(repairIngredient);\n}\n```\n接口中的方法：\n* `getUses`：返回该品质的耐久。\n* `getSpeed`：返回该品质的挖掘效率乘数。\n* `getAttackDamageBonus`：返回该品质基本攻击伤害。\n* `getLevel`：返回该品质的挖掘等级(原版为0-4)\n* `getEnchantmentValue`：返回该品质的附魔效益\n* `getRepairIngredient`：返回用于修复该品质工具的材料\n* `getTag`：以`Tag<Block>`的形式返回该品质的工具可以挖掘的方块，命名格式为：`<modid>:needs_<tier_name>_tool`\n\n### TierSortingRegistry\n通过static声明，使Tiers比Items先注册。一个tier可以由`TierSortingRegistry#registerTier`注册。所有未在sorting system中定义的tier都会采用原版默认行为。\n[暂略](https://forge.gemwire.uk/wiki/Making_Tools)\n\n### 创建工具\n继承对应的工具类可以创建工具。\n分别为`SwordItem`,`PickaxeItem`,`AxeItem`,`ShovelItem`,`HoeItem`\n\n### SwordItem-剑类\n```java\n//用该剑对一个实体造成伤害时调用\npublic boolean hurtEnemy(ItemStack item, LivingEntity pTarget, LivingEntity pAttacker)\n\n```\n\n### 模型和材质\n```json\n{\n  \"parent\": \"item/handheld\",\n  \"textures\": {\n    \"layer0\": \"MOD_ID:item/tool_ID\"\n  }\n}\n```\n\n## Armor-防具\n\n### 自定义防具材料\n利用快捷键`ctrl+h`可以查看已实现接口的类，找到`net.minecraft.world.item.ArmorMaterials`，复制并修改即可。\n```java\npublic enum CustomArmorMaterials implements ArmorMaterial {\n\t//注意点：该数组为防具的耐久基数，并且是从脚到头(靴子到头盔)的顺序。\n    private static final int[] HEALTH_PER_SLOT = new int[]{13, 15, 16, 11};\n    //注意点：复制后getName()要改成如下，\"MOD_ID:name\"\n    public String getName() {\n        return MOD_ID+\":\"+this.name;\n    }\n}\n```\n### 注册\n```java\npublic static final RegistryObject<Item> CUSTOM_HELMET=ITEMS.register(\"custom_helmet\",()->new ArmorItem(CustomArmorMaterials.MATERIAL,EquipmentSlot.HEAD,new Item.Properties()));\n```\n\n| 类型 | EquipmentSlot       |\n| ---- | ------------------- |\n| 头盔 | EquipmentSlot.HEAD  |\n| 胸甲 | EquipmentSlot.CHEST |\n| 护腿 | EquipmentSlot.LEGS  |\n| 靴子 | EquipmentSlot.FEET  |\n\n### 材质\nmodels/json和其他item相同。\n盔甲的材质要放在以下目录\n```\nresources\n├── assets\n│   └── MOD_ID\n│       ├── textures\n│       │   └── models\n│       │       └── armorID_layer_1.png\n│       │       └── armorID_layer_2.png\n```\n\n### 特殊效果\n为了实现特殊效果，应自定义Armor类，并继承`ArmorItem`\n\n## Projectile-远程武器\n\n\n## BlockEntityWithoutLevelRenderer\n这是一个处理道具动态渲染的方法。\n## Using\n`BlockEntityWithoutLevelRenderer`可以让你通过`public void renderByItem(ItemStack itemStack, TransformType transformType, PoseStack poseStack, MultiBufferSource bufferSource, int combinedLight, int combinedOverlay)`渲染你的item。\n（以下简称BEWLR）\n\n为了使用BEWLR，该Item必须满足它的model的`BakedModel#isCustomRenderer`返回true。如果它未设置BEWLR，会调用默认的`ItemRenderer#getBlockEntityRenderer`。\n\n给一个item设置BEWLR，需要有一个`IItemRenderProperties`的匿名实例在`Item#initializeClient`方法中。在匿名实例中，`IItemRenderProperties#getItemStackRenderer`需要被重写，并返回你的BEWLR。\n```Java\n// In your item class\n@Override\npublic void initializeClient(Consumer<IItemRenderProperties> consumer) {\n  consumer.accept(new IItemRenderProperties() {\n\n    @Override\n    public BlockEntityWithoutLevelRenderer getItemStackRenderer() {\n      return myBEWLRInstance;\n    }\n  });\n}\n```\n※ 每个模组只能有一个自定义BEWLR的实例","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Projectile","url":"/2022/05/08/my-forge-learning-projectile/","content":"\n# Projectile 自定义投掷物\n\n## 相关基类\n\n`Projectile`\n* 存储投掷物的所有者\n* 包含发射的方法，设置移动方向\n* has methods for what happens for reacting to impacts\n* 不包含移动和碰撞检测的逻辑\n\n`ThrowableProjectile > Projectile`\n* 在tick方法中包含移动和碰撞检测\n\n`ThrowableItemProjectile > ThrowableProjectile`\n* 同时呈现为物品\n\n`AbstractArrow > Projectile`\n* 在tick方法中包含移动和碰撞检测\n* 可以旋转并朝向移动方向\n* 穿透效果\n* 基于速度和`setBaseDamage`造成实际伤害\n* 掉在地上并且可被拾取\n* 可被`ArrowItem`类的武器发射\n\n`Arrow > AbstractArrow`\n* 附加药水效果\n\n## Rendering\n为了让你的投掷物被玩家们看见，你必须将它和`EntitiyRenderer`绑定。\n","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Blocks","url":"/2022/05/07/my-forge-learning-block/","content":"\n# Blocks\n\n<!--more-->\n\n## Register-注册\n地面上的方块是`Block`，物品栏的方块是继承了`Item`的`BlockItem`。因此在注册方块的同时，通常需要同时注册方块物品。(也有像水方块等例外，其没有直接对应的物品) 因此可以将注册方法进行包装，便于后续注册方块。\n```java\n//BLOCKS注册器\npublic static final DeferredRegister<Block> BLOCKS=DeferredRegister.create(ForgeRegistries.BLOCKS, MOD_ID);\n//BlockItem的注册方法\nprivate static <T extends Block> RegistryObject<Item> registryBlockItem(String name, Supplier<T> block, CreativeModeTab tab){\n    return ItemRegistry.ITEMS.register(name,()->new BlockItem(block.get(), new Item.Properties().tab(tab)));\n}\n//Block的注册方法，并调用BlockItem注册方法\nprivate static <T extends Block> RegistryObject<T> registryBlock(String name,RegistryObject<T> block,CreativeModeTab tab){\n    RegistryObject<T> newBlock=BLOCKS.register(name,block);\n    registryBlockItem(name,newBlock,tab);\n    return newBlock;\n}\n//注册Block\npublic static final RegistryObject<Block> TEST_BLOCK =registryBlockWithItem(\"test_block\",()->new TestBlock(),CustomTab.instance);\n```\n\n## Properties-属性\n原版方块的属性可在`net.minecraft.world.level.block.Blocks`中查看\n### Properties方法一览\n`of(Material)`：设置方块的材质\n`destroyTime(float)`：设置挖掘时间\n`explosionResistance(float)`：设置爆炸抗性(须大于0F)\n`strength(float，float)`：调用以上两个方法\n`requireCorrectToolForDrops()`\n`sound(SoundType)`：详见[sounds](https://mcforge.readthedocs.io/en/1.18.x/gameeffects/sounds/)\n`lightLevel((state)->)`：设置方块的亮度，通常为0~15(可通过state属性控制)\n`friction`：摩擦力，默认0.6，冰块为0.98。\n`speedFactor(float)`：对速度的影响，默认为1F(灵魂沙为0.4F,减速至40%左右)\n`jumpFactor(float)`：对跳跃的影响,默认为1F(蜂蜜块为0.5F，跳跃高度减至15%)\n`instabreak()`\n`randomTicks()`：接收随机刻\n`noCollission()`：设为无碰撞方块(按钮等)但对速度，跳跃的影响依然生效\n`noOcclusion()`：是否会使玩家窒息\n`dynamicShape()`\n`noDrops()`：无掉落\n`lootFrom()`\n`air()`\n`isValidSpawn(BlockBehaviour.StateArgumentPredicate<EntityType<?>>)`\n`isRedstoneConductor(BlockBehaviour.StatePredicate)`\n`copy(Block.BlockBehaviour)`：复制另一个方块的属性\n\n所有这些方法都可以连锁调用。\n\n## IForgeBlock接口\n```java\n//如果为true，会作为燃烧的方块对生物造成伤害\nboolean isBurning(BlockState state, BlockGetter level, BlockPos pos)\n{\n    return this == Blocks.FIRE || this == Blocks.LAVA;\n}\n```\n## 其他Method\n```java\n//玩家右键方块时调用\npublic InteractionResult use(BlockState state, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit)\n//返回true时，方块可以种植植物\npublic boolean canSustainPlant(BlockState state, BlockGetter world, BlockPos pos, Direction facing, IPlantable plantable)\n//接收随机刻\npublic boolean isRandomlyTicking(BlockState state)\npublic void randomTick(BlockState state, ServerLevel world, BlockPos pos, Random rand)\n//玩家踩在方块上时调用(例子为施加加速效果)\npublic void stepOn(Level level,BlockPos pos,BlockState state,Entity entity){\n\tif(!level.isClientSide()){\n\t\tif(entity instanceof LivingEntity){\n            LivingEntity livingEntity=((LivingEntity)entity);\n            livingEntity.addEffect(new MobEffectInstance(MobEffects.MOVEMENT_SPEED,300));\n        }\n\t}\n}\n//（被实体）放置时调用\npublic void setPlacedBy(Level level, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack stack)\n//玩家左键方块时调用\npublic void attack(BlockState state, Level level, BlockPos pos, Player player)\n//在玩家破坏方块前调用(原版的活塞，TNT重写了此方法)\npublic void playerWillDestroy(Level level, BlockPos pos, BlockState state, Player player){\n    super.playerWillDestroy(level,pos,state,player);\n}\n//当有实体与方块碰撞/重叠时调用(如篝火)\npublic void entityInside(BlockState state, Level level, BlockPos pos, Entity entity)\n```\n\n- `playerDestroy `(used by beehives to release angry bees when you break them)\n- `onRemove `: called when the block is destroyed for any reason\n- `handleRain `: 1/16 chance to be called each tick while its raining (used by cauldrons to fill with water)\n- `fallOn `: called when an entity falls on the block. Deals the fall damage by calling `Entity.causeFallDamage(distance, damageMultiplier) `. (used by farm land to break the crop)\n- `onPlace`\n- `getExpDrop `returns the number of experience points to give when broken (like some vanilla ores)\n\n```java\n//use()使用案例\n@Override\npublic InteractionResult use(BlockState p_60503_, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult result) {\n    ItemStack held = player.getItemInHand(hand);\n    if (!world.isClientSide() && held.getItem() == Items.GUNPOWDER) {\n        world.explode(player, pos.getX(), pos.getY(), pos.getZ(), 4.0F, true, Explosion.BlockInteraction.DESTROY);\n        held.shrink(1);\n        return InteractionResult.CONSUME;\n    }\n    return InteractionResult.FAIL;\n}\n```\n\n## Stair/Slab/Fence/Gate\n楼梯，台阶，栅栏，栅栏门\n\n## Door/Trapdoor/Button/PressurePlate\n门/活板门/按钮/压力板\n\n## 透明/半透明方块\n继承`GlassBlock`，（或其父类）\n\n## ItemBlockRenderTypes\n\n| ItemBlockRenderTypes  | Block                          |\n| --------------------- | :----------------------------- |\n| RenderType.tripwire() | 绊线钩                         |\n| cutoutMipped()        | 草方块，铁栏杆，玻璃板         |\n| cutout()              | 玻璃，床，门，蜘蛛网，各种花草 |\n| translucent()         | 染色玻璃，粘液块，蜂蜜块       |\n\n## 应用自定义模型\n设置碰撞箱：\n```java\nprivate static final VoxelShape SHAPE = Block.box(x1,y1,z1,x2,y2,z2);\n\n@Override\npublic VoxelShape getShape(BlockState state,BlockGetter level,BlockPos,pos,CollisionContext,context){\n    return SHAPE;\n}\n```\n\n# Block States\n## 简介\n\n一个特定的方块只存在一个实例，位于对应的注册器中。而BlockStates就是在此基础上附加了BlockPosition，BlockProperties，BlockStateProperties的实例，并通过`World(Level)`保存和修改。\n\n方块的每个属性（property）都通过`Property<?>`的一个实例描述。属性包括但不限于：\ninstruments（`EnumProperty<NoteBlockInstrument>`）\n\nfacing（`DirectionProperty`）\n\npoweredness（`Property<Boolean>`）\n\n## 使用BlockState Properties\n```Java\npublic class CustomBlock extends Block{\n    //创建property\n    public static final BooleanProperty CLICKED=BooleanProperty.create(\"clicked\");\n    //关联property\n    @Override\n    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> pBuilder) {\n        pBuilder.add(CLICKED);\n    }\n    //使用property\n    @Override\n    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult result) {\n    if(!level.isClientSide()&&hand==InteractionHand.MAIN_HAND){\n    //获取当前CLICKED值\n    boolean currentState=state.getValue(CLICKED);\n    //修改CLICKED的值\n    level.setBlock(pos,state.setValue(CLICKED,!currentState),3);\n    }\n    return InteractionResult.SUCCESS;\n    }\n}\n```\n调用`BlockState#getValue(Property<?>)`可以获得属性的值。\n调用`BlockState#setValue(Property<T>,T)`设置属性的值。\n原版提供的实现如下：\n\n* `IntegerProperty`实现：`Property<Integer>`\n\t* 创建：`IntegerProperty#create(String propertyName, int minimum, int maximum)`\n\t\n* `BooleanProperty` 实现：`Property<Boolean>`\n\t* 创建：`BooleanProperty#create(String propertyName)`\n\t\n* `EnumProperty<E extends Enum<E>>`实现：`Property<E>`\n\t* 创建：`EnumProperty#create(String propertyName, Class<E> enumClass)`\n\t  ※也可以仅使用Enum中的一个子集\n\t\n\t  （见`EnumProperty#create`重载）\n\t\n* `DirectionProperty`简化`EnumProperty<Direction>`\n\t* 一些方法：`DirectionProperty.create(\"<name>\", Direction.Plane.HORIZONTAL)`\n\t* `DirectionProperty.create(\"<name>\", Direction.Axis.X)`\n\n`BlockStateProperties`类包含了原版共通的属性，而无需自己创建。\n\n当你有期望的`Property<>`，在你的block类中重写`Block#createBlockStateDefinition(StateDefinition$Builder)`，并在其中调用`StateDefinition$Builder#add(Property)`。\n\n每个block都会有默认的state设置。你可以通过在构造器中调用`Block#registerDefaultState(BlockState)`修改默认属性。\n`DoorBlock`的默认属性：\n```Java\nthis.registerDefaultState(\n  this.stateDefinition.any()\n    .setValue(FACING, Direction.NORTH)\n    .setValue(OPEN, false)\n    .setValue(HINGE, DoorHingeSide.LEFT)\n    .setValue(POWERED, false)\n    .setValue(HALF, DoubleBlockHalf.LOWER)\n);\n```\n\n如果你希望在放置方块时改变`BlockState`，（比如依照玩家的朝向），你可以重写`Block#getStateForPlacement(BlockPlaceContext)`\n\n因为所有可能的`BlockState`都在初始化时生成，你可以使用`==`判断两个`BlockState`是否相等。\n\nYou can get and place `BlockState`‘s in the level using `Level#setBlockAndUpdate(BlockPos, BlockState)` and `Level#getBlockState(BlockState)`. If you are placing a `Block`, call `Block#defaultBlockState()` to get the “default” state, and use subsequent calls to `BlockState#setValue(Property<T>, T)` as stated above to achieve the desired state.\n\n## BlockStates和模型的绑定\n\n文件路径\n```\nresources\n├── assets\n│   └── MOD_ID\n│       ├── blockstates\n│       │   └── CustomBlock.json      \n```\n\n文件内\n```json\n{\n  \"variants\": {\n    \"clicked=false\": {\"model\": \"MOD_ID:block/custom_block_off\"}\n    \"clicked=true\": {\"model\": \"MOD_ID:block/custom_block_on\"}\n  }\n}\n```","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-本地化","url":"/2022/05/06/my-forge-learning-localization/","content":"\n# Internationalization and localization\ninternationalization简称i18n，是一种让代码能够在不同语言下生效的设计。Localization则是将显示文字适应用户语言的过程。\n\n<!--more-->\n\ni18n通过*translation keys*实现。translation key是一个字符串，用于识别一块可显示的文字，例如`block.minecraft.dirt`是Dirt block的translation key。\n\n## Language files\n位于`assets/[namespace]/lang/[locale].json`\n例如`examplemod`的英文翻译位于`assets/examplemod/lang/en_us.json`。\n翻译文件必须用UTF-8编码。\n\n## Usage with Blocks and Items\n方块，道具以及一些其他MC中的类已经提供了translation keys。这些translation keys可以通过重写`@getDescriptionId`定义。*Item also has*`#getDescriptionId(ItemStack)` *which can be overridden to provide different translation keys depending on ItemStack NBT.*\n\n`#getDescriptionId`默认返回`block`或`item`，例如，一个ID为`examplemod:example_item`的道具，其language file为：\n\n```json\n{\n  \"item.examplemod.example_item\": \"Example Item Name\"\n}\n```\n\n## Localization methods\n[暂略](https://mcforge.readthedocs.io/en/1.18.x/concepts/internationalization/#localization-methods)","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Resources","url":"/2022/05/06/my-forge-learning-resources/","content":"\n# 资源 Resources\nMinecraft有两种基本的资源系统。\n`assets`位于逻辑客户端（logical client）中，用于模型，材质，本地化。\n`data`位于逻辑服务器（logical server）中，用于一些游戏机制，如合成表，[Loot table](https://minecraft.fandom.com/wiki/Loot_table)等。前者由Resource packs控制，后者由Datapacks控制。\n\n在默认的mdk中，assets和data目录位于`src/main/resources`中\n\n<!--more-->\n\n## General Files\n### mods.toml\n位于`./META-INF/`中，保存模组的基本信息。\n### pack.mcmeta\n使minecraft识别模组提供的assets\n## Assets\n`./assets`文件夹保存了所有客户端相关的文件。这些文件保存在用户本地电脑中。\n### Blockstates\n位于`./assets/<modid>/blockstates/`\n### Localizations\n用于本地化的json文件，名称为[language code](https://docs.microsoft.com/en-us/previous-versions/commerce-server/ee825488(v=cs.20)?redirectedfrom=MSDN)的小写。\n### Models\n模型文件为json，位于`./assets/<modid>/models/block/`或`./assets/<modid>/models/item/`\n### Textures\n纹理文件为png，位于`./assets/<modid>/textures/block/`或`./assets/<modid>/textures/item/`，其他实体在`/textures/`下各自独立的文件夹中。\n### Data\n`./data`文件夹保存了服务器相关的文件。这些文件会通过网络从主机同步。\n### Advancements\njson文件，位于`./data/<modid>/advancements/<group>/`，其中group为进度所属。\n### Loot Tables\njson文件，位于`./data/<modid>/loot_tables/<group>/`，其中group是掉落该loot table的物体，（如一个block的loot table位于`blocks`）\n### Recipes\njson文件，位于`./data/<modid>/recipes/`\n### Tags\njson文件，位于`./data/<modid>/tags/<group>/`其中group为创建tag的注册物体。（一个entity tag将存在于`entity_types`）\n\n## ResourceLocation\nmc通过`ResourceLocation`识别资源。一个`ResourceLocation`包括两个部分：命名空间和路径。它会到`<assets|data>/<namespace>/<ctx>/<path>`定位资源，其中`ctx`是*context-specific path fragment*，决定了资源如何被使用。当`ResourceLocation`用string读或写，它的形式为：`<namespace>:<path>`。如果namespace和冒号省略，那么namespace就默认为`minecraft`。一个模组通常将它的资源的命名空间设置为`modid`。","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Mod Lifecycle","url":"/2022/05/06/my-forge-learning-mod_lifecycle/","content":"\n# Mod Lifecycle\n在模组加载的过程中，多个生命周期事件会在mod-specific 事件总线中启动，例如物体注册，数据生成的准备，或是和其他模组的联动。\n\n<!--more-->\n\n事件监听器也需要通过`@EventBusSubscriber(bus=Bus.MOD)`或在模组构造器中注册：\n```Java\n@Mod.EventBusSubscriber(modid = \"mymod\", bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class MyModEventSubscriber {\n  @SubscribeEvent\n  static void onCommonSetup(FMLCommonSetupEvent event) { ... }\n}\n\n@Mod(\"mymod\")\npublic class MyMod {\n  public MyMod() {\n    FMLModLoadingContext.get().getModEventBus().addListener(this::onCommonSetup);\n  } \n\n  private void onCommonSetup(FMLCommonSetupEvent event) { ... }\n```\n\n※模组必须保证线程安全，当调用其他模组的API时或访问原版系统时。通过`ParallelDispatchEvent#enqueueWork`可以延后执行。\n\n## 注册事件\n注册事件有两种：`NewRegistryEvent`和`RegistryEvent$Register`。\n前者允许模组制作者注册他们注册使用`RegistryBuilder`类创建的自定义的注册表。\n后者用于将物体注册到注册表中。每个注册表都会启动`register`事件。*This event is for registering mods’ data providers to their associated data generator. This event is also fired synchronously.* \n\n## 数据生成（Data Generation）\n如果游戏运行data generators，`GatherDataEvent`将是最后一个启动的事件。\n\n## Common Setup\n## Sided Setup\n## InterModComms\n<!--more-->\n","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Events","url":"/2022/05/05/my-forge-learning-events/","content":"\n# 事件（Events）\nForge使用事件总线监听模组的各种行为。\n`FMLJavaModLoadingContext#getModEventBus`：Mod总线，负责生命周期事件。\n`MinecraftForge#EVENT_BUS`：Forge总线，负责除生命周期事件外的所有事件。\n\n<!--more-->\n\n## 创建一个事件处理器（Event Handler）\n事件处理器的方法有一个参数，且不返回任何结果。方法可以为static或为接口的实现。\n\n事件处理器可以用`IEventBus#addListener`或`IEventBus#addGenericListener`（用于泛型事件）直接注册。*Either listener adder takes in a consumer representing the method reference.Generic event handlers need to specify the class of the generic as well. *事件处理器必须在在main mod 类的构造器中被注册。\n\n```Java\n// In the main mod class ExampleMod\n\n// This event is on the forge bus\nprivate void forgeEventHandler(AddReloadListenerEvent event) {\n    // Do things here\n}\n\n// This event is on the mod bus\nprivate static void modEventHandler(RegistryEvent.Register<RecipeSerializer<?>> event) {\n    // ...\n}\n\n// In the mod constructor\nforgeEventBus.addListener(this::forgeEventHandler);\nmodEventBus.addGenericListener(RecipeSerializer.class, ExampleMod::modEventHandler);\n```\n\n### 实例方式使用事件系统 Instance Annotated Event Handlers \n```Java\npublic class MyForgeEventHandler {\n    @SubscribeEvent\n    public void pickupItem(EntityItemPickupEvent event) {\n        System.out.println(\"Item picked up!\");\n    }\n}\n```\n`@SubscribeEvent`注解用于标注某方法为事件处理器。传入的参数决定了该处理器监听的事件类型。\n（例子中的事件处理器监听`EntityItemPickupEvent`，每当有`Entity`拾起道具就会向总线发送该事件。）\n\n使用`MinecraftForge.EVENT_BUS.register(...)`并传递一个事件处理器的实例，以注册到Forge总线中。如果要注册到Mod总线中，用`FMLJavaModLoadingContext.get().getModEventBus().register(...)`作为代替。\n\n### 静态方式使用事件系统 Static Annotated Event Handlers\n一个事件处理器也可以是静态的。处理方法依然需要用`@SubscriberEvent`注释。\n\n`@Mod.EventBusSubscriber`表示该类中所有带`@SubscribeEvent`的静态方法都是事件处理器。可以在参数中指定将要注册的总线。\n\n```Java\n@Mod.EventBusSubscriber(bus=...)\npublic class MyStaticForgeEventHandler {\n    @SubscribeEvent\n    public static void arrowNocked(ArrowNockEvent event) {\n        System.out.println(\"Arrow nocked!\");\n    }\n}\n```\n在注册时需这样写：`MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class)`\n\n### 自动注册静态事件处理器\n一个类可以用`@Mod$EventBusSubscriber`注释，这样的类会在`@Mod`类自身被构造时，自动地注册到`MinecraftForge#EVENT_BUS`这等同于在`@Mod`类的构造器的末尾添加`MinecraftForge.EVENT_BUS.register(AnnotatedClass.class);`\n\n你可以将你想要监听的总线用`@Mod$EventBusSubscriber`注释。你也可以指明mod id，bus名以及加载event subscriber的端。\n```Java\n@Mod.EventBusSubscriber(modid = \"mymod\", bus = Bus.FORGE, value = Dist.CLIENT)\npublic class MyStaticClientOnlyEventHandler {\n    @SubscribeEvent\n    public static void drawLast(RenderLevelLastEvent event) {\n        System.out.println(\"Drawing!\");\n    }\n}\n```\n\n## 取消事件\n如果一个事件可以被取消，它需要被`@Cancelable`注释，则`Event#isCancelable()`将返回true。通过调用`Event#setCanceled(boolean canceled)`，可以设定一个事件是否取消。当一个不可取消的事件调用`setCanceled()`时，会抛出`UnsupportedOperationException`异常。\n\n**※在尝试取消一个事件前，先用`Event#isCancelable()`进行确认。**\n\n## 结果（results）\n有些事件含有`Event$Result`。一个结果可以是一下三者之一：\n* `DENY`：停止事件\n* `DEFAULT`：使用原版行为\n* `ALLOW`：强制动作发生\n\n事件的结果类型可以通过`Event$Result`的`#setResult`设置。不是所有的事件都有results，含有result的事件会被`@HasResult`注释。\n\n## 优先级（Priority）\n每个事件处理器方法(用`@SubscribeEvent`注释)都有一个优先级。你可以通过设置`priority`变量来设置事件优先级。`priority`的值可以是`EventPriority`enum中的任何一个(`HIGHEST`,`HIGH`,`NORMAL`,`LOW`,`LOWEST`)。\n\n## 子事件（Sub Events）\n很多事件都有它们的变种。这些可能是基于一个基本因素（如`PlayerEvent`，或可以是一个含有多个阶段的事件（`PotionBrewEvent`)\n\n## 模组事件总线（Mod Event Bus）\n模组事件总线用于监听生命周期事件，以初始化模组。总线上的每个事件都要求实现`IModBusEvent`接口。许多事件可以平行运行，从而多个模组可以同时被初始化。这意味着你不能在这些事件中直接执行来自其他模组的代码。为此要使用`InterModComms`。\n以下是4个在模组初始化时最常用的生命周期事件：\n* `FMLCommonSetupEvent`\n* `FMLClientSetupEvent`&`FMLDedicatedServerSetupEvent`\n* `InterModEnqueueEvent`\n* `InterModProcessEvent`\n\n※`FMLClientSetupEvent`和`FMLDedicatedServerStupEvent`只在它们各自的distribution上调用。\n\n这4个事件都是平行运行的，因为它们都是`ParallelDispatchEvent`的子事件。如果你想要在`ParallelDispatchEvent`期间运行主线程代码，你可以使用`#enqueueWork`来达到这个目的。\n\n另外，还有一些用于注册，安装，初始化各种东西的事件，大多数这些事件是不平行的。如：\n\n* `ColorHandlerEvent`\n\n* `ModelBakeEvent`\n\n* `TextureStitchEvent`\n\n* `RegistryEvent`\n\n当一个事件需要在初始化模组时处理，它就应启动在模组事件总线上。\n\n# 笔记\n\n> miscellaneous：混杂的，各种各样的","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-Sides","url":"/2022/05/04/my-forge-learning-sides/","content":"# Sides\n在制作模组时的一个重要概念就是两个Side：client（客户端）和server（服务器）\n\n<!--more-->\n## 不同类型的Sides\n我们通常说的“客户端”或“服务器”，是直觉性地将游戏区分为两部分，客户端就是用户交互的地方，服务器是用户连接多人游戏的地方。\n\n事实上，这两个概念并没有那么清晰的界线。这里为了消除歧义，列出4个可能的“client”和“server”的意义。\n* Physical client：指的是你启动MC时需要运行的整个程序。所有进程，线程，以及运行时需要提供的图形，交互等等服务都包含在内。\n* Physical server：通常被称为专属服务器(dedicated server)，是运行`minecraft_server.jar`的整个程序，它不会提供可游玩的GUI。\n* Logical server：运行游戏逻辑的服务器。包括mob生成，天气，更新建筑物品，生物AI等等。通常逻辑服务器附属在物理服务器中，但它也可以和逻辑客户端一同在物理客户端中运行，比如在单机模式中。逻辑服务器通常在`Server Thread`线程中运行。\n* Logical client：负责接收玩家的输入并输送到逻辑服务器。除此之外，也能从逻辑服务器接收信息，并以图像呈现给玩家。逻辑客户端运行在`Render Thread`，有时也会开启其他线程去处理音声或渲染分支。\n\n在Forge代码中，用enum`Dist`代表物理端，用enum`LogicalSide`代表逻辑端。\n\n## 针对特定端的处理\n### `Level#isClientSide`\n用于检查一个域所属的**逻辑端**。※[暂略](https://mcforge.readthedocs.io/en/1.18.x/concepts/sides/#performing-side-specific-operations)\n\n当你需要确定游戏逻辑或其他气质是否需要运行时可以使用这个check。比如，如果你想要让玩家每次点击某个方块时受到伤害，或者让你的机器将沙子变成钻石，你要确保`#isClientSide`为`false`。将游戏逻辑应用在逻辑客户端可能会导致游戏不同步（幽灵实体，未同步的状态等），严重会导致游戏崩溃。\n\n### `DistExecutor`\n[暂略](https://mcforge.readthedocs.io/en/1.18.x/concepts/sides/#distexecutor)\n`DistExecutor`提供了多种方法，以在不同物理端运行，以及只在某一端运行的方法。\n\n>FML checks基于物理端，一个单人游戏世界（物理客户端内包含逻辑客户端和逻辑服务器）总是使用Dist.CLIENT\n\n### 基本错误\n\n### 编写单端模组\n\n\n\n# 笔记\n\n>generic:泛型","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Forge1.18-注册","url":"/2022/05/03/my-forge-learning-registry/","content":"\n经过了一个月的Java学习，是时候开始使用Forge制作模组了。开发版本为forge-1.18.2-40.1.0。首先打算通读forge官方文档，同时做些简略的翻译（给自己看）以加深理解。\n\n<!--more-->\n\n# 注册(Registries)\n注册是让模组中的物体（道具，方块，音乐等）能够被游戏识别的过程。\n\n大多数需要被注册的东西都被`Forge registries`处理。注册表是类似于map的双列集合。Forge使用`ResourceLocation` 的keys注册物体。这会让`ResourceLocation`起到注册名的作用。 一个物体的注册名可以通过`getRegistryName`，`setRegistryName`获取。（setter只能被调用一次）\n\n每一类可注册的物体都有它自己的注册表。`ForgeRegistries` 类中可以看到所有注册表。同一注册表中的所有的注册名必须唯一，但不同注册表中可以使用相同的注册名。(如一个`Item`和一个`Block`可以用相同的注册名)\n\n## 注册方式\n### DeferredRegister class\n```Java\nprivate static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, MODID);\n//创建一个Block类的注册表\npublic static final RegistryObject<Block> ROCK_BLOCK = BLOCKS.register(\"rock\", () -> new Block(BlockBehaviour.Properties.of(Material.STONE)));\n//将自定义的ROCK_BLOCK注册到BLOCKS中，register()第二个参数为supplier的get()方法，重写后返回一个实例即可\n```\n\n### RegistryEvent$Register event\n通过事件来注册物体，而这些事件会在模组构造器调用后，configs载入前，启动。\n```Java\n@SubscribeEvent\npublic void registerBlocks(RegistryEvent.Register<Block> event) {\n  event.getRegistry().registerAll(new Block(...), new Block(...), ...);\n}\n//registerAll()可以同时导入多个Block\n```\n\n## 非Forge提供的注册\n因为一些奇怪的原因，不是所有的注册都被Forge所包装，如`RecipeType`（使用比较安全），`ConfiguredFeature`（动态注册）。`DeferredRegister#create`的重载可以允许模组编写者指明注册表的key。\n```Java\nprivate static final DeferredRegister<RecipeType<?>> REGISTER = DeferredRegister.create(Registry.RECIPE_TYPE_REGISTRY, MODID);\n\npublic static final RegistryObject<RecipeType<ExampleRecipe>> EXAMPLE_RECIPE_TYPE = REGISTER.register(\"example_recipe_type\", () -> new RecipeType<>() {});\n```\n\n## 特例\n有些类本身无法被注册，作为替代，`~Type`类会被注册，并在前者的构造器中使用（如`BlockEntity`有`BlockEntityType`，Entity有`EntityType`）这些`~Type`类是专门用于创建其包含类的“工厂”。\n这些“工厂”通过`~Type￥Builder`类被创建。\n\n```Java\n//（REGISTER属于DeferredRegister\\<BlockEntityType>）\npublic static final RegistryObject<BlockEntityType<ExampleBlockEntity>> EXAMPLE_BLOCK_ENTITY = REGISTER.register(\n  \"example_block_entity\", () -> BlockEntityType.Builder.of(ExampleBlockEntity::new, EXAMPLE_BLOCK.get()).build(null)\n);\n```\n\n## 引用被注册物体\n被注册的物体不能被存储在域中。它们应当总是在事件启动时被创建并注册。\n被注册的物体必须通过一个`RegistryObject`引用，或一个带有`@ObjectHolder`的域(field/变量)\n\n### 使用被注册物体\n`RegistryObject`可以获取被注册物体的引用。它们被`DeferredRegister`用于返回被注册物体的引用。这些引用以及`@ObjectHolder`会在它们对应的注册表的`RegistryEvent$Register`启用时更新。\n\n为了获取一个`RegistryObject`，可以调用带有`ResourceLocation`和`IForgeRegistry`的`RegistryObject#create`方法。将`RegistryObject`存在`public static final`域中，每当需要用它的时候调用`#get`即可。\n\n```Java\npublic static final RegistryObject<Item> BOW = RegistryObject.create(new ResourceLocation(\"minecraft:bow\"), ForgeRegistries.ITEMS);\n\n// assume that 'neomagicae:mana_type' is a valid registry, and 'neomagicae:coffeinum' is a valid object within that registry\npublic static final RegistryObject<ManaType> COFFEINUM = RegistryObject.create(new ResourceLocation(\"neomagicae\", \"coffeinum\"), new ResourceLocation(\"neomagicae\", \"mana_type\"), \"neomagicae\"); \n```\n\n### 使用@ObjectHolder\n注册表中被注册的物体可以被添加到`public static`域，只要用`@ObjectHolder`注释类或域，并提供必要的信息去构造一个`ResourceLocation`。\n`@ObjectHolder`的规则如下：\n\n* 如果**类**被`@ObjectHolder`注释，它的值会作为类内所有域的默认命名空间。而**域**被`@ObjectHolder`注释，它的值为路径（Name path）\n* 如果**类**被`@Mod`注释，MODID会作为类内所有域的默认命名空间。\n* 一个域如果满足一下条件，会被注入：\n\t* 至少有`public static`标识<font color='gray'>(域没有@ObjectHolder时要加final)</font>\n\t* 满足以下条件之一：\n\t  * 外部类(enclosing class)拥有`ObjectHolder`注释，并且域为`final`，且：\n\t  * name value为该域的名称，且：\n\t  * namespace value为该内部类的命名空间\n\t  * 域被`@ObjectHolder`注释，且：\n\t  * name value被明确定义，且：\n\t  * namespace value被定义，或为外部类的命名空间\n* 域的类型或其父类型对应一个有效的注册表(如Item或ArrowItem对应Item注册表)\n* 一个域没有对应的注册表，或`ResourceLocation`不正确或无效时，会抛出异常。\n\t\n\n在它们对应的注册表的`RegistryEvent$Register`事件启动时，`@ObjectHolder`注释的域的值以及`RegistryObject`会被注入。\n\n```Java\n//有注解类↓\n@ObjectHolder(\"minecraft\")\nclass AnnotatedHolder{\n    @ObjectHolder(\"ambient.cave\")\n\tpublic static SountEvent ambient_sound = null;\n\t//从[SountEvent]注册表注入\"minecraft:ambient.cave\"\n    \n    public static final Item ENDER_PEARL = null;\n    //从[Item]注册表注入\"minecraft:ender_pearl\"\n}\n\n//无注解类↓\nclass UnannotatedHolder{\n    @ObjectHolder(\"minecraft:flame\")\n    public static final Enchantment flame = null;\n    //从[Enchantment]注册表注入\"minecraft:flame\"\n}\n```\n\n## 自定义Forge注册表\n通常自定义注册表可以只是一个map，但它对已有的注册表有强烈的依赖。并且它要求所有数据手动地在客户端和服务器间同步。\n因此Forge提供了`RegistryBuilder`，用于更好地管理自定义注册。\n\n`RegistryBuilder`类含有多个参数（包括注册表名，它所注册的类型，以及多个应对注册表事件的回调函数）。新的注册表会在启动`NewRegistryEvent`事件后被注册到`RegistryManager`中。\n\n注册表所注册的类必须实现`IForgeRegistryEntry`接口，其中定义了`#setRegistryName`和`#getRegistryName`。除了直接实现接口，这里也推荐继承默认实现类`ForgeRegistryEntry`。当`#setRegistryName(String)`被调用时，如果那个String没有明确的命名空间，它的命名空间会被设为当前的MODID。\n\n新创建的注册表要调用它关联的注册方式去注册其关联的物体。\n### 使用`NewRegistryEvent`\n通过`RegistryBuilder`调用`#create`，返回一个supplier-wrapped registry。在`NewRegistryEvent`被提交到模组事件总线后，该注册表就可被访问。如果在`NewRegistryEvent`完成前试图获取自定义注册表，会返回`null`。\n### DeferredRegister\n`DeferredRegister`方法又是上述事件的另一种包装。当`DeferredRegister`被带有注册名，MODID的`#create`创建在常量域，注册表可以由`DeferredRegister#makeRegistry`构造。\n※[暂略](https://mcforge.readthedocs.io/en/1.18.x/concepts/registries/#with-deferredregister)\n\n## 处理遗失的注册条目\n※[暂略](https://mcforge.readthedocs.io/en/1.18.x/concepts/registries/#handling-missing-entries)\n## 笔记\n> enclosing class:外部类\n>\n> nested class:嵌套类(其中non-static nested class==inner class)\n>\n> inner class:内部类\n","tags":["编程","游戏","Java"],"categories":["游戏制作","从零开始做mc模组"]},{"title":"Java坦克大战个人总结","url":"/2022/04/29/my-TankWar-conclusion/","content":"\n&emsp;&emsp;刚学完Java，为了巩固所学，做了个坦克大战。这次主要挑战了下自定义地图和敌人寻路两个功能。\n\n<!--more-->\n\n## 自定义地图\n\n自定义地图比较简单，只要将地图作为外部文件读取就可以了。\n\n如这么一个txt文件，W是墙壁，P是玩家起始位置，E是敌人起始位置（可以有多个）：\n\n>WWWWWW\n>WPOOOW\n>WOOOEW\n>WWWWWW\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar.png)\n\n读取文件基本结构：\n\n```Java\n\t String filePath=\"../maps/\"+name+\".txt\";//用String生成文件路径，可以根据传入的name读取不同文件\n        InputStream inputStream=getClass().getResourceAsStream(filePath);\n        int data;\n        try {\n            while((data=inputStream.read())!=-1){//read()返回-1，说明读取完毕\n                char ele=(char)data;//将以整数读取的数据转换为字符\n                ......\n            }\n        }\n```\n\n## 敌人寻路\n&emsp;&emsp;常用的寻路算法有广度优先搜索，A-star算法等等。但这次我还是打算自己挑战一下写一个适合这个程序的算法。~~其实是没学会怎么写~~\n最后经舍友启发，写出了一个虽然不是最优路径，但很简短的寻路算法。\n\n### 核心思路\n从起点开始依次遍历相邻方格，并让它们指向起点的方向（好比单向链表），形象点说就是在所有可以行走的方格画上箭头，指向起点。待所有方格填完，再从**终点**沿着箭头寻回起点，就形成了一条唯一的路径。（最后还要反转一下）\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar2.png)\n\n### 地图存储方式\n对于寻路来说，不需要知道地图的所有信息，只要知道每个方格能否通过就行。\n```Java\n//单个结点\npublic class Node {\n    int Px;\n    int Py;\n    boolean canPass;//是否可以通过（水流，墙壁为无法通过的地形）\n    Node last=null;//用于在寻路算法中形成指向起点的链表\n}\n//用Vector存储结点集合\nVector<Node> nodes=new Vector<Node>();\n//用于获取相邻4个结点中可以通过的方格的方法，在后续寻路时起到重要作用\n    Vector<Node> neighbors(int x,int y){\n        Vector<Node> neighborNodes=new Vector<Node>();\n        for(Node n:nodes){\n            if((n.Px-x==-1||n.Px-x==1)&&(n.Py==y)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n            if((n.Px==x)&&(n.Py-y==-1||n.Py-y==1)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n        }\n        return neighborNodes;\n    }\n```\n\n用Graph类存储所有方格的信息，并提供寻路中要用到的算法：\n```Java\npublic class Graph {\n    Vector<Node> nodes=new Vector<Node>();\n     void setGraph();//根据读取的文件初始化所有方格的信息（略）\n     void clearAll();//使所有node的last=null，以便下一轮寻路（略）\n     Node findNode(int x,int y);//根据坐标找到相应的node（略）\n     void setVector(Node now);//核心算法，给所有方格填上箭头\n     void setRoute(Node start,Node goal,Vector<Node> route);//寻回起点，形成路径\n     Vector<Node> reverseRoute(Vector<Node> route);//反转路径【Vector竟然没提供（略）\n}\n```\n\n### 寻路算法\n\n```Java\nvoid findRoute(){\n    Vector<Node> newRoute=new Vector<Node>();\n    int Tx=MyPanel.player1.p_x;\n    int Ty=MyPanel.player1.p_y;\n    Node start=graph.findNode(p_x,p_y);//自身所在位置\n    Node goal=graph.findNode(Tx,Ty);//目标所在位置\n    graph.setVector(start);//“画箭头”的方法\n    graph.setRoute(start,goal,newRoute);//从终点寻回起点，形成路径\n    route=graph.reverseRoute(newRoute);//反转路径，从起点指向终点\n    graph.clearAll();//清除所有箭头\n}\n```\n### 用递归\"画箭头\"\n\n```Java\nvoid setVector(Node now){\n    for(Node n:neighbors(now.Px,now.Py)){\n    \t//对于now相邻的每个方格n，如果还没有画上箭头，就让n.last=now\n        if(n.last==null){\n            n.last=now;\n            setVector(n);//递归，直到其相邻方格均画上箭头就停止\n        }\n    }\n}\n```\n\n### 从终点寻回起点，形成路径\n```Java\nvoid setRoute(Node start,Node goal,Vector<Node> route){\n    Node now=goal;\n    route.add(now);//将now从终点开始沿着箭头位移，并加入到route\n    while(!now.equals(start)){\n        now=now.last;\n        route.add(now);\n    }\n}\n```\n\n## 多线程能做的事\n&emsp;&emsp;本次坦克大战和飞机大战相比，最大的不同还是用到了多线程。在专业的游戏中，渲染引擎，物理引擎等都是在不同线程下以不同频率工作。相比单线程，更加发挥出了硬件的性能，流畅地运行计算量更大的游戏。\n我在坦克大战中，将每个敌人作为一个线程，同时每个敌人的【攻击判断，移动，路径生成】为单独的线程，路径每隔3秒生成一次，攻击判断和移动间隔为30毫秒。\n将行为包装为抽象类，子类行为只要重写job()和canUse()方法就行\n```Java\n//run()为启用线程时执行的方法，job()为抽象方法，子类须重写\n    public void run(){\n        while(KEY!=0){\n            if(canUse()){\n                job();\n            }\n            try {\n                Thread.sleep(30);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    };\n```\n\n刚刚接触多线程，设计还不到位（比如没有把渲染和物理分离），希望在将来的学习中改进。","tags":["编程","大学生活","游戏","Java"],"categories":["游戏制作"]},{"title":"飞机大战-详细流程","url":"/2022/04/09/my-GameMakingProcess/","content":"\n记录一下详细的流程\n<!--more-->\n\n## easyX库\n\n[easyX](https://easyx.cn/)是针对C++的免费绘图库，在制作飞机大战时，需要用该库中的函数来绘制图像。\n**下载安装该库后，使用时需要包含头文件<graphics.h>**\n下面是一定需要用到的函数：\n\n### initgraph(width,height)\n&emsp;&emsp;用于初始化一个宽为width，高为height的绘图窗口\n&emsp;&emsp;默认不会打开控制台，但如下填入第三个参数，可同时打开控制台，用于调试。\n（比如给一个函数加上cout<<\"success\",检测有没有调用这个函数）\ninitgraph(width,height,EW_SHOWCONSOLE)\n&emsp;&emsp;第三个参数还可以填入其他值，详见[文档](https://docs.easyx.cn/zh-cn/initgraph)\n\n### cleardevice()\n&emsp;&emsp;使用当前背景色（默认为黑）清空绘图窗口。在显示新画面前一般都要调用这个函数\n### loadimage(&img,_T(\"./image.png\"))\n&emsp;&emsp;将图片加载到img(该变量名可以自定义)这个对象上。至少填入两个值，前一个为easyX的IMAGE类的对象（要传入其地址），后一个在引号内填图片的路径\n&emsp;&emsp;IMAGE类是easyX这个库自带的对象，用于保存图片的各种数据。\n&emsp;&emsp;其成员函数getwidth()/getheight()返回图片的宽/高\n&emsp;&emsp;为了在其他电脑上也能正确找到图片地址，路径应使用相对路径\n\n### putimage(x,y,&img)\n将先前加载的图片绘制到窗口上。参数为**图像的左上角在窗口上对应的坐标**\n\n### easyX的坐标系\n需要注意的是，easyX的坐标系默认是以**向右为正，向下为负，以窗口左上角为原点**。且所有图片的定位都是看其左上角对应的坐标。\n绘制图像时，坐标可以为负数或超出窗口的宽高，这样的话会绘制一半在窗口中，或完全不显示在窗口中。（但该图像依然存在）\n\n## 文件的结构\n和以往的作业不同，这是一个较大的项目。一方面，代码里包含了许多的类，另一方面，在程序本身之外还有图像等资源文件（统称为assets）。如果把所有类写在一个文件，改写的时候就非常难找，因此最好尝试把各个类分文件写\n大致这样👇\n\n```\nspacewar//根目录\n\t├── main.cpp\n\t└── player.cpp\n\t└── enemy.cpp\n\t└── images//文件夹，用于存放所有图像文件\n```\n\n在包含另一文件时，有以下两种方法：\n\n>#include <graphics.h> //用尖括号表示优先查找系统文件\n>#include \"player.cpp\" //用引号表示优先从当前文件夹查找，自己写的文件都最好用这个方法\n\n\n## 游戏的架构\n\n### 外层结构\n要想做一个画面实时变化的游戏，就要像视频一样，以人眼难以分辨的频率去不断绘制画面，因此，程序的最简结构如下：\n```C++\nint main()\n{\n\tinitgraph();//初始化绘图窗口\n\tinit各种东西();\n\t//初始化需要用到的所有变量，包括但不限于玩家飞机，敌人系统，分数，道具系统等等\n\twhile(1)\n\t{\n\t\t//游戏的主循环，每一轮循环都要画出所有元素，一次循环为一帧\n\t}\n}\n```\n### 主循环\n\n虽然每个人做的游戏规则不同，但在主循环中，大致要做如下的事情（执行顺序要视情况调整）：\n* 判断玩家，敌人，子弹间的碰撞\n* 按照一定频率生成敌人，道具等\n* 接收玩家输入的操作，并处理结果\n* 绘制玩家，敌人，子弹，分数等元素，同时处理移动\n* 控制帧率\n\n其中控制帧率最简单的方法是在循环的结尾加Sleep()\n```C++\n\tSleep(time);//需要头文件<windows.h>\n\t//time为毫秒，例如time=33.3时，帧率(FPS)为30，即每秒刷新30次画面\n```\n实际上在sleep()前执行函数的时间也要计算，但飞机大战这个规模还没有什么影响，就忽略不计了\n\n### 接收玩家指令的方式\n\n\"\\_kbhit()\"函数在用户按下按键时返回true，否则返回false\n\"\\_getch()\"函数**等待并返回**用户按下按键的ASCII码\n只使用\\_getch()，程序需要等待用户输入按键，也就会导致玩家不动，敌人也不动的现象。\n这里专门给玩家设置一个执行指令的函数，是为了后续能清楚地分清与玩家相关的指令和不相关的指令。\n\n```C++\n\tif (_kbhit())\n\t{\n\t\tchar cmd = _getch();\n\t\tswitch (cmd)\n\t\t{\n\t\t//调用玩家对象的command函数\n\t\tdefault:Player.command(cmd); break;\n\t\t}\n\t}\n```\n\n### 试着先让自己的飞机动起来\n我自己在写的时候也不是一次性就加入敌人，子弹等等内容，先别想那么多，让飞机在窗口上动起来🎵\n\n```C++\nclass player{\nprivate:\n\tint m_x;\n\tint m_y;\n\tint m_speed;\n\tIMAGE m_img;\npublic:\n\tplayer()\n\t{\n\t\t//载入图片\n\t\tloadimage(&m_img, _T(\"./images/player.png\"));\n\t\t//先随便给个值，但注意不要超出窗口大小！\n\t\tm_x=100;\n\t\tm_y=100;\n\t\tm_speed=10;\n\t}\n\tvoid drawPlayer()\n\t{\n\t\t//绘制玩家的函数\n\t\tputimage(m_x, m_y, &m_img,);\n\t}\n\tvoid command(char cmd)\n\t{\n\t\t//执行玩家指令的函数\n\t\tswitch (cmd)\n\t\t{\n\t\t//根据指令让对应坐标+或-速度\n\t\tcase 'w':m_y-= m_speed; break;\n\t\tcase 'a':m_x-= m_speed; break;\n\t\tcase 's':m_y+= m_speed; break;\n\t\tcase 'd':m_x+= m_speed; break;\n\t\t}\n\t}\n```\n将它放到main函数中：\n```C++\nint main()\n{\n\tinitgraph(500,800);\n\tplayer Player;\n\twhile(1)\n\t{\n\t\tcleardevice();\n\t\tPlayer.drawPlayer();\n\t\tif (_kbhit())\n\t\t{\n\t\t\tchar cmd = _getch();\n\t\t\tswitch (cmd)\n\t\t\t{\n\t\t\tdefault:Player.command(cmd); break;\n\t\t\t}\n\t\t}\n\t\tSleep(50);\n\t}\n}\n```\n\n## 设计类\n\n以我的做法，最少需要4个类：玩家，子弹，敌人，敌群\n其中【玩家，敌人，子弹】都有共通的属性：坐标，速度，宽高，因此可以继承自一个Object类。\n**敌群**这个类的作用，在于管理所有的敌人。因为所有的敌人都需要和玩家判断碰撞，并且在超出屏幕时及时删除\n敌群类(enemies)和敌人类(enemy)不同于继承，叫做组合，是“A有B”的关系。\n\n#### object类\nobject基类很简洁，只需要记录几个必要信息，并做所有物体通用的碰撞检测\n```C++\nclass object {\nprotected:\n\tint m_x;//横坐标\n\tint m_y;//纵坐标\n\tint m_width;//图像宽度\n\tint m_height;//图像高度\n\tint m_speed;//速度\n\tint map_width=550;//窗口宽度(用于判断越界)\n\tint map_height=850;//窗口高度\npublic:\n\t//判断碰撞的函数，使用时传入子类指针就行。不用static其实也可以\n\tstatic bool isHit(object* ptr1,object* blt);\n```\n\n※isHit()详见[第一次游戏制作](https://ustb-lzm.gitee.io/ustb-lzm/2022/03/26/my-firstGame/)\n\n#### 敌人类&敌群类\n敌人最少只要object所继承的属性外加一张图片就可以。\n敌群要控制敌人的生成，\n```C++\nclass enemy:public object {\n\tfriend class enemies;//将权限给敌群类\nprivate:\n\tIMAGE m_img;//用于保存敌机图片的IMAGE对象\n\t…………\n}\n\nclass enemies {\n\tint enemyCount;//记录敌人数量(但我并没用到)\n\tint interval;//敌人产生的间隔\npublic:\n\tenemy* ePtr[30] = { 0 };//敌人类指针数组,上限为30个敌人\n\tvoid createEnemy();//生成敌人\n\tvoid drawEnemies();//绘制所有敌人\n\tvoid deleteEnemies();//删除死亡/超出屏幕的敌人\n\tint isEnemiesHit();//给每个敌人判断碰撞\n\tvoid shoot();//如果敌人可以发射子弹，最好在敌群类统一管理（要和玩家判断碰撞）\n```\n\n### 子弹类\n```C++\nclass bullet:public object {\nprivate:\n\tIMAGE m_bullet;\n\tdouble m_angle;//发射角度\npublic:\n\tvoid drawBullet()\n\t{\n\t\tputimage(m_x, m_y, &m_bullet);\n\t\tm_x += m_speed * sin(m_angle);//所有子弹通用的移动，只需确定方向和速度\n\t\tm_y += m_speed * cos(m_angle);//但要注意x和y为整数，角度太细会丢失精度\n\t}\n\tbool isOut();//判断子弹是否超出屏幕\n```\n\n### 玩家类\n```C++\nclass player:public object {\nprivate:\n\tIMAGE m_img;\n\tbullet* m_blt[50] = { 0 };\npublic:\n\tvoid shoot();//发射子弹\n\tvoid command(char cmd);//接收指令\n\tbool judgeOverflow(char cmd);//移动时判断防止超出屏幕\n\tvoid drawPlayerAndBullet();//绘制玩家和子弹\n}\n```","tags":["编程","大学生活","游戏","C++"],"categories":["游戏制作"]},{"title":"第一次游戏制作","url":"/2022/03/26/my-firstGame/","content":"\n&emsp;&emsp;因学校程序设计课的作业要求，第一次游戏制作献给了飞机大战。一开始还嫌麻烦，但基本框架打好之后就得心应手了，开始添加各种元素，比玩游戏还上头🤩三天能交的作业硬是拖了一周\n&emsp;&emsp;本来还有各种主意想要实现，但再做下去也学不到什么新东西了，就暂且割爱了。\n\n<!--more-->\n\n## 起因\n\n>游戏的编写能用到C++学习过程中的很多知识，数组、函数和面向对象。这个练习是一个开放式的练习，你可以在基本要求的基础上进行任何扩充。\n>游戏编写的基本要求，参看附件。\n>\n>>扩充下游戏1定义的飞机大战游戏的功能：\n>>增加多个界面，初始化界面，说明游戏功能；结束界面，提示用户的得分情况，以及是否开始一个新的游戏；\n>>随着积分的增加，可以考虑增加难度，加快敌机的下落速度，和出现的速度；\n>>功能上做更多的性能处理：例如防止玩家操控飞机飞出边界，击中/碰撞检测的处理\n>>增加按Esc键后游戏暂停的功能\n>>增加图形界面（EasyX,Qt, MFC）以及面向对象的程序设计\n\n>要求：提交完成一定功能或性能扩充后的源代码，以及一个word文档，说明你做的功能完善的目标，设计以及程序实现和测试效果。\n\n虽说是作业，但毕竟是值得纪念的第一作，因此我决定发挥自己目前最大水平做个完整的游戏。\n\n## 游戏下载\n\n※有闲空的可以玩玩看，就是普通的飞机大战。\n（Win10应该能正常运行，Win7没试过）\n\n规则：\n* wasd移动，空格切换子弹类型，q使用道具，esc暂停，道具只能存一个\n* 敌人的血量，频率，移速会随着score增加而增加\n\n>链接：https://pan.baidu.com/s/1iB6d0R82fL6XXXTTvJWdIA \n>提取码：0519\n\n## 游戏制作\n### 绘图库的选择\n&emsp;&emsp;使用的是[EasyX](https://easyx.cn/),在上学期刚入门C++的时候正好用过就沿用了，简单易上手。\n\n### 文件结构\n![image-20220326132332034](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20220326132332034.png)\n图中父子结点表示class的继承关系（右继承左）\n其中（itemSystem--itemBlock),(enemies--enemy)是友元关系\n\n* enemies（敌群）用于初始化敌人的类型，速度等参数，并随着得分情况而改变产生敌人频率。\n* itemSystem作用和enemies相同，控制道具的生成类型和生成频率\n* object父类成员为所有和物体位置相关的变量，以及一个处理碰撞的函数\n* player包含一个bullet指针数组，用于一并管理玩家发出的所有子弹，方便和敌人进行碰撞判断(enemies同理)\n\n### 操作输入结构\n\n这个方法一次只能接收一个指令，无法做到斜方向的丝滑移动。希望在今后的学习中找到改进方案\n```C++\n//判断输入暂停还是玩家操作\nif (_kbhit())\n{\n\tchar cmd = _getch();\n\tswitch (cmd)\n\t{\n\t\tcase 27:systemPause(); break;\n\t\tdefault:p1.command(cmd); break;\n\t}\n}\n```\n\n```C++\n//玩家操作输入（judgeOverflow用于判断玩家是否超出窗口）\nvoid command(char cmd)\n{\n\tswitch (cmd)\n\t{\n\tcase 'w':\n            if (judgeYOverflow(cmd))m_y-= m_speed; break;\n\tcase 'a':\n            if (judgeXOverflow(cmd))m_x-= m_speed; break;\n\tcase 's':\n            if (judgeYOverflow(cmd))m_y+= m_speed; break;\n\tcase 'd':\n            if (judgeXOverflow(cmd))m_x+= m_speed; break;\n\tcase 'q':\n            useItem(); break;\n\tcase ' ':\n            //实现在0~3号子弹发射模式中切换\n            bltType = ((bltType == 3) ? 0 : bltType+1); break;\n\t}\n}\n```\n\n\n### 问题-1 解决运行时闪屏问题\n&emsp;&emsp;在绘制图像过多时，EasyX会出现不定时闪屏问题，为此需要使用批量绘图函数\n详见：https://docs.easyx.cn/zh-cn/BeginBatchDraw\n\n```C++\n\tBeginBatchDraw();\n\twhile(1)\n\t{\n\t\t//各种元素的绘制函数\n\t\tFlushBatchDraw();//将之前绘制的图像一并输出倒窗口上\n\t}\n\tEndBatchDraw();\n```\n\n### 问题-2：对不规则物体判断碰撞\n&emsp;&emsp;常规的判断碰撞就是用两物体的x,y,width,height比较，但由于子弹和飞船形状都不是矩形，使用上述方法会导致判定过于宽松，玩家死都不知道怎么死的🐕。\n\n我的改进方案：\n在常规判断法之外，利用EasyX库中getpixel()扫描子弹即将达到的位置区域内有没有背景色以外的颜色。这样的话就可以把误差减小到子弹的方格(大概3px内)\n\n缺点：\n\n* 因判断条件，背景色不能过多(最终我的背景是双色)。\n* 如果子弹面积过大的话边角误差也较大\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/hitRange.png)\n\n```C++\n\tstatic bool isHit(object* ptr1,object* blt)\n\t{\n\t\tif (ptr1 == 0 || blt == 0)\n\t\t\treturn false;\n\t\tif (ptr1->m_x - blt->m_x > blt->m_width || ptr1->m_x+(ptr1->m_width)<blt->m_x)\n\t\t\treturn false;\n\t\tif (ptr1->m_y - blt->m_y > blt->m_height || ptr1->m_y+(ptr1->m_height)< blt->m_y)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < blt->m_width;i++)\n\t\t{\n\t\t\tfor (int j = 0; j < blt->m_height; j++)\n\t\t\t{\n\t\t\t\tif (getpixel(blt->m_x + i, blt->m_y + j) != BLACK\n                    && getpixel(blt->m_x + i, blt->m_y + j) != 0x000033)\n\t\t\t\t{return true;}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n```\n\n### 问题-3：无法输出透明图片\n&emsp;&emsp;EasyX不支持输出带Alpha通道的png图片，但在游戏进行时会出现很多元素重叠的情况，为了防止图片的黑边挡住下面的图片，需要做透明化处理\n解决方案：利用三元光栅操作，对图片进行位运算\n详见：https://blog.csdn.net/q781634081/article/details/108107639\n```C++\n\t//加载图片\n\tloadimage(&m_img, _T(\"./images/enemy_normal.png\"));\n\tloadimage(&m_alpha, _T(\"./images/enemy__normal_alpha.png\"));\n\t//输出图片\n\tputimage(m_x, m_y, &m_alpha, SRCAND);\n\tputimage(m_x, m_y, &m_img, SRCPAINT);\n```\n\n### 问题-4：窗口大小受系统设置影响，显示不全\n&emsp;&emsp;在打包游戏发给室友测试的时候，发现游戏窗口的大小和预想中的不一样，原因是显示设置中修改了缩放比例。为了在不同缩放比例的电脑上都能正常显示，使用了以下方式。\n\n详见[创建一个不受系统缩放设置（DPI）影响的绘图窗口 - CodeBus](https://codebus.cn/yangw/dpi-awareness)\n\n```C++\n#define WINVER 0x0A00\n#define _WIN32_WINNT 0x0A00\n#include <ShellScalingApi.h>\n#pragma comment(lib, \"Shcore.lib\")\n\nSetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE);  \n```\n\n## 心得\n&emsp;&emsp;生涯第一次制作完整的游戏，还是非常兴奋的。此前一直想学Unity，但作为计算机专业还是要加强底层设计能力。耗时一周，共900多行代码，虽然对我来说算是一次不小的挑战，但跟独立游戏的规模比起来，还是“路漫漫其修远兮，任重而道远。”【By初中物理老师\n&emsp;&emsp;除了代码之外，图像制作也是一大麻烦事，而且技术要求也不低。本次游戏只有爆炸效果有3帧的动画，其他元素都是一图流🏳\n\n","tags":["编程","大学生活","游戏","C++"],"categories":["游戏制作"]},{"title":"unsignedchar的学习","url":"/2022/01/27/my-study-UnsignedChar/","content":"\n实际上是借助容量最小的unsigned char类型学习位运算的应用\n\n<!--more-->\n\n## unsigned char 与 char 的区别\n\nchar的最高位为符号位，而unsigned char无符号位，因此：\n>char：-127~127\n>unsigned char：0~255\n\n## unsigned char 闭环\n当unsigned char取得负数**x**时，其值相当于**(256-|x|)**\n\n例：![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201272027432.png)\n<details>\n<summary>答案</summary>\n<b>10 + 246 = 256, C</b>\n</details>\n\n\n## 将unsigned char作为Flag使用 \n```c++\nunsigned char flags = 0; //共8位,每位表示一个Flag\n//用枚举类型保存至多8个flag\n//（实际情况下每个flag都有具体名称表示）\nenum{\n    Flag1,Flag2,Flag3,Flag4,\n    Flag5,Flag6,Flag7,Flag8,\n};\n//检测某个Flag开闭状态的函数\nbool checkFlag(unsigned char f){\n    //\n    unsigned char t = flags;\n    t >>= f;//相当于t = t/(2^f);\n    t <<= 7;//相当于t*128,如果t为奇数，结果为128，否则为0\n    return (t != 0) ? true : false;\n}\n//开启某个Flag的函数\nvoid setFlag(unsigned char f){\n    flags |= (1 << f);\n}\n//关闭某个Flag的函数\nvoid resetFlag(unsigned char f){\n    flags &= ~(1 << f);\n}\n//验证，输出‘success’\nint main(){\n    setFlag(Flag2);\n    if (checkFlag(Flag2))\n    {\n        cout << \"success\";\n    }\n    else\n        cout << \"failure\";\n}\n\n```\n\n上述代码中，enum型的Flag1~8的值为0~7，为了让它们对应到8bit中的每位，在setFlag()和resetFlag()中要进行位移操作：\n```C++\n1<<f //将1向左移动f位,相当于2^f\n```\n\n","tags":["编程","C++"],"categories":["程序设计"]},{"title":"程序设计题目——整数分治","url":"/2022/01/15/my-programing-Problem/","content":"\n## 题目\n&emsp;&emsp;程序设计专业课期末考试上的一道题：\n>**输入两个整数n，k，将n划分为k个整数，且每份均不能为0。求共有多少种划分方案**\n>※没有顺序之分，比如对于n=4,k=3,(1,1,2)和(2,1,1)只能算一种方案。\n>输入样例：7 3\n>输出样例：4\n\n当时考试还剩20分钟，本想着绰绰有余，但没带草稿纸而本人又是心算苦手，就直接白给 ~~但最后还是抖机灵把样例输出凑上了~~\n\n<!--more-->\n\n## 思路\n&emsp;&emsp;对于每个数据**n**(n>k)，由于每一份都不能为“0”，所以我们可以首先从**n**中拿出**k**个“1”而不改变结果。假设我要使用 **Func(n,k)** 使其输出答案 **A**，则：\n```\n\tA == Func(n,k) == Func(n-k,k) + S\n```\n&emsp;&emsp;在拿出**k**个“1”后，要注意剩下的 **(n-k)** 是可以分出“0”的，所以在 **Func(n-k,k)** 的基础上还要加一个**S**。\n&emsp;&emsp;而S为：将**n**分成**k**份，且其中有**1~(k-1)** 个“0”。\n&emsp;&emsp;由此推出，对于给定的 **n**和**k**，：\n\n```\n\tS == Func(n,k-1)+Func(n,k-2)+…+Func(n,1)\n```\n将第一条等式中的S替换，就可以得出：\n```\n\tA == Func(n,k) == Func(n-k,k)+…+Func(n-k,1)\n```\n到这一步，递推关系已经出来了，接下来是寻找结束条件。\n* 首先不难想到，**k==1**时，**Func(n,1)==1**\n* 其次考虑当**n==k**时，**Func(n,k)==1**\n* 当**n<k**时，**Func(n,k)==0**\n\n## 代码\n```cpp\nint Func(int n, int k)\n{\n    if (k == 1||n == k)\n        return 1;\n    else if (n < k)\n        return 0;\n    else\n    {\n        int sum = 0;\n        n = n - k;\n        while (k >= 1)\n        {\n            sum += Func(n,k); \n            k--;\n        }\n        return sum;\n    }\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    cout << Func(n,k);\n}\n```\n递归题虽然思考过程很痛苦，但看到写出来的代码如此简介还是很爽👍\n","tags":["编程","大学生活","C++","递归","算法"],"categories":["程序设计"]},{"title":"【翻译】大学生为了制作一部游戏而经历的地狱","url":"/2022/01/14/trans-make-game-bymyself/","content":">原文链接：\n>[大学生が自作ゲームを1本作るまでに経験した数々の地獄のお話](https://note.com/dom_cob1/n/n8eaf211cba2b?magazine_key=mcaf9d5648d65)\n>原作者：\n>[Matsumoto](https://note.com/dom_cob1/)\n\n## 译者摘要\n这篇文章讲述了一位非科班的大学生从学习编程，到最后制作出一款完整的游戏所经历的种种磨难。从他的回忆中，我能感受到作者满溢的创作热情，其中的许多经验，以及最后的话语也给我莫大的鼓励和启发。\n<!--more-->\n\n## 前言\n&emsp;&emsp;初次见面。虽然有些唐突，但各位！\n&emsp;&emsp;一定也有过“人生至少要做一次游戏制作者！”这样的想法吧。\n&emsp;&emsp;这篇文章讲述的就是我，从大二开始学习制作游戏，到实际完成所经历的种种地狱。\n&emsp;&emsp;至于为什么把这件事特意写成文章，在最后会解释。\n&emsp;&emsp;不限于游戏，如果你正想要开始某些事情，请务必看一看。\n\n## 经济学院的地狱\n&emsp;&emsp;常说“如果没有想做的事，就先去大学增加未来的选项”,但我想对高中时的自己说，并不是到了大学就会找到想做的事情。\n&emsp;&emsp;什么都没考虑就选择了经济学。\n&emsp;&emsp;课程对我而言很无聊不说，还因为看不起经济学院那群逼王，没有交到朋友，大概有一年没去学校。\n&emsp;&emsp;在那个时期我开始思考就职的事情，而一看同学的求职方向大多都是银行，证券公司，周围的人就像坏掉的机器人一样一天到晚求职咨询。而且大家比起说是对工作内容感兴趣，嘴上聊的都是年收入和头衔的话题。而我，一边觉得他们扯淡，却也找不到自己想做的事。\n&emsp;&emsp;从这个时候，我开始思考自己真正想做的事情。\n\n## 编程的地狱\n&emsp;&emsp;因为觉得编程就像黑客一样酷炫，我决定学习编程。\n&emsp;&emsp;因为编程的话题根本不好玩，所以我就不展开来谈了，但大约遇到过5次挫折。\n&emsp;&emsp;看不懂写着“猫也能看懂”的书而对猫肃然起敬；搞不来环境配置而扬言自己的电脑不适合编程；去向工学院的教授问“安装”是什么意思被批了一通等等。\n&emsp;&emsp;但我想对接下来要学习编程的所有人说一句话。\n**就算完全不懂也没关系，尝试着自己去使用它**\n&emsp;&emsp;这点非常重要，像考试科目那样“先掌握基础，再去理解整体~”这样的学法对编程是不怎么管用的。\n&emsp;&emsp;还有就是不要去看推特上的大佬。  \n\n经过一段时间后，我就试着用python做了一个2048。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141420300.png' width=60%></span>\n&emsp;&emsp;当看到程序按照自己所想的一样运作时，我从中第一次感受到了游戏制作的乐趣。\n&emsp;&emsp;建议在学编程学完函数和类左右的时候，可以试着自己思考做些程序。\n\n## 从Python转到C++的地狱\n&emsp;&emsp;因为有人说做游戏的话学C更好，我就开始学习C++。\n&emsp;&emsp;了解过的人应该知道，C++和Python完全不同。差不多就像Wii Sports的保龄球和真实的保龄球那种程度不同。\n&emsp;&emsp;开始出现指针，变量声明之类从未接触的术语，而且又败在了环境配置这一步。\n&emsp;&emsp;编程初学者的最大敌人就是环境配置。具体就不展开说了，但如今我更喜欢易阅读的C++。\n\n## Unity的天堂\n&emsp;&emsp;就算是没有做过游戏的人，想必也听说过Unity。简而言之就是能做游戏的工具。\n&emsp;&emsp;第一次接触的时候，得知它能演算重力，判定碰撞等等各种事情，让我非常感动。\n&emsp;&emsp;在Unity中需要用到C#这门语言，但就算没学过也问题不大，在想要实现某种功能时现查就可以了。\n&emsp&emsp;就像先前说过的，“尝试着自己去使用它”。我就在按照书本制作游戏的途中记住了编程的方法。\n&emsp;&emsp;实际看到自己的角色动起来的时候，真的是很有乐趣。\n\n## 实习的地狱\n&emsp;&emsp;就在这个时期，我看机会难得，就参加了游戏公司的实习。\n&emsp;&emsp;因为要进行作品评比，我花了一个月左右，从ddl三天前开始熬夜赶工做出了以下这款游戏。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141437310.png' width=60%></span>\n&emsp;&emsp;游戏机制什么的都比较单薄，而且说实话比看上去还要不好玩，道具按钮也只是个单纯的按钮。\n&emsp;&emsp;但毕竟是独立完成的游戏，就自信满满参加了评比会。\n&emsp;&emsp;轮到我发表的时候，本来还自信满满的，但被问到有趣在哪里，怎么游玩的时候却几乎答不上来。\n&emsp;&emsp;轮到下一个人——“这是日本游戏大奖的获奖作品……”\n&emsp;&emsp;再下一个人——“这是我拿去参加韩国的比赛的作品……”\n&emsp;&emsp;再下一个人——“这是可以在Wii上运行的……”\n&emsp;&emsp;差不多到这个时候我就感觉社死了，心情非常消沉，觉得自己完全不是一个水平。\n&emsp;&emsp;轮到最后一个人——“对不起，看了别人的作品我还是决定不拿出来献丑了……”\n&emsp;&emsp;正当我为找到同伴而稍微安心的时候，评委说就算这样也可以拿出来看一看。确实作为游戏的完成度还不够，但想法非常有创意。很难具体表达，但我感觉像是能火的有趣作品。\n&emsp;&emsp;那天以后，我想着自己又没技术，又没创意，全都玩完了，过了一段暴饮暴食的日子。\n\n## 想不出创意的地狱\n&emsp;&emsp;后来我的精神又恢复了过来，准备再次挑战的时候，却迟迟没法下手。\n&emsp;&emsp;以往我只是把角色动起来就很满意了，但这次开始觉得如果不好玩的话做出来也没有意义。\n&emsp;&emsp;无法忘记在评比会上看到的那些游戏专业学生的作品，或是有足够创意的作品，尤其是那个拿了大奖的作品，我还经常想起来，在油管上反复观看。\n&emsp;&emsp;那个悲惨时期的我就只能跟朋友吹吹“我跟这样的大佬一起参加过实习”。\n&emsp;&emsp;只是，多亏实习的失败经历，我查阅了很多GameJam，游戏奖，独立游戏等等相关的资料，并认识了很多优秀的游戏。\n&emsp;&emsp;然后我想着先不管怎么说要做点东西出来，就把想到的主意逐个做成了demo。\n&emsp;&emsp;以下是我废弃的辣鸡游戏，追悼。\n\n* 边躲避激光边搬运武器的游戏\n* 移动箭头对战的游戏\n* 数字俄罗斯方块（想法还可以就是没能做出来）\n* 把战车和洗车混合的游戏<font color='gray'>(※日文中战车和洗车发音相同)</font>\n* 通过预知能力躲避攻击的游戏\n* 在自动扶梯上逆行的游戏\n* 让电梯恰好停住的游戏\n* 很多隐藏砖块的坑人游戏\n* 不容易被敌人干掉的游戏\n* 血条和蓝条共用的游戏\n* 改变角色大小的游戏\n* 立体停车场（没想好要怎么玩）\n* 屏幕画面之外非常乱的游戏\n* 变成虫子诱导人（已经有了）\n\n&emsp;&emsp;像这样做了很多游戏，虽然大部分都不是很有趣。但是！！最后有两个游戏存活了下来。\n* 关卡会旋转的游戏\n* 和透明的敌人战斗，然后重播后观看自己动作的游戏\n&emsp;&emsp;它们会在后文提到。\n\n## 编程的地狱 Part2\n&emsp;&emsp;既然做不出创意，就用编程能力一决胜负吧！然而，从结果来看就是我的错觉。在技术上取胜是世界第一难事。\n&emsp;&emsp;但总之，不能全部依赖引擎！要自己写出重力和画面！！！这么想着，我买了一本书——《在成为游戏工程师之前应该记住的技术》。\n&emsp;&emsp;真的是地狱。\n&emsp;&emsp;看了书之后我才发现自己至今的编程都只是图一乐。\n&emsp;&emsp;必须在完全理解了指针，继承，二进制等等才能看得进去。\n&emsp;&emsp;现在来看，那个时期学的知识都有很大的帮助，但我也不希望萌新看了这本书而被劝退。\n&emsp;&emsp;不过对于学编程比较轻松的人来说，我还是非常推荐这本书。\n&emsp;&emsp;顺便一提，我因为实在是搞不懂，至少敲了100次桌子，还在阳台大喊“谁tm搞这个”，也因为太过挫败深夜骑自行车去金阁寺，在推特上发过“我真是一无是处”，在麦当劳暴饮暴食吃胖了15kg。\n\n## 自制游戏的地狱\n&emsp;&emsp;好不容易看了书，事实后该不用引擎制作游戏了！这么想着，我完成了“关卡会旋转的游戏”。\n&emsp;&emsp;别看只有“完成了”这么三个字，过程是真的累死累活。当遇到报错的时候，那个波浪线总是划在不是我写的代码的地方（标准库），让我完全不知道哪里出了错。\n&emsp;&emsp;就好像是迷路的时候看一眼手机发现导航显示自己在大海上一样。\n&emsp;&emsp;这样的事情一天至少要发生10次。\n&emsp;&emsp;或许大佬不同，但我的话至少有70%左右的时间花在了寻找出错原因上面。\n&emsp;&emsp;这段时间又因为真的搞不懂而经历了暴饮暴食，去银阁寺的路上迷路，无所事事地改改字体大小等等。\n&emsp;&emsp;结果就完成了这么个游戏。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141716419.jpg' width=60%></span>\n&emsp;&emsp;图画是朋友帮忙画的，右下角的猫是玩家。\n&emsp;&emsp;虽然我写的都是怎么怎么受挫，但一旦不用引擎完成了自制游戏，那成就感是非同一般的。\n&emsp;&emsp;比如，从菜单到关卡选择的迁移方式都需要自己考虑，还自制了保存制成的关卡名的时候的文本框。\n&emsp;&emsp;一边怀疑自己是不是走偏了，一边又用谁也想不到的方法制作，运行成功的时候，我是发自内心感到兴奋的。\n&emsp;&emsp;我真是天才！！（然后30分钟后因为各种报错而崩溃)\n&emsp;&emsp;可惜最后还是有判定奇怪等种种问题，没能达到发行的质量。\n\n## 虚幻引擎的天国\n&emsp;&emsp;具体时间有些搞不清了，但我偶然看到这个视频，大受感动，开始使用虚幻引擎。\n\n>&emsp;&emsp;[虚幻5技术演示(B站)](https://www.bilibili.com/video/BV1Y5411s7Sa)\n\n&emsp;&emsp;就算现在再看也让我起鸡皮疙瘩，让我觉得“可以亲手创造这样美丽而充满激情的世界吗！”\n&emsp;&emsp;然后我就回想起纯粹制作游戏的感觉，开始学习虚幻引擎。\n&emsp;&emsp;虚幻引擎不需要任何编程就可以做游戏，利用一种叫蓝图的可视化脚本语言，让角色动起来，或是制作机关。顺便一提，我用它制作的游戏也一次都没有写代码。\n&emsp;&emsp;然后我就想，和之前不同，既然用了引擎就一定要做出有趣的游戏，把技术力抛在脑后，一个劲打磨游戏的趣味性。\n&emsp;&emsp;就在这时，我想到了“和透明的敌人战斗，然后重播后观看自己动作的游戏”，因为重播自己的动作很有趣，从而想到制作一款把自己的动作倒放，然后和倒放的自己合作的游戏。\n\n## 自制游戏的地狱 Part2\n&emsp;&emsp;虽然写着地狱，但和先前的游戏制作比起来，这次的经历绝对是最让我快乐的。\n&emsp;&emsp;一方面是自己对这个游戏的有趣程度有自信，一方面是由于引擎而让想法的实现变得简单了。\n&emsp;&emsp;但也有一些比较心累的地方：\n1. 看到推特上的大佬会无法避免地产生自卑感\n2. 存档和包装等为了游戏发行而不得不考虑的事情\n\n&emsp;&emsp;第一点想必对哪个领域都一样。真正厉害的人是真的厉害，不去看他们更好。写Qiita<font color='gray'>(日本一个工程师论坛)</font>的人也都是天才。他们的人生估计已经五周目了，一周目的我就满怀感激地接受教导吧。\n&emsp;&emsp;第二点应该是大多数人受挫的原因。同样是做游戏，随意制作的人和完整地制作一部的人是完全不同的。就像做意大利面也有买酱回来做的人和从酱开始做的人。除了包装之外，我也考虑了美工和建模等等问题。\n&emsp;&emsp;即便如此，这也是真的很快乐的事情。\n&emsp;&emsp;**不用去学会所有的东西**\n&emsp;&emsp;**只要查阅自己创作所需要的就行**\n&emsp;&emsp;**制作自己认为有趣的东西**\n&emsp;&emsp;**想象着自己的游戏大卖然后出名**\n&emsp;&emsp;以上这些应该就是感到快乐的原因。关于游戏的设计，我也看了不少制作人的演讲，游戏分析博主的视频等等，还疯狂拜托别人去试玩。\n\n## 开始怀疑是否有趣的地狱\n&emsp;&emsp;中途开始患上了担心这个游戏实际上没意思的病。不过后来知道这种情况在游戏开发者身上是常有的。\n&emsp;&emsp;当时问了朋友们对试玩版的感想，大家可能是比较善良，都说很好玩。我就坚信他们的话坚持了下来。\n&emsp;&emsp;顺便一提其中有一个朋友因为太过热衷而把大学考试全翘掉了，学科全挂。\n&emsp;&emsp;爱死你了！经济学院！\n\n## 游戏被别人玩的天国\n&emsp;&emsp;历经坎坷，游戏终于在steam上公开了试玩版，推特上的宣传也被转发了3742次！当时太过开心，给试玩的朋友门疯狂打电话。\n<font color='gray'>（※游戏名【Relash】steam上可以看到商店界面，现已停止试玩）</font>\n\n## 想说的话\n&emsp;&emsp;在刚刚接触游戏制作时，我觉得那些爆火的都是天选的人。但实际上到现在，我也依然边抱怨搞不懂边做着游戏。\n&emsp;&emsp;我写这篇文章，就是想让那些今后想要制作游戏的人意识到，“原来大家都会受挫折”，“做出没有意思的作品也是理所当然的”。\n&emsp;&emsp;我在开始制作游戏时，最想知道的，就是**不知道也没关系**。\n&emsp;&emsp;就是因为不知道这点，我好几次都差点放弃制作游戏。\n&emsp;&emsp;我还只是完成了一款游戏，但因为不想被别的开发者认为是在装逼，所以我会马上就说我并不厉害。\n&emsp;&emsp;但这正是在过去让我痛苦的话语。\n&emsp;&emsp;因为那些比我厉害的人，摆着一副这种程度理所应当的表情，所以才会觉得“是我不适合”。\n&emsp;&emsp;正因如此我才要勇敢地说出来，我能制作一款完整的游戏，是一件很厉害的事情，但更多地，是一件非常吃力的事情，充满了未知的事情。\n&emsp;&emsp;所以我才希望今后想要制作游戏的人意识到**不知道也没关系**，以“做出来就很厉害！”的心态去面对。\n&emsp;&emsp;以上就是我制作一款游戏所经历的种种地狱。\n\n## 笔记\n>肩書き(かたがき)：头衔，官衔\n>殆ど(ほとんど)：几乎\n> 垢(あか)：污垢，油泥\n> 遷移(せんい)：变迁，迁移\n> ダントツ：压倒性地出众，领先\n> 語呂合わせ(ごろあわせ)： 双关，谐音\n> 別格(べっかく)：特别处理，特殊待遇\n","tags":["游戏"],"categories":["游戏制作","翻译"]},{"title":"【翻译】古川本铺-聊聊作词的方法","url":"/2022/01/14/trans-hurukawa-lyric/","content":">原文链接：\n>https://sp.uta-net.com/today/news.php?id=12288\n>原作者：\n>古川本铺\n\n## 译者摘要\n古川本铺是我最喜欢的音乐创作者之一，在舒适的旋律之外，他的歌词也总是充满文艺，清新的色彩。本篇文章来自Uta-Net，日本的音乐资讯网站，讲述了古川本人创作歌词的过程。\n<!--more-->\n\n## 正文\n&emsp;&emsp;新年好，我是古川。\n&emsp;&emsp;从去年时隔六年复出，到现在也有一年了。创立个人事务所后打拼至今，还是手忙脚乱的状态。\n&emsp;&emsp;去年11月末，我发行了复出后的第三首曲子[「Ordinaries feat.古川亮」](https://www.bilibili.com/video/BV1X44y1a7f9)。关于歌词，以往我都以让它在乐曲的世界里完结为理想，但大概从这首曲子开始，我逐渐会去思考“如何让歌词和日常生活有所关联”。这首歌在我的作品中也是非常独特新颖的一首，请一定听听看。\n&emsp;&emsp;那么，今天既然是歌词随笔，我就聊一聊我平时作词时的方法和小技巧。\n&emsp;&emsp;作词首先要从确保词曲对应的舒适开始。\n<font color='gray'>※这里原词是**譜割り**，是在歌曲创作中把歌词细分到音符的行为，没找到中文对应的术语，还请谅解</font>\n比如，无论如何都需要4个音符(字)的歌词，却强行填入三个字。\n>⭕おにぎり(饭团，o ni gi ri)\n>❌うどおん(乌冬，原本是 u do n，此处填成：u do o n)\n\n&emsp;&emsp;你可能会吐槽什么鬼歌词，但只是举个例子。这个时候如果一定要用うどん(乌冬)这个词，就必须强行拉长元音以对应音符，但通常在作词过程中我会尽量避免这种情况出现。\n&emsp;&emsp;话虽如此，也不是说从一开始就要考虑这个问题，实际创作过程也没有那么顺利。因此，我的作词过程有一定程度的模式化，并且总是先作曲，再作词。\n1. 先作曲到能进行部分弹唱为止。\n2. 用既不是英文也不是日语的谜之语言弹唱录音。\n3. 挑选出弹唱过程中有意义的单词和句子。\n4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n5. 修改文章，使其能够对应音符。\n6. 尝试用有特色的词句插入或替换。\n7. 加入感叹号、句号等，让歌词更像文章。\n8. 再弹唱，录音，如果没有违和感就OK。\n9. 第二天重新听一遍，然后弃用。\n\n&emsp;&emsp;理想是不达到⑨完成创作，但现实没有这么简单。\n&emsp;&emsp;在上述工序中比较重要的是③。在用比较随便的词句反复哼唱旋律的过程中，总会有那么一两个词跟旋律非常搭配。我把它当成是**歌曲在呼唤的文字**，并从此衍生出整个歌词。所以我通常不会定下主题或对象开始创作。\n\n---\n\n### 1. 先作曲到能进行部分弹唱为止。\n不用说也知道，创作歌词不是写诗，如果最后不成曲调就没有意义。所以首先要确定旋律，到能唱的状态。不过最终可能会优先歌词而改变旋律。\n\n### 2. 用既不是英文也不是日语的谜之语言弹唱录音。\n&emsp;&emsp;这个阶段，我认为用什么语言其实无所谓，最优先的是作为歌词发音的舒适程度。\n&emsp;&emsp;偶尔会有人说英语歌词比较逊，但我想告诉作词者的是，这种意见全部可以无视掉。只是，如果一段歌词能统一语言的话，节奏会更舒适。\n\n### 3. 挑选出弹唱过程中有意义的单词和句子。\n&emsp;&emsp;如果没有做到这点就从1重新开始。实在找不出的话，就弃用。\n\n### 4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n&emsp;&emsp;如果在这个阶段考虑音符的对应，我就感觉会变成所谓“平庸的歌词”。这道工序应该是形成世界观的过程，但我并不是很喜欢“世界观”这个用法，所以也不会特别在意这方面的好坏。我比较关注的是曲子的气氛和文章的气氛是否一致。\n\n### 5. 修改文章，使其能够对应音符。\n&emsp;&emsp;这个过程我做的比较机械，主要是检查字数是否吻合音符，有没有强行延长元音，等等。\n\n### 6. 尝试用有特色的词句插入或替换。\n&emsp;&emsp;这是给歌词添加个性的重要环节，因此我在这个部分会花比较多的时间。比如在「Ordinaries」中，既有“溜息を燃やす”这样的表达，也会刻意加入“ブラリと歩いた”这样比较土的词句。如果让听众在读词的时候感到“哦？”，或者“哦！”就是我的胜利。\n\n### 7. 加入感叹号、句号等，让歌词更像文章。\n&emsp;&emsp;这是我个人特色的部分，也是我每次作词必做的环节。加句号是为了确认歌词是否作为文章产生美感，加感叹号是为了表现出歌曲不足以表达完整的那部分情感。\n&emsp;&emsp;可能也有人认为只用音乐表现就可以了，但在我心中，歌词有歌词，乐曲有乐曲的表现领域，而这两者不一定需要完全一致，也可以从不同的角度表达出深意。\n\n### 8. 再弹唱，录音，如果没有违和感就OK。\n&emsp;&emsp;本来在这一步还会制作**歌词卡**，但因为只是个人兴趣所以不展开谈了。只是检查一下歌词作为文章排版之后是否够帅。至于有什么好坏标准，我自己也不是很清楚。\n\n### 9. 第二天重新听一遍，然后弃用。\n&emsp;&emsp;80%的作品都是这个结局。我会努力不走到这一步。\n\n---\n\n&emsp;&emsp;古川的歌词就是通过上述的方法创作的。要点在于，不是先**决定想要表现的内容**，而是**给想要表现的事物创造轮廓**。\n&emsp;&emsp;在此之后，我会一边思考它究竟适合表现什么事物，一边进行修正，添加。\n&emsp;&emsp;这次，在11月发行的曲子「Ordinaries」表现的是“日常”。并不是像“平凡的日常也非常美丽”这样含蓄的话题，而是说**“今天是普通的，普通的一天”**，仅此而已的曲子。很难说它是美丽或者无趣，但看来至少不是糟糕的一天。我希望这首曲子能为这样的日子增添一抹光亮。\n\n## 笔记\n>段取り：计划，方法\n>手合い(てあい)：小子，家伙/对局/种类\n>お蔵(おくら)：电影戏剧等停止公映，或事物不再使用\n>省く(はぶく)：省略，减去\n","tags":["古川本铺","音乐"],"categories":["翻译"]},{"title":"【翻译】拓宽版面设计的视角","url":"/2022/01/13/trans-LayoutDesign/","content":"\n>原文链接：\n>[レイアウトデザインの視点を増やす 思考＆Tips](https://note.com/harahiroshi/n/n3af079dc17e9)\n>原作者：\n>[ハラヒロシ](https://note.com/harahiroshi/)\n\n## 译者摘要\n本文面向入门设计者，用了图例和很多比喻，生动形象地介绍了布局排版，留白处理的技巧。\n在上一篇文章中，我把“情報”照搬成情报，而后认为翻译成信息更合适，因此在这篇文章中全部采用了后者。\n\n<!--more-->\n\n## 形似水流\n&emsp;&emsp;在布局的时候，通常先决定信息的优先级，再用板块面积区分主次。光到这一步，还只是单纯地堆在一起，而没有流动感。为了让视线能平滑地浏览内容，在创造留白的时候可以想象河流的感觉。\n![picture_pc_519942b46e253091dc646bfcf05c209d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131539348.jpg)\n\n<details>\n<summary>原文</summary>\n<b>川の流れのように</b>\n<p>レイアウトするにあたっては、情報の優先順位を決めてそれをボリュームで割り当てるのが基本です。ただし、これだけだと単に積み重ねているだけで流れが悪いので、視線が滑らかに移動するように“川の流れ”を意識して余白を作っていきます。流れが明確であれば、左右入れ替えてもOKです。\n</details>\n\n## 画面要有纵深感\n&emsp;&emsp;网页虽然只是一个平面，但也和实景一样，人们通常会先识别最吸引眼球的地方，再按顺序获取信息。作为设计者，必须有意识地利用这点去调整画面的纵深。\n&emsp;&emsp;在下面的例子中，文字标题和橙色的方块是最抢眼的，然后再是绿色区域，蓝色区域。所以并不是说全都从上往下排列就ok了。\n&emsp;&emsp;刚上手的时候，思路可能容易局限于单纯地将元素上下堆积。内容之间的关联，视线的动向，下一步的响应都考虑到的同时，从纵深，左右，时间等多重角度审视设计，就可以拓宽思路。\n![picture_pc_d2eb1880b7c33ee76cd1ffeb82a2e56a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131603983.jpg)\n\n<details>\n<summary>原文</summary>\n<b>画面には「奥行き」がある</b>\n<p>webは画面という「平面」に対してだいたい同じ距離感で見るものですが、実は景色と同じで、誘目性の高いものから認識し、順を追って情報を得ていきます。つまりそこには「奥行き」があります。\n<br>作り手としてはそれを意識し、利用しながら、画面から離れたり近づいたりしながらデザインを調整していくことが大事です。\n<p>以下の例では、文字とともにその下のオレンジ色が誘目性が高く、次に緑、青と順を追って認識していきます。決して「上から順に」配置していけばいいというわけではありませんね。\n<p>最初のうちは上下にブロックを積みあげていくだけの思考に留まってしまう場合が多いです。コンテンツの関係性や視線の流れ、次へのアクションなどをしっかりおさえつつ、奥行き、左右、時間…という複数の重なりの視点を持つとそこから抜け出せると思います。\n</details>\n\n## “通风透气”\n&emsp;&emsp;留白可以诱导视线，让用户注意力转向设计者期望的内容。在布局的时候，不是将元素填入空间，而是通过制作留白让画面“通风透气”。要点在于，制造一条通道，让气流能刚好触碰到重要的信息。\n以下的例子中，如果用户的视线跟着留白走，就能自然地注意到文字内容。\n![picture_pc_0adf0b12355d3a0c60b166110560dc00](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131611974.jpg)\n&emsp;&emsp;要想验证是否做到有效的视线诱导，可以试着在自己的设计上画箭头，如果画箭头的时候感到犹豫，就可以说没有起到很好的诱导效果。\n![picture_pc_df8185ba06f7e71cc1de7c63a66954f5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131613870.jpg)\n\n<details>\n<summary>原文</summary>\n<b>空気の流れを良くする</b>\n<p>「余白」は視線誘導し、意図した情報に注目させることに利用できます。レイアウトするとき、要素をスペースに埋めようとするのではなく、余白を作って「風通しよく」してあげます。ポイントは、逃げ道をつくり、重要な情報を空気の流れに触れさせてあげること。余白がなく、息が詰まるな、と思ったら空気の流れがしっかり通っているかチェックするとよいでしょう。\n<p>以下は、余白を追っていくとコピーが自然と視界に入ってくるレイアウト例です。\n<p>なお、ちゃんと視線誘導できているかは、自分のデザインに矢印を描きこんでみるとよいです。矢印に迷いがあれば、誘導が上手くいっていないといえます。\n</details>\n\n## 从树干衍生出枝叶\n&emsp;&emsp;就拿刚才的素材，这次将关注点从留白转向构图。在布局的时候，要决定一条轴线。扎实的轴线可以增强可读性，也可以在引入变化时不让整体垮掉\n![picture_pc_9a28de0112cc45b698575e7f97b26591](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131655643.jpg)\n&emsp;&emsp;要点在于把轴线当成树干，像衍生出旁支一样布局。（轴线可以不在画面中心)在枝叶上可以自由变换。\n\n<details>\n<summary>原文</summary>\n<b>「木の幹」を意識して枝を作っていく</b>\n<p>では同じ素材で、今度は「余白」ではなく「図」に目を向けてみましょう。レイアウトするとき「軸」を決めます。軸がしっかりしていると読みやすいし、崩しを入れても破綻しにくいのです。\n<p>ポイントは「木の幹」を意識して枝を作っていくことです（軸は真ん中でなくてもよいです）。枝で変化つけると自由さが広がります。\n</details>\n\n## 重心意识\n&emsp;&emsp;进行有动向的布局时，需要有重心意识。以对角线作为辅助线就一目了然。通过调整元素的大小和位置，让重心不偏向画面的一边，就可以平衡地布局。\n![picture_pc_e7811a7a4d67d790ecc87bd05be51a17](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131702816.jpg)\n\n<details>\n<summary>原文</summary>\n<b>重心を意識する</b>\n<p>上下・左右に要素を散らすなど、動きのあるレイアウトを行うときは「重心」を意識することが重要です。その際、対角線などの補助線を描くとわかりやすいです。重心がどちらかに傾かないようにオブジェクトのサイズと位置を調整するとバランスよく配置できます。\n</details>\n\n## 布局要整齐划一\n&emsp;&emsp;**对齐**是设计的四大原则之一，但通常在设计中会要引入**变化**和**强调**，以吸引用户的注意力。但这个变化必须建立在保持协调之上，设计者应该牢记先整齐布局后再加入变化。\n![picture_pc_0a13a8c3767ee3bf1db201fc5603def5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131731290.jpg)\n\n<details>\n<summary>原文</summary>\n<b>レイアウトは整理整頓</b>\n<p>デザイン四原則には「整列」がありますが、それだけだと注意を引きつけられない場合があるので「変化」「強調」という引っかかりをつける必要があります。ただし、その変化は、あくまでも調和を守ったうえでのことです。調和の中でしか変化は成り立ちません。まずはしっかりと整理整頓したうえで、変化をつけるように心がけたいものです。\n</details>\n\n## 检验分组好坏的技巧\n&emsp;&emsp;当担心分组恰当与否时，可以采取模糊全图，看看期望的分组是否形成一个整体。\n![picture_pc_0eda9846d1b9f6bf79685cbe5c0a625d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131745255.png)\n\n<details>\n<summary>原文</summary>\n<b>グルーピングを確認するためのTips</b>\n<p>整列に関連して。グルーピングがうまくいっているか迷ったときは、全体をぼかしてみて、意図したグループが塊として見えるかどうかを試してみるとよいです。\n</details>\n\n## 从正反两面观察\n&emsp;&emsp;对于难以制造留白的场合，试着调换留白和信息所占的区域。通过这个方法，可以更清楚地捕捉留白的形状，从而判断留白究竟是杂乱的还是协调的。要点在于能否同时从正反两种视角去调整。\n\n![picture_pc_ea7c171d1905b0e31e46373735059369](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131813323.jpg)\n\n<details>\n<summary>原文</summary>\n<b>ポジとネガで見てみる</b>\n<p>余白つくるのが苦手な場合は、ポジとネガの視点切り替えを意識するとよいです。ネガ（余白）の形をしっかり捉えてみると、ネガとの対比でポジ（図）が見えていることや、余白がバラバラになっていることなどに気づけます。ポジとネガ、両方見てコントロールできるかがポイントです。\n</details>\n\n## 地平线的位置\n&emsp;&emsp;有时在叠加背景和图像时会拉一条地平线，而地平线的位置也会改变整体的印象。\n![picture_pc_d9b0d3264d28589dabe43c913a7186d4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131818593.png)\n左：图像与背景重叠部分较多，体现安定感，一体感。\n中：地平线在图像下方，使图像突出，更有动感。\n右：让背景渐变，加强纵深感。\n\n<details>\n<summary>原文</summary>\n<b>地平線をどこに引くか</b>\n<p>図と背景を重ねるときの「地平線」を引くことがあると思いますが、その地平線の位置で随分印象は変わります。安定させるか、動きを感じさせたいか、なじませたいか、など。相手の視点を決める重要なポイントです。\n<p>上のほう：図と背景の重なりが多い分、安定感、一体感があります\n<br>下のほう：逆に関わりが薄くなる分、不安定となり動きを感じます\n<br>グラデーションを引くと馴染んで、奥行きを感じさせるレイアウトになります。\n</details>\n\n## 点，线，面\n&emsp;&emsp;在需要体现出叙事性，或强弱区分的时候，可以将分散的点排布到轨迹上，构造动作或流向。\n\n![picture_pc_dccfb3714b3f0665908d90c378196831](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132002194.png)\n\n<details>\n<summary>原文</summary>\n<b>点、線、面に展開していく</b>\n<p>ストーリー性を出したい場合や強弱を意識する際に、バラバラの点を軌跡に並べて動きや流れを作り、ひとつひとつの大小つけて大きなものは面にし、変化や奥行きを出します。webの場合、手前と奥、上下、左右の流れをうまく活用したいですね。\n</details>\n\n## 俯瞰全体\n&emsp;&emsp;网页通常在纵向较长，但同一时刻只有一部分会展示在显示屏上。为了保障用户在滚动网页的过程中的观感，需要俯瞰网页整体的设计。\n&emsp;&emsp;这是我自己过去做的案例，有意识地连成一体的设计比较多。交互，交叉，重叠，突出，反复，等等，要考虑怎样让网页能够有序，有节奏地连续呈现。\n![picture_pc_75e7292ef3e7335a5a7dee406a5e1d9b](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132009352.jpg)\n\n<details>\n<summary>原文</summary>\n<b>俯瞰してみて、リズムがあるかどうかを確認する</b>\n<p>Webサイトは縦に長くても、視界に入るのは画面の面積のごく一部。しかし、スクロールしていく中で心地よく見せられるかどうか、それには俯瞰の視点も必要です。デザイン全体をみたときに美しくレイアウトされているかはチェックしたほうがいいでしょう。\n<p>自身の過去案件の事例ですが、「ひとつながり」を意識することが多いです。交互、交差、重なり、押し出し、繰り返し…など。ページ全体を見たときに、どうやってリズムよく、秩序を保ちながら連続的に見せるかを考えます。\n</details>\n\n## 结语\n&emsp;&emsp;通过效仿设计原则，就可以做出表面上优美的设计，但是如果没有属于自己的美的标准，就很难对其认定。像上文提到的一样，拓宽视角去审视设计，我认为也对启发自身美的标准有所帮助。\n&emsp;&emsp;多设计，多欣赏，在积累经验的途中就会逐渐对美的基准有手感。如果能在绘制一个单纯的矩形时感受到美，那就最好不过了。\n\n<details>\n<summary>原文</summary>\n<b>さいごに</b>\n<p>「デザインの原則」で語られる「美しさ」は真似すれば表面上は会得できるますが、やはり自分の中に「美しさ」の基準がないとなかなか定着しないと思います。その基準は、この記事でまとめたような「見方」にヒントがあるでしょう。\n<p>たくさんデザインして、いいものを見て、経験を積むことで「これが基準」の手応えを感じられるようになるはずです。ただ一つの矩形を描く手の感覚の中に「美しい」を感じられたら最高だな、と思うのです。\n</details>\n\n## 笔记\n\n>* 奥行き(おくゆき)：纵深，进深\n>* 木の幹(きのみき)：树木的茎\n>* 破綻(はたん)：失败，破裂，破产\n>* 際立つ(きわだつ)：显著，突出\n\n","tags":["设计"],"categories":["翻译"]},{"title":"【翻译】设计留白","url":"/2022/01/12/trans-WhiteSpaceDesign/","content":">原文链接：\n>https://note.com/toffy_bon/n/na73bb66846a2#OJ1BV\n>https://note.com/toffy_bon/n/n38475f161c31\n>原作者：\n>[assassin@Web屋](https://note.com/toffy_bon/)\n\n## 译者摘要\n本文面向入门设计者，简明扼要地介绍了留白的概念，作用，和部分应用场景。\n<!--more-->\n\n## 何为留白\n\n&emsp;&emsp;“留白”顾名思义就是空白的空间，英文又称WhiteSpace或NegativeSpace。乍一看可能会觉得它起不到任何作用，但留白绝不等同于多余的空间。留白是在设计中非常重要的元素，通过让其起到应有的作用，可以提高设计档次，改善用户体验。\n\n<details>\n<summary>原文</summary>\n<b>「余白」とはなにか。</b>\n<p>「余白」とは文字通り「空白のスペース」のことで、ホワイト・スペースやネガティブ・スペースとも呼ばれたりします。\n一見すると、何の役割も成さないものと捉えがちですが、「余白」＝「余分な空間」では決してありません。「余白」はデザインにおいて重要な要素であり、しっかり意味や役割を持たせてあげることで、デザインをグッと良くしてくれたり、UXの向上に一役買ってくれたりします。\n</details>\n\n## 设计师的一项重要任务\n&emsp;&emsp;“不让用户感到压力的设计” 是设计师的任务之一，而用户主要的压力因素如下：\n* 难以阅读\n* 难以理解\n* 看着会感到疲劳，烦乱\n* 难以找到想要的情报\n* 难以使用\n……etc.  \n&emsp;&emsp;除此之外，根据实际情况会有各种各样的因素，但通过适当地引入留白，可以有效缓和，甚至消解上述压力。\n\n<details>\n<summary>原文</summary>\n<b>デザイナーにとっての重要なミッション</b>\n<p>この大きなテーマの一つとして、「ユーザーにストレスを感じさせないデザインをすること」が挙げられると思います。<p>考えられるユーザーの主なストレス要因は以下の通りです。\n<br>・読みづらい\n<br>・分かりづらい\n<br>・見ていると疲れる（ざわざわする）\n<br>・目的の情報がなかなか見つからない\n<br>・使いづらい<br>…などなど。\n<p>他にもシチュエーションによって様々な要因があると思いますが、余白を上手くデザインに取り入れることで、これらのストレス要因を解消してくれたり、緩和する力を持っています。\n</details>\n\n## 留白的效果和职责\n留白的主要效果和职责大致分为五项。\n* 缓和情报间的干涉\n* 对情报进行分组\n* 层次体现\n* 诱导视线\n* 给用户留下特定的印象  \n\n<details>\n<summary>原文</summary>\n<b>「余白」の効果と役割</b>\n<p>先ず肝心なのは、余白の効果と役割について理解しておくことです。\n<p>余白の主な効果と役割は、大きく分けて5つあります。\n<br>・情報の干渉緩和\n<br>・情報の区分け（グルーピング）\n<br>・階層表現\n<br>・視線誘導\n<br>・印象操作\n</details>\n\n### 1.缓和情报间的干涉\n&emsp;&emsp;可以加强文字情报的可读性，或刻意孤立重要情报，起到强调作用。![picture_pc_8c188bf741c0f521a474f4a26635e9fc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130801361.png)\n&emsp;&emsp;图中举了两个例子。  \n&emsp;&emsp;图右通过在区块内添加适度的留白，消除了**拥挤感**，给人清爽的印象。\n![picture_pc_4d8f6abb7f3bb979c737d4cf462f167a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130808625.png)\n&emsp;&emsp;除此之外，行间距也是留白的一种，尤其在文字情报中需要注意。\n&emsp;&emsp;通常行间距是字体大小的1.5~1.6倍，但近年来也有网站采用2倍左右的宽松行距。虽然相同范围内的情报量减少了，但行距的宽松也给整体设计带来了宽裕舒适感。\n\n<details>\n<summary>原文</summary>\n<b>１．情報の干渉緩和</b>\n<p>コンテンツ内の文字情報を読みやすく（可読性向上）したり、または重要な情報をあえて孤立させて強調させたりすることが出来ます。\n<p>上に例を２つ挙げました。\n<br>どちらが「見やすい」と感じるでしょうか。\n<br>右下はブロック内に適度な余白が設けられていることで、「窮<br>屈さ」が無くなり、スッキリした印象になっていると思います。\n<p>また、「行間」も「余白」の一つです。\n<br>文字情報は特に注意が必要で、一般的な行間はフォントサイズの1.5～1.6倍程度と言われていますが、近年では、2倍程度までゆったり行間を取っているサイトも多く見かけます。同範囲内の情報量は減ってしまいますが、行間にゆとりを持たせると、デザインにも「ゆとり」が生まれるのです。\n</details>\n\n### 对情报进行分组\n&emsp;&emsp;通过适度的间隔，可以明确情报间的从属关系。\n![picture_pc_065874a10a1b4d75dc032103685d99e2](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130823526.png)\n&emsp;&emsp;乍一看左右两图都有整齐的感觉，但实际在读取情报的时候，图左的标题和文章内容的位置区分显得有些模糊。相比之下，图右中标题与文章内容就一目了然。\n\n<details>\n<summary>原文</summary>\n<b>２．情報の区分け（グルーピング）</b>\n<p>間隔を適度に取ることで、情報がどこに属するのか明確にしてくれます。\n<p>上の例を見比べてみてください。\n<p>一見すると、どちらも整っているように感じるかも知れませんが、情報を読み取ろうとしたとき、左上はタイトルと文章の位置付けが曖昧だと感じないでしょうか。対して右下は、どれがタイトルでどれがタイトルに属する文章なのかが、すぐに把握できるのではないかと思います。\n</details>\n\n### 层次体现\n&emsp;&emsp;当情报之间有嵌套关系，通过使用缩进可以清楚地表现层次。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130831718.png'></span>\n&emsp;&emsp;需要注意的是，使用缩进的时候不能半半拉拉。至少要缩进一个字距左右，让人一眼就能看出的程度，否则用户在阅读的时候反而会产生没有对齐的不适感。\n\n<details>\n<summary>原文</summary>\n<b>３．階層表現</b>\n<p>情報が入れ子になっているものは、インデントを使うことで階層を分かりやすく表現してくれます。\n<p>良く見かける例がこれですね。\n<p>この階層表現を使うことで、情報整理にもなります。\n<br>ただ、インデントで余白を取る時は、中途半端は禁物です。最低一文字分くらい、パッと見で分かる程度の余白を持たせておかないと、ユーザーが見たとき、逆に「ズレている？」と見られ兼ねませんので、ご注意を。\n</details>\n\n### 诱导视线\n&emsp;&emsp;通过在纵向采取更多的留白，可以起到诱导视线的作用。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130840369.png'></span>\n&emsp;&emsp;大多数人在看到上图时，视线应该是从左向右，Z型移动。\n&emsp;&emsp;如果图片间的留白没有规律，用户的视线就会犹疑。在某些随机展览的网站中可能不限于此，但如果希望用户按照顺序阅读，这个手法就显得尤为重要。\n\n<details>\n<summary>原文</summary>\n<b>４．視線誘導</b>\n<p>「前へ」「次へ」「下へ」「上へ」や、横より縦の余白を多く取ることも視線誘導の一つです。\n<p>上のような画面を見たとき、視線はどのように動くでしょうか。\n<br>恐らく多くは左から右へ、Z型に移動していくものと思います。\nこの余白の取り方がバラバラだと、視線は迷い、自由に画面を見ようとします。ランダムなギャラリーサイトのような例においてはこの限りではありませんが、一般的にはユーザーに順序正しく見せたいのであれば、この手法は鉄則と言えると思います。\n</details>\n\n### 给用户留下特定的印象\n&emsp;&emsp;使用留白，可以制造高级感，宁静感，实惠感，繁华感等印象。\n![picture_pc_4a8c8e615e7acd8dc1aa5d57d4a0b4f8](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130853272.png)\n&emsp;&emsp;为画像准备的空间也是留白的一种。\n&emsp;&emsp;使用较多留白，可以体现高级感，宁静感，清爽感。而采取较少的留白可以体现紧迫感或实惠感。\n因此，有关酒店或奢华商品，会多采取留白，而促销广告，或网络商场等需要成列大量商品时，会使用较窄的留白。\n\n<details>\n<summary>原文</summary>\n<b>５．印象操作</b>\n<p>余白を上手に扱うことで、「高級感」「静けさ」「お得感」「賑やかさ」などの印象を持たせてくれます。\n<p>上に挙げたサイトは一例です。\n<br>ちなみに、画像に設ける空間も「余白」です。\n<br>余白を多く取っているものは、「高級感」や「清潔感」「静けさ」などが演出できます。逆に取らずにレイアウトすると「緊迫感」や「お得感」「賑やかさ」などが演出できます。\nなので、ホテルやラグジュアリーな商材を取り扱う場合は余白を多く取り、特売の広告媒体やインターネットモールなど多くの商品を取り扱う場合は、余白を狭くレイアウトすることで有効な訴求ができるかも知れません。\n</details>\n\n## 应用留白\n&emsp;&emsp;在设计之前，**充分理解内容**显得尤为重要。面向的用户群体，产品的种类，情报说明的对象等等，都应把握到位。  \n\n<details>\n<summary>原文</summary>\n<b>余白を上手に扱うコツ</b>\n<p>まずはじめにデザインを行う前提として、「コンテンツを十分に理解すること」がとても重要になります。どんなユーザーに向けた、どんなクリエイティブ（制作物）なのか、この情報はどれに対する説明なのか…など、内容をしっかり把握しておきましょう。\n<p>「土台」が理解できていなければ、良いものは生まれません。\n</details>\n\n### 1.了解适合的留白量\n\n&emsp;&emsp;如同前面提到的一样，留白有着制造印象的作用。虽然具体情况要具体分析，但基本可以按照以下思路进行\n![picture_pc_eaaab23be1d54ebaf1a80a1112b8b275](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130926768.png)\n<font color='gray'>从左到右分别是：电商·情报网站；博客，画廊；企业网站；品牌网站</font>\n\n&emsp;&emsp;需要注意的是情报量。情报量和留白量基本呈反比例，例如电子商务平台（淘宝，京东等）需要一次性展示大量商品，如果采取大量留白，会导致商品界面的页数大涨，用户也难以找到心怡的产品，影响销售额。\n&emsp;&emsp;而品牌网站需要将少量商品的魅力完整地展现出来，如果采用较少留白，虽然能一次性展示更多的情报，但难以给用户留下深刻的印象。\n\n<details>\n<summary>原文</summary>\n<b>ポイント１：適切な余白量の目安を知る</b>\n<p>余白にクリエイティブの印象を左右する効果があるのは、前半でもお話した通りです。そのものの背景によって断言できない部分もありますが、基本的には以下のような考え方で分類できます。\n<p>チェックすべきポイントは「情報量」です。\n<br>情報量と余白の割合は反比例しており、情報が多いほど余白は小さく、情報が少ないほど余白を大きく取るのが効果的と言われています。\n<p>たとえばウェブサイトを例に挙げるとすると、膨大な商品数を扱うECサイトと、高級ブランドの公式サイトを見比べるとどうでしょうか？\n<p>全く余白の取り方が違っていると思います。\n<p>想像してみてください。\n<p>もし、これが真逆の状態になったら、どのようになるでしょう。\n<p>ECサイトの場合は、余白が大きくなることで一度に閲覧できる商品数が減ってしまい、そのぶんサイト全体のページ数も更に膨れ上がり、ユーザーが目的の商品を見付けにくくなったりと、売上げにも影響を及ぼしかねません。\n<p>ブランディングサイトなどの場合は、余白が小さくなることで一度に閲覧できる情報量は増えますが、本来伝えたいイメージがユーザー側に伝わりにくくなったり、商品の魅力が損なわれることすらあるのです。\n</details>\n\n### 2.对各部分的留白设定规则\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130945808.png)\n&emsp;&emsp;上图中，将相同规则的留白用相同颜色做了标记。  \n&emsp;&emsp;像这样，对同属性的元素制定统一的规则，不光美观，还能让用户产生安心感。\n![picture_pc_d6184179795c17511a43c77501254abb](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951631.png)\n&emsp;&emsp;反过来，就算只相差几个像素，或者只有一处的留白不同，也会很明显地让用户感到混乱，违和。\n![picture_pc_4742ef42919cc939f6c8d1cb5b91f437](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951323.png)\n&emsp;&emsp;通过调整其中的规则，也可以像前面提到的一样发挥视线诱导的效果，使内容之间产生阅读顺序。\n\n<details>\n<summary>原文</summary>\n<b>ポイント２：セグメント内の余白にルールを設ける</b>\n<p>上の図は、同じルールで配置された余白を色分けしたものです。（テキストが英文のため、左右の余白が違って見えてしまっていますが…；）\n<p>分かりやすく少し大袈裟な例を挙げてみましたが、たとえこれが数pxの違いだったり、1箇所だけ余白の取り方が違っているだけでも、ユーザーを混乱させてしまったり、意外に違和感を覚えるものです。見た目にもまとまりがないだけでなく、見ている側のストレス要因にもなります。\n<br>このルールを調整すると、前半でもお話した通り、視線誘導の効果が発揮され、コンテンツの見方に順序が生まれるわけです。\n<p>数px単位でも印象は微妙に変わって来ますので、デザインを俯瞰で眺めてみると気付くことが多いと思います。\n</details>\n\n### 3.片段中的留白要有层次\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131001801.png)\n\n&emsp;&emsp;通过使内侧的留白比外侧的留白小，整体布局会显得更加清楚。就像俄罗斯套娃一样，把一个内容块想象成一个盒子。如果里盒的留白和外盒一样，或更多，就会丧失平衡感。\n\n<details>\n<summary>原文</summary>\n<b>ポイント３：セグメント内の余白は入れ子にする</b>\n<p>基本的に、内側は外側の余白より小さくすることで、全体的にまとまりが出てスッキリしたレイアウトになります。マトリョーシカのような要領で、各コンテンツブロックを１つの箱として考えてみましょう。\n<br>内ブロックの余白が外ブロックと同じ、または外ブロックより大きかったりすると、アンバランスで、見ている側は何だか落ち着かない（ざわざわした）気持ちになるものです。\n</details>\n\n### 思考内容和留白之间的关系\n![picture_pc_cd1383153dd33cf247bbcd55fbd04da4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131007174.png)\n\n&emsp;&emsp;左右两边的内容完全相同，但第一眼看过去，通常图左会把“Sweets”看作图片的标题，而图右会把它看作文章的标题。\n&emsp;&emsp;元素之间距离越近，越能体现从属关系。因此如果希望“Sweets”和图片分为一组，就让它们之间的间距减小，而与下方文章的间距增大就行，反之亦然。在上图中，无论采取哪种都可，但根据具体内容，有些情况下其中一种会是更优解。\n\n![picture_pc_534608440f345b0583c71615176e28dc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131021666.png)\n<font color='gray'>标题是“多彩的甜点”</font>\n\n在改变标题内容后，图左的布局就更合适了。因为图像和“多彩的甜点”搭配更自然，而与文章内容的关联不大。\n\n<details>\n<summary>原文</summary>\n<b>ポイント4：内容と余白の関係を意識する</b>\n<p>上の２つをパッと見たとき、どのように読み取ったでしょうか。\nどちらも内容は同じですが、左は「Sweets」が画像のタイトル、右は<br>文章のタイトルに見えたのではないかと思います。\n<p>これは前半でお話した「情報の区分け（グルーピング）」効果に属しますが、違いは余白の取り方にあります。距離が近い方に属しているように見えるので、画像とセットで見せたければ、画像間の余白を小さくし文章との余白を大きく、文章とセットで見せたければ、逆にするだけで良いのです。\n<br>なので、内容によって「余白のあり方」は変わってきます。\n<p>さて、テキスト情報を変更してみました。\n<br>どちらの余白の取り方が適切だと思いますか？\n<br>答えは左です。この場合「カラフルなスイーツ」の文言は、画像に所属させる方が自然です。文章寄りにしてしまうと、本文内容と噛み合わずチグハグな印象を与えてしまいます。\n</details>\n\n## 总结\n&emsp;&emsp;设计的基础遵循[格式塔组织原则](https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%A1%94%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99/10544754)。\n\n&emsp;&emsp;设计没有正确答案，正因为如此，设计师自身在制作中要有明确的意向。当被问到“为什么这么设计”时，如果能明确地说出理由，就能提高产品设计的说服力。留白的应用很难一概而论，但如果你之前没有过多留意，不妨根据上面的介绍实践一下。\n\n<details>\n<summary>原文</summary>\n<b>まとめ</b>\n<p>いかがでしたか。\n<br>デザインのイロハはゲシュタルトの法則に基づいています。\n<p>デザインに正解はありません。だからこそ、デザイナー自身がしっかりとした意向を持って制作に取り組むことが重要です。「なぜこうしたの？」と聞かれたら、明確に理由を説明できるとクリエイティブの説得力も増します。余白の取り方はデザインによって変わりますので一概には言えませんが、「今まで特に意識したことなかった」という方は、前半と後半でご紹介したポイントを念頭において、ぜひ実践してみてください。\n</details>\n\n## 笔记\n>* 一役買う(ひとやく かう)：主动承担任务，主动帮助\n>* 挙げる(あげる)：逮捕/举行/**举例**/扬名/尽力\n>* ゆとり：宽裕，余地\n>* 入れ子(いれこ)：套盒，套匣\n>* 賑やか(にぎやか)：热闹，繁华\n>* 設ける(もうける)：准备，设立\n>* ラグジュアリー(luxury)：奢华的，豪华的\n>* 商材(しょうざい)：商品\n>* ECサイト(electronic commerce)：电子商务平台\n>* コーポレートサイト(corporate website)：企业网站\n>* ブランディングサイト(branding website)：品牌网站\n>* セグメント(segment)：切片，部分，程序段\n>* ちぐはぐ：不配对，不协调，龃龉\n>* 基づく(もとづく)：根据，按照\n\n","tags":["设计"],"categories":["翻译"]},{"title":"网站图标","url":"/2022/01/12/my-AvatarIcon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121316093.png\" width=40%>\n</span>\n<!--more-->\n\n\n初版是在小学4年级左右的时候设计的，长这个样子👇\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121141859.jpg\" width=60%>\n</span>\n还取了个名字叫**魔鬼的讴歌**🙈（中二爆棚）\n\n之前正愁博客logo用什么好的时候突然想起来，就直接用了，所以其实没什么内涵💦\n\n","tags":["设计"],"categories":["个人作品","平面设计"]},{"title":"欢迎光临🎉","url":"/2022/01/11/my-first-blog/","content":"\n## 📃Intro\n2021级大学本科生，计算机专业。此前在QQ空间写一些感想，但是感觉发挥受限，也不好排版和整理。于是趁大一时间充裕，建了一个博客用来记录我的学习成果和思考。目前专业水平不足，写不出有价值的技术性文章，因此会以翻译日语的文章为主，一方面备考N1（~~前提是抢得到考位~~），一方面也能学习和分享知识。\n<!--more-->\n\n## 🎮兴趣\n* 音乐：J-POP听的比较多，最近沉迷Vaundy的[napori](https://music.163.com/#/song?id=1450922612)。\n\n    [#古川本铺]()  [#真夜中]()  [#夜鹿]()  [#匹老板]()  [#Vaundy]()  [#優里]()\n* 番剧：虽然是老二次元，但看番比较挑，很多经典都没看过。心中的神作是三月的狮子。（但是不出续集💔\n\n    [#三月的狮子]()  [#Sonny Boy]()  [#扳机社]()  [#冰菓]()  [#春物]()\n* 游戏：进入大学后开始少玩商业，多玩独立。明日方舟会时不时回来过个年。\n\n    [#Hades]()  [#Jonathan Blow]()  [#传说之下]() [#麦哲伦(明日方舟)]()  [#YGOmobile]()\n\n* 电影：了解的不是很多，兴致来了就看。\n\n    [#韦斯·安德森]()  [#汤浅政明]() \n\n*\t书：卡尔维诺，神。\n* [#卡尔维诺]()  [#毛姆]()  [#塞林格]() \n\n最近开始有目的地去欣赏作品，提高审美，欢迎朋友们推荐🙏。\n\n## 💡个人能力\n终极目标是做独立游戏，所以各方面都在努力中，大学期间主要以提高编程能力为主。\n大一上学期给班级做了班徽，班服设计，然后个人参加了学院的明信片设计大赛拿了三等奖。\n还做了微电影的导演和后期，但那个实在是太花时间，大学期间不打算再做了。\n日语是第二母语，有语感的那种，就是词汇量还有待提高。\n\n## 📫联系方式\n* QQ：499061152\n* Bilibili：[@神秘的哇哇](https://space.bilibili.com/1394852578)\n\n"},{"title":"年末总结——2021","url":"/2021/12/31/conclusion-2021/","content":"2021，无论是对我，还是对我的同学们来说想必都是意义重大的一年。\n<!--more-->\n大学里也有乱七八糟的事务和浪费时间的水课，但至少我们有了选择的权利。可以选择放下冗杂的一切去钻研自己所热爱的，也可以发挥江苏学生的应试能力，杀出一条保研道路。\n\n## 来到大学觉得比较香的地方\n\n首先是食堂，总体价钱和初高中差不多，更不必说还有烤腿饭这种神的存在。（不过感觉没高中那么耐吃😭怀念芝士焗饭）\n然后是图书馆。从宿舍走路5分钟就能到。虽然装修得像个仓库一样，但藏书还是相当齐全。座位和研修室的预约管理系统也很完善，很抢手，不过井井有条。👍\n还有本学期加了两个技术社团，培训了一学期，学到了一些课外的知识，也认识了很多优秀学长。\n\n## 今年的收获\n\n看网课把C++，java，Js，html和css入了个门，本来想两个月学会web前端但发现想多了，现在处于知识非常零散的状态😫（其实就是屁都不会)希望利用寒假能把它融会贯通。\n参加了学院的明信片设计，班徽班服设计，宿舍风采，微电影制作，还有摇篮杯这几个比赛，有的拿了不错的名次，有的不是我一人能决定结果，有的主办方拉垮，但总的来说还行，也得到了同学们的肯定。👌\n因为一些原因开始时隔多年写“空间非主流文案”🐷虽然有些羞耻，实际写起来发现是个整理思绪的好方法。\n今年想通了很多事情，但随着思考深入，也更加意识到自己的不足。我不追星，但也不禁会仰望那些在舞台发光的人，也免不了为自己太过遥远的理想焦虑。💦\n>做不了天才，那就大器晚成。\n\n2022，请多指教。(^^ゞ\n","tags":["大学生活"],"categories":["总结","年末总结"]},{"title":"【The Witness】","url":"/2021/12/12/game-The-Witness/","content":"\n起初，它们只是有着固定规则的符号，只是一个个死的谜题。\n<!--more-->\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120987.jpeg)\n\n有些谜题很难，能卡我好几天。有些谜题需要先去其他区域，掌握新的规则再做。\n有些谜题，我用上了手机摄像头的彩色滤镜，或是录视频后逐帧播放，才能破解。\n还有圆柱上的，树荫下的，映在水里的谜题，我一笔一画将它铺开来，呈现在纸上才能破解。\n花了16小时，破解400多道谜题后，我以为的终点却只是把我带回起点。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120536.jpeg)\n\n然后我才发现，这不是充满谜题的世界，而是谜题组成的世界。\n是生起第一把火，点亮第一盏灯的人，他们眼里的世界。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120069.jpeg)\n","tags":["Jonathan Blow","游戏","感想"],"categories":["游戏鉴赏","解谜"]},{"title":"班徽设计","url":"/2021/10/26/my-class-icon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121648261.jpg\" width=60%>\n</span>\n<!--more-->\n据同学说黑底背景更有感觉\n但现在看右下角那缺了一块好不爽ヾ(≧へ≦)〃\n\n## 弃用方案：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121651470.png\" width=60%>\n</span>\n只有一个8实在是太单调了（说不定可以用在球服？）\n\n\n\n## 中途版本：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121709946.png\" width=60%>\n</span>\n一开始那个“计”放在头顶上像是要寄了x，后来做成表盘就不那么容易联想🐕\n\n","tags":["大学生活","设计"],"categories":["个人作品","平面设计"]}]