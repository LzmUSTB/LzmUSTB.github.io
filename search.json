[{"title":"Javascript与前端算法","url":"/2023/09/08/my-javascript-note/","content":"\n# Javascript\n\n## ES6\n\n### Map\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n\n也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“**值—值**”的对应，是一种更完善的 Hash 结构实现。\n\n* 实例化\n\n```javascript\n//空map\nconst map = new Map();\n//初始化map，通过数组表示键值对\nconst map = new Map([\n   ['name','Jack'],\n   ['age',16]\n]);\n```\n\n* 方法\n\n```javascript\nmap.size //2\nmap.has('name'); //true\nmap.get('name'); //'Jack'\nmap.set('key','value'); //返回对象本身，可链式调用\nmap.delete(key); //删除成功返回true\nmap.clear(); //清除所有成员，无返回值\n\n<!--遍历:-->\nmap.keys(); //返回键名的遍历器\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nmap.values(); //返回键值的遍历器\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nmap.entries(); //返回所有成员的遍历器\nfor (let [key,value] of map.entries()) {\n  console.log(key, value);\n}\n\n//forEach\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n\n<!--与数组结合:-->\n[...map.keys()];\n[...map.values()];\n[...map];\n[...map.entries()];\n\n//使用数组filter创建新map\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n```\n\n※注意点\n\n```javascript\n//只有对同一个对象的引用，Map结构才将其视为同一个键\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n//同样的值的两个实例，在 Map 结构中被视为两个键\nconst k1 = ['a'];\nconst k2 = ['a'];\nmap.set(k1,1);//两者不同\nmap.set(k2,2);//两者不同\n\n//undefined和null是两个键\n//NaN为同一个键\n//0，-0为同一个键\n```\n\n### Class\n\n```javascript\n//1.基本类语法\nclass Person {\n  constructor( name , age ) {\n    this.name = name;\n    this.age = age;\n  }\n    \n  say() {\n    return '我叫'+this.name+',今年'+this.age+'岁';\n  }\n    \n  static walk(){\n      console.log('我会走路');\n  }\n}\n\nvar p = new Person('小明',18);\np.say(); //成员方法\nPerson.walk(); //静态方法\n\n//2.原型继承\nclass Child extends Parent{\n\tconstructor(name,age,gender){\n        //通过super可以调用父类构造器或方法\n        super(name,age);\n        this.gender=gender;\n        //super作为对象时，指向父类的原型对象\n        console.log(super.func());\n    }\n    //ES6中规定，子类的构造函数必须执行一次super函数。\n}\n\n//3.getter,setter\nclass Person {\n  constructor() {}\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n//使用get和set关键字可设置存值函数和取值函数\n//拦截该属性的存取行为\nlet p = new Person();\np.prop = 666; //setter: 666\n```\n\n虽然引入了关键字，但ES6中并没有真的引入类这个概念，通过class定义的仍然是函数。class仅仅是通过更简单直观的语法去实现原型链继承。这种对语言功能没有影响、但是给程序员带来方便的新语法，被称为**语法糖**。\n\n在 constructor 里面，super 的用法是 super()。它相当于一个函数，调用它等于调用父类的 constructor 。\n\n但在普通方法里面，super 的用法是 super.prop 或者 super.method()，它相当于一个指向对象的 [[Prototype]] 的属性。\n\n## 前端算法\n\n### 链表\n\n#### 双指针\n\n判断链表有无成环\n\n```javascript\nlet slow = head;\nlet fast = head;\nwhile(fast && fast.next){\n\tfast = fast.next.next;\n\tslow = slow.next;\n    //快慢指针相遇说明链表成环\n\tif(slow===fast) return true;\n}\n```\n\n#### LRUcache\n\nleast recently use cache\n\nVue的`<keep-alive>`组件使用了**LRUcache（最少最近使用缓存）**。\n\n```javascript\nclass LRUCache {\n    constructor(capacity){\n\t\tthis.cache = new Map();\n    \tthis.maxSize = capacity; \n    }\n    \n    get(key){\n        //若key对应的value存在，在返回之前将其排在队尾\n        if(this.cache.has(key)){\n            let tmp = this.cache.get(key);\n            this.cache.delete(key);\n            this.cache.set(key,tmp);\n            return tmp;\n        }\n        return -1;\n    }\n    \n    put(key,value){\n        if(this.cache.has(key)){\n            this.cache.delete(key);\n        }else if(this.cache.size>=this.maxSize){\n            //如果新增元素将超过缓存容量，淘汰队首元素\n            this.cache.delete(this.cache.keys().next().value);\n        }\n        this.cache.set(key,value);\n    }\n}\n```\n\n### 位运算\n\n#### 组合权限认证\n\n* 标记：通过二进制位标记某个属性\n* 授权：**或运算**授予一个变量多个属性\n* 校验：**与运算**判断有无该属性\n* 删除：**异或运算**删除一个属性\n\nvue中判断虚拟DOM类型\n\n```javascript\nexport const enum ShapeFlags{\n\tELEMENT = 1,\n    FUNCTIONAL_COMPONENT = 1 << 1,\n    STATEFUL_COMPONENT = 1 << 2,\n    ...\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n}\n```\n\n判断一个数是否为2的整数次幂\n\n```javascript\nn>0 \n&&\nn & (n-1) === 0 \n```\n\n异或去重\n\n```javascript\na^a^b^b^c //c\n```\n\n### 树结构\n\n递归翻转\n\n```javascript\ninvertTree=(root)=>{\n\tif(root==null){\n\t\treturn root;\n\t}\n\t[root.left,root.right]=[invertTree(root.right),invertTree(root.left)];\n    return root;\n}\n```\n\n### 栈\n\n判断html标签是否闭合，简化路径\n\n```javascript\nlet stack=[];\nlet paths=path.split('/');\nfor (let i=0;i<paths.length;i++){\n    const p = paths[i];\n    if(p=='..'){\n        spack.pop();\n    }else if(p && p!=='.'){\n     \tstack.push(p);\n}\nreturn '/'+stack.join('/');\n```\n\n","tags":["编程"],"categories":["程序设计","前端"]},{"title":"基本乐理与声音设计","url":"/2023/07/19/my-music-note/","content":"音乐学习相关的笔记\n<!--more-->\n# 基本乐理\n\n### 泛音(倍音，倍频)\n![image-20230901164632960](../images/image-20230901164632960.png)\n\n整数次谐波=>基音，倍音\n![image-20230901164700405](../images/image-20230901164700405.png)\n\n和弦和单音在物理学意义上没有区别\n![image-20230901164715003](../images/image-20230901164715003.png)\n\n## 音乐基础\n\n### 三要素\n* 节奏\n* 旋律\n* 和声\n\n### 音程-interval\n\n| **度数名**        | **英語** | **例（ドの場合※）** | **半音数** | **テンションとして見た場合** |\n| ----------------- | -------- | ------------------- | ---------- | ---------------------------- |\n| **完全1度**       | P1/d2    | ド（同じ音）        | 0          |                              |\n| 増1度/短2度       | m2/A1    | ド♯/レ♭             | 1          | ♭9th                         |\n| 長2度/減3度       | M2/d3    | レ/ミ♭♭             | 2          | 9th                          |\n| 増2度/短3度       | m3/A2    | レ#/ミ♭             | 3          | ♯9th                         |\n| 長3度/減4度       | M3/d4    | ミ/ファ♭            | 4          |                              |\n| **完全4度**/増3度 | P4/A3    | ファ/ミ♯            | 5          | 11th                         |\n| 増4度/減5度       | A5/d5    | ファ♯/ソ♭           | 6          | ♯11th                        |\n| **完全5度**       | P5       | ソ                  | 7          |                              |\n| 増5度/短6度       | A5/m6    | ソ♯/ラ♭             | 8          | ♭13th                        |\n| 長6度/減7度       | M6/d7    | ラ/シ♭♭             | 9          | 13th                         |\n| 短7度             | m7       | ラ♯/シ♭             | 10         |                              |\n| 長7度             | M7       | シ                  | 11         |                              |\n| **完全8度**       | P8       | ド（オクターブ上）  | 12         |                              |\n\n- **P**…パーフェクト（完全）\n- **M**…メジャー（長）\n- **m**…マイナー（短）\n- **A**…オーグメンテッド（増）\n- **d**…ディミニッシュト（減）\n\n异名同音(×为##)：\n![image-20230901164732238](../images/image-20230901164732238.png)\n\n### 大小调\n\n与大调有关的三个小调：（只按自然小调标升降号）\n\n* 自然小调：组成音完全相同（C大调/A小调）\n* 和声小调：自然小调升第七个音\n* 旋律小调：下行自然小调，上行自然小调升六七音\n\n12大调，48大小调\n\n### 冠音\n\n最高音，大部分情况下是旋律音\n\n![image-20230829115933572](../images/image-20230829115933572.png)\n\n![image-20230901164746538](../images/image-20230901164746538.png)\n\n### 五度圈\n\n![PNG](../images/co5th.png)\n\n查看基调和弦：以A大调为例，由框内的六个音组成\n    ![1694867599892](../images/1694867599892.png)\n\n## 和声\n\n五音经常可以被省略，通常不影响和弦判断\n\n三音和七音不能省\n\n### 钢琴指法\n* m：三音左移半音\n* ♯：全部右移半音\n* ♭：全部左移半音\n* dim：三音，五音左移半音\n* sus4：三音右移半音（挂4和弦）\n* aug：五音右移半音\n* -5/b5：五音左移半音（flat five）\n* 6：七音在五音的右侧两个半音位置\n* 7：七音在五音的右侧3个半音位置\n* 9：短七音+九音\n* M7（Δ7）：七音在五音的右侧4个半音位置\n* add9：七音在根音的右侧两个半音位\n\n### cadence/终止\n\n* Authentic/正格终止（Ⅴ→Ⅰ）\n  * perfect authentic（根音=和弦最低音&和弦最高声部为Tonic）\n  * imperfect authentic\n* half/半终止（→Ⅴ）\n* plagal/变格终止（Ⅳ→Ⅰ）\n* deceptive/伪终止（Ⅴ→Ⅵm）\n\n### 和声机能\n\n![1694871651941](../images/1694871651941.png)\n\n![1694872296729](../images/1694872296729.png)\n\nⅢm在有些时候会有**T**的作用\n\n![image-20230917084451373](../images/image-20230917084451373.png)\n\n### 和声韵律(Harmonic rhythm)\n\n\n\n### 常见和声\n\n\n* 丸之内/just the two of us\n\n$$\nⅣM7-Ⅲ7-Ⅵm7-Ⅰ7\n$$\n\n## 人声的范围\n\n![image-20230903194409225](../images/image-20230903194409225.png)\n\n## 转调\n\n![image-20230903194746090](../images/image-20230903194746090.png)\n\n## 旋律\n\n### 五音音阶 Pentatonic\n\n\n### 注意点 \n  ![image-20230903200858730](../images/image-20230903200858730.png)\n\n### 和弦外音\n\n* 经过音：两个和弦音之间的音\n* 相邻音：两个相同的音之间差一个以上相邻的音\n* 先现音：提前出现下一个和弦的音\n* 跳脱音\n* 倚音\n* 悬挂音suspension/retardation\n\n### 付点/切分\n\n## 节奏\n\n### 鼓的构成\n\n* Kick\n* Hi-Hat：通常是将节奏分的最细的部分，根据Hi-hat的节奏，将节奏类型分为8beat，16beat等\n* Snare\n\nghost note\n\n\n\n# 设计声音\n\n## 物理学系统\n\n* 自由度：物体能够运动的方向的数量（三个平移自由度，三个转动自由度）在声音模型中通常假设仅有一个自由度\n\n* 激励者：把能量带给系统的物体\n\n* 受激：产生振动的物体\n\n  在声音的产生过程中，激励者和受激缺一不可\n\n\n### 材料\n\n* 质量\n* 弹性/塑性\n* 硬度\n* 密度\n* 结构与强度\n\n材料对声音的影响主要体现在质量和弹性两个方面。不同状态(固液气)的物体对声音的传导能力不同\n\n体积模量K（E：杨氏模量；v：泊松比）：\n$$\nK=\\frac{E}{3(1-2v)}\n$$\n\n### 波\n\n* 横波/纵波/扭转波\n\n* 速度（质点速度，相速度，群速度）\n\n* 幅度\n\n**声速**（相速度phase velocity）c近似公式（K：杨氏模量；ρ：密度）：\n$$\nc=\\sqrt{\\frac{K}{ρ}}\n$$\n\n$$\nc=fλ\n$$\n\n**群速度**：取决于介质属性的常量，通常与相速度相等。当相速度和群速度不完全相等时，该介质弥散（dispersive），如水波冲刷海岸的现象。\n\n### 界面\n\n当界面的两种物质相差极大时，声音中有很大一部分会被反射，很小一部分会传导。对于水和空气，这个比率约为99%。\n\n入射角会影响反射波的强度，在布鲁斯特角，反射波会消失。\n\n**固体界面处的弯曲波相位**：对于坚硬界面的材料，波会反相反射；对于弹性界面的材料，波会同相反射。\n\n反射波与入射波具有相同的波长和波速，但幅度较小。\n\n被传导的波在新的介质中有新的波长，频率不变。\n\n**驻波**：持续不断的行波与反射波叠加干涉，形成驻波（在吉他中，第一个是基音，后面的是泛音）\n\n![image-20230901105905563](../images/image-20230901105905563.png)\n\n\n\n### 模拟（analogue）\n\n借由其他类似系统进行推理，达到连续测量的目的。在声音设计中主要考虑“电，力，声”三种系统。\n\n* 流动：\n\n  * 电学：电流\n  * 力学：速度\n  * 声学：体积流动\n\n    ![image-20230901115743564](../images/image-20230901115743564.png)\n\n* 质量：\n\n  * 电学：电感\n\n  * 力学：质量\n\n  * 声学：声质量 *inertance*\n    > （流动介质的质量除以波阵面的横截面积）\n\n* 阻抗：\n\n  * 电学：电阻\n\n  * 力学：摩擦\n\n  * 声学：粘滞力，介质的耗散属性\n\n    > （波阵面上的声波压强除以体积速度）\n\n    ![image-20230901115909642](../images/image-20230901115909642.png)\n\n* 容抗\n\n    * 电学：电容\n    * 力学：柔度，硬度的倒数\n    * 声学：声容，与所施压强的变化相抗的量\n    ![image-20230901115803986](../images/image-20230901115803986.png)\n\n**将被敲打的弦的类比系统**：\n\n![image-20230901120723041](../images/image-20230901120723041.png)\n\n**对钟和小提琴的entity-action解构**：\n\n![image-20230901120828572](../images/image-20230901120828572.png)\n\n### 振动\n\n周期波听起来像有固定的音高，而非周期波听起来很复杂或类似噪声。\n\n* 弛豫振荡relaxation oscillator\n\n* 简谐振荡\n\n弦的固有频率：(L:长度；T:张力；mu:单位长度质量)\n$$\nf=\\frac{1}{2L}\\sqrt{\\frac{T}{m_u}}\n$$\n简单几何形状的物体大致可以分为两类：能够自由振动的物体，和在张力下的物体。琴弦，鼓皮会以与它们所受张力有关的频率振动。\n\n#### 受激振荡与谐振\n\n共振系统在不同阻尼下的响应：\n\n![image-20230901145420644](../images/image-20230901145420644.png)\n\n将驱动振荡器看作是对能量流动的阻抗，随着驱动频率远离固有频率，能量的转移越来越小。\n\n受激系统的行为就像是**滤波器(filter)**。当系统阻尼较小时，系统具有**高谐振，窄带宽**的特性，而受到强烈阻尼的系统具有**低谐振，宽带宽**的特性。\n\n\n\n## 声学系统\n\n在声学中我们仅考虑**纵波**，总体积的行为。\n\n空气中的声速方程：\n$$\nc=\\sqrt{\\frac{γp}{ρ}}=\\sqrt{\\frac{γRT}{M}}\n$$\nR：摩尔气体常数，T：绝对温度，M：摩尔质量\n\n### 声压级&声强级\n\n声压p是单位面积上的一个力，波的峰值声压反比于距离，所以若与声源相距为r，则峰值按1/r减少。\n\n声压级（Sound pressure level）是一个以分贝为单位的比率，设20μN/m^2^作为声学上最小可测量值，则：\n$$\nSPL=20log_{10}\\frac{p(N/m^2)}{2*10^{-5}}\n$$\n※声波的声压级不会超过194dB，这个值意味着疏部压强为真空压强。（在爆炸和闪电中存在压强大于194dB的单极性脉冲）\n\n------\n\n声音强度I是单位面积上的功率，用W(瓦特)/m^2表示，它正比于声压级的平方。\n\n对于谐波平面波：（ρ：密度，c：相速度）\n$$\nI=±\\frac{p^2}{2ρc}\n$$\n声强级(sound intensity level)是以分贝为单位的比率，以10^-12^W/m^2^作为参考值：\n$$\nSIL=10log_{10}{\\frac{I}{10^{-12}}}\n$$\n\n### 位置与相干性\n\n当观察者听到来自不同声源（或是反射波）的**相关**声音时，声音可能被加强或减小。当声源移动，则声音不断地加强或对消，观察者会听到一个扫频的陷波滤波效果。\n\n![image-20230901153530820](../images/image-20230901153530820.png)\n\n如果各个声源相似但由单独的机制产生（如合唱，一团蜜蜂）那么声源之间不具有**相关性**。\n\n对于大量的声源集合，相关与否会导致观察到的平均幅度上的显著差异：\n$$\nA_{相关}=A_a+A_b+A_c\\cdots\\\\\nA_{不相关}=\\sqrt{{A_a^2+A_b^2+A_c^2\\cdots}}\n$$\n\n### 衰减\n\n#### 距离导致的几何损耗\n\n![image-20230901160653650](../images/image-20230901160653650.png)\n\n对于圆柱模型（琴弦，或是繁忙的公路），辐射功率的耗散正比于距离。\n\n对于球模型，功率耗散正比于距离的平方。\n\n#### 吸收导致的能量损耗\n\n声音频率越高，速度越快，吸收损耗越大（斯托克斯定律）\n\n衰减α：(η：粘滞度)\n$$\nα=\\frac{2η2\\pi\\\\f^2}{3ρc^3}(Np/m)\\\\ *8.685889\\rightarrow(dB/m)\n$$\n\n### 传播效应\nP58补\n* 反射\n\n纵向的声波在反射时会保持相同的(压强)相位，我们将听到由直达波和反射波相互叠加所引起的效果，类似的驻波模式图样将出现在房间等声学空间中。\n![image-20230904131043414](../images/image-20230904131043414.png)\n\n* 散射\n\n* 弥散\n* 折射\n* 衍射\n\n### 声学振荡\n\n## 心理声学\n\n\n\n人类听觉的频率范围：20~20kHz\n\n自然声音（语音和音乐）的大部分频率都在300~3kHz之间。\n\n### 定位\n\n三大规律：\n\n* 高频声音比低频声音更容易定位，且声音刚开始的时候比延音更容易定位。\n* 在户外或自由空间中对声音的定位能力好于在具有大量反射的小房间中的定位能力。\n* 倾斜头部能获得更好的仰角感知，更容易定位\n\n#### 耳间强度差IID\n\n抵达每只耳朵的相对幅度（即立体声系统中的**声像定位-panning**）\n\n在频率高于700Hz开始有效，1.5kHz以上时完全工作。\n\n#### 耳间时间差ITD\n\n声音抵达两只耳朵的时间差值。当多于一个完整波长放到两耳之间（15~25cm），就会引起含糊不清。\n\n因此耳间时间差对700Hz以下的声音最有效，在1.5kHz以上时无效。\n\n(r:头部半径；θ：与鼻子方向中线的夹角)\n$$\nITD=r\\frac{(θ+sinθ)}{c}\n$$\n\n### 响度\n\n声音的响度是一个主观数值，单位为sone。\n\n1sone=1kHz的正弦波在40dB SPL的响度。声压级增大10dB SPL，感受到的响度用sone表示会变为原来的2倍。\n\n对于人耳，同声压级的一些频率比另一些频率听上去会更响，因此人们测量得到了等响度曲线，并定义\n\n1phon=1dB SPL的1kHz纯音\n\n![image-20230904140147498](../images/image-20230904140147498.png)\n\n声级表运用“计权滤波器”来补偿频率的相关性，其中A计权标度多用于环境噪声测量，BBC给出的ITU-R468标度用于广播和母带的处理。\n\n#### 时域积分效应\n\n对于200ms以内的持续时间，通过将声音拉长一些毫秒，就可以使它们具有更大的表观音量。\n\n### 音域\n\n* **低音bass**\n  * **次低音sub**：多用于给雷声等音响效果增加深度\n  * **上低音upper bass**：底鼓，贝斯基频，钢琴与吉他较低的八度\n* **中音mid**：人声，弦乐，铜管的最佳音区\n* **高音treble**\n  * **临场感presence**：为人声和乐器增加清晰度\n  * **上方top**：镲片，类噪声音\n  * **空气感air**：所有最高泛音\n\n![image-20230906090620166](../images/image-20230906090620166.png)\n\n### 分辨率\n\n人耳可以区分100Hz和105Hz的区别，但无法区分16000Hz和16005Hz的区别。\n\n### 频谱\n\n**音色timbre**是对频谱的主观感知量，是由一个稳定频谱产生的瞬时的听觉感受。\n\n#### 明亮度\n\n将具有一些较响的高频并不足以让一个声音明亮，声音的明亮度取决于**频谱质心**，以及**起音attack**。\n\n#### 对时域结构的感知\n\n### 包络envelope\n\n在声音设计中通常用四个词描述一个声音的包络：\n\n* 起音attack\n* 衰减decay\n* 延音sustain\n* 释音release\n\n#### Attack\n\n在这个阶段，声音从0开始上升到最大能量处。对于打击型声音，这个起音非常短；对于琴弦，可以长达几秒钟。\n\n从斜面滑落空气的物体可以模拟起音的过程，该物体持续加速，同时摩擦激励产生一个越来越响的声音。\n\n#### Decay\n\n衰减应用于那些在瞬变阶段后有能量持续供应的系统上。\n\n#### Sustain\n\n在这个阶段，系统的输入能量等于输出能量。\n\n#### Release\n\n系统不再接受能量，只通过存储的能量产生一段声音。对于运动物体，这个数值对应于动量，对于流体则对应于存储能力。\n\n### 哈斯效应\n\n又称先入为主效应，决定了我们在何处区分环境与声源。\n\n大约30ms后接受到的反射声将被分配给环境，被听成单独的回声，比如在大厅里击掌产生的回声；发生在30ms内的反射声被融合到这个声音本身中，比如古典吉他的空腔内产生的回声\n\n### Gabor极限\n\nGabor极限标出了一个声音具有音高所需的最小持续时间，大约在10~20ms。\n\n# 合成器\n\n## 放大器Amplifier\n\n## 振荡器Oscillator\n\n### 音频振荡器\n用于产生音频，不同波形会产生不同音色timbre的声音，振幅影响响度\n### 低频振荡器（LFO）\n用于调制某个音频，让一个参数（音高，音量等）来回振荡，使音频的某些特性随时间变化。\n慢速的调制通常用作改变行为（声音的表现），而快速调制则用来改变音色（声音本身的特征）\n\n## 滤波器Filter\n* Low-Pass Filter低通滤波器\n\n  ![image-20230912205725143](../images/image-20230912205725143.png)\n  \n  * Resonance：共振，增强截止频率周围的振幅\n  * Frequency：滤波器的截止频率\n\n## 合成弹拨贝斯\n<div style='display:flex;width:100%;'>\n<img style='width:50%;' src='../images/image-20230912210218103.png' />\n<img style='width:50%;' src='../images/image-20230912210242942.png' />\n</div>\n\n声音的”弹拨”性是由包络调制滤波器而生成的。 这会导致滤波器快速开合和关闭。\n\n### 音高失谐detune\n\n* cents音分：一音分等于半音的百分之一\n\n* semitone半音\n\n  12semitone=1个八度\n\n## 噪声发生器\n\n噪声发生器会生成没有音高的声音，可以用来模拟风或雨的声音。","tags":["音乐"],"categories":["音乐"]},{"title":"安装与配置MySQL(Ubuntu)","url":"/2023/06/26/MySQL_commands/","content":"## 安装mysql\n\n```shell\nsudo apt update\nsudo apt install mysql-server\t\n```\n\n## 查看mysql是否安装成功\n\n```shell\nmysql --version\n```\n\n## 设置root用户的密码\n\n```shell\nsudo mysql #登录mysql服务器\n```\n\n```sql\nsql指令:\n/*将new_password部分替换为你的新密码*/\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new_password';\n/*更新用户权限*/\nFLUSH PRIVILEGES; \n/*退出sql命令行*/\nexit\n```\n\n## 查看mysql服务器运行状态\n\n```shell\nsudo service mysql status\n```\n\n如果MySQL正在运行，将显示\"active (running)\"\n\n## 启动mysql服务器\n\n```shell\nsudo service mysql start\n```\n\n## 本地连接mysql服务器\n\n```shell\nmysql -u <username> -p\n```\n\n将`<username>`替换为用户名(未创建新用户则填root)\n\n## 查看MySQL服务器的ip地址\n\n通常主机外网ip即为服务器ip地址\n\n```shell\nifconfig #linux\n```\n\n## 配置MySQL服务器远程连接\n\n### 编辑配置文件'mysqld.cnf'\n\n```shell\nsudo nano /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在 `mysqld.cnf` 文件中找到 `bind-address` 选项，并将其注释掉或将其值设置为MySQL服务器的IP地址。默认情况下，此选项被设置为 `127.0.0.1`，只允许本地连接。如果要允许远程连接，请将其修改为服务器的实际IP地址或注释掉该行。例如：\n\n```\n#bind-address = 127.0.0.1\n```\n\n保存并关闭`mysqld.cnf`文件（ctrl+x）\n\n### 重启MySQL服务器以应用更改\n\n```shell\nsudo systemctl restart mysql\n```\n\n### 创建或授予远程访问权限\n\n```shell\nsudo mysql\n#或\nmysql -u root -p\n```\n进入sql命令行\n```sql\n/*显示MySQL服务器上所有用户列表*/\nSELECT user, host FROM mysql.user;\n```\n如果有用户拥有`%`主机的访问权限，则该用户可以进行远程访问。如果没有，则授予权限\n\n```sql\n/*替换<password>（包括大小于号）*/\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '<password>' WITH GRANT OPTION;\n\n/*刷新用户权限*/\nFLUSH PRIVILEGES;\n\nexit\n```\n\n或创建新用户：\n\n```sql\n/*替换<username>和<password>（包括大小于号）*/\nCREATE USER '<username>'@'%' IDENTIFIED BY '<password>';\n\n/*授予新用户对所有数据库的完全权限*/\nGRANT ALL PRIVILEGES ON *.* TO '<username>'@'%' WITH GRANT OPTION;\n\n/*刷新用户权限*/\nFLUSH PRIVILEGES;\n\nexit\n```\n\n## 查看MySQL服务器端口\n\n默认为3306，若进行了自定义设置可在**sql命令行**使用以下指令\n\n```sql\nSHOW VARIABLES LIKE 'port';\n```\n\n## 关闭Ubuntu防火墙\n\n```shell\n#关闭防火墙\nsudo ufw disable\n#查看防火墙状态，若显示'Status:inactive'则关闭成功\nsudo ufw status\n```\n\n# MySQL语言\n\n"},{"title":"Qt开发记录","url":"/2023/03/04/my-Qt-note/","content":"\n# 版本信息\n```python\nQt creator==9.0.2\npython==3.9.7\n\n```\n\n# 关系结构\n\n# Layout\n\n# QtWidgets\n* `QWidget`：基本容器\n* `QPushButton`\n\n# QML\n* 每个QML文件需要有一个唯一的根元素\n* 声明形式\n* ```css\n  type{\n  id:不带引号的标识符，所有元素唯一//其他元素通过id访问\n  width:\n  height:\n  property int <名称>:1//自定义属性(要写明类型)\n  property alias <名称>:<引用>//引用其他属性  \n  }\n  ```\n* \n```\n\n## QtQuick\n\n\n##  初始化\n```css\n*{\n\tborder:none;\n\tbackground-color:transparent;\n\tbackground:none;\n\tpadding:0;\n\tmargin:0;\n\tcolor:#fff;\n}\n```"},{"title":"《献给阿尔吉侬的花束》","url":"/2023/02/25/read-Flowers-for-Algernon/","content":"\n# 引言\n\n>箱子里有迷宫。\n>\n>你在错综复杂的道路上前行。\n>\n>你相信墙的另一侧一定有些什么，\n>\n>时而失道却坚定地向着出口前进。\n>\n>这身影对我有些耀眼。(阿尔吉侬)就是这样的一首曲子。\n>\n><p style=\"text-align:right\">——n-buna</p>\n\n<!--more-->\n\n前段时间听夜鹿新曲[アルジャーノン(阿尔吉侬)](https://music.163.com/#/song?id=2020247157)得知其原型是科幻巨著《献给阿尔吉侬的花束》。\n\n小说从主人公 查理·高登 的自述开始。通过没有逗号、错别字满篇的报告得知，他是一名30多岁的智力障碍者，在面包店做些清扫工作，同时在低能成人学校努力学习。他想变聪明，想让面包店的同事高兴，想理解他的朋友们所谈论的话题，并参与其中。\n\n后来，他被带到声称能改造智力的科学实验室中，在那里遇到了高智商老鼠 阿尔吉侬。阿尔吉侬是唯一一个实验成功的老鼠，它快速走出迷宫的样子令查理感到无比的惊讶和敬佩。\n\n科学家和医生看到查理天性善良，又有上进心，认为他是人体实验的不二之选。查理接受了手术，变成了天才。然而，等待他的不是为他自豪的朋友，而是他不曾体会的复杂世界。\n\n<font color='scarlet'>**※以下涉及剧透**</font>\n\n[^n-buna]: n-buna（ナブナ）音乐组合ヨルシカ（[Yorushika/夜鹿](https://baike.baidu.com/item/Yorushika/61892682?fromModule=lemma_inlink)）成员，负责作词、作曲、编曲。\n\n# 人物关系图\n\n![flowersForAlgernon](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/flowersForAlgernon.png)\n\n# “比拥有高智商更重要的事”\n在智力的飞速发展下，查理很快便掌握多门语言，读通最前沿的科学论文。一开始，他以为这就是正常人的世界，但此时的查理和其他人之间的隔阂却和手术前一样大。查理不能忍受尼姆等人追求名利，他在公开场合说的话虽然理性而正确，但让这些科学家们难堪。\n\n高智商让他察觉人性中的丑恶，但没有给他宽容这些丑恶的人情。\n\n>但我可以告诉你一件事，在你手术之前，你并不是这个样子。你不会在自己的秽物中打滚，不会沉迷于自怜，不会整天整夜坐在电视机前污染自己的心灵，更不会大声对别人咆哮。你有些令我们尊敬的特质……没错，即使是过去的你。你身上有些我从来没有在其他弱智者身上见过的特别东西。\n>\n><p style=\"text-align:right\">——艾丽斯·纪尼安</p>\n\n# 献给阿尔吉侬\n\n查理得知留给自己的时间不长后，把所有精力花在研究他自身发生的变化上。他并没有用他梦寐以求的聪明去做自己想做的事，而是用昙花一现的人类最高智力，去推进科学发展，为未来其他智障者开辟道路。\n\n>我把阿尔吉侬的尸体放在一个小金属容器里带回家，我不会让他们把它丢进焚化炉。这样做有些愚蠢和伤感，但昨天深夜我把它埋在后院。把一束野花放在坟上时，我哭了起来。\n\n------\n\n我和查理没有什么共同点可言，无论是在他做手术前，还是之后。我想象自己如果在书中是个什么样的位置，最后发现可能只是面包店里默默工作的一员。我不会嘲笑和捉弄查理，也不会在他变成高智商时排挤他。但我的篇幅一定不会比金皮或者乔更多。或许查理会主动和我敞开心扉，而我多半对此爱莫能助；或许我从头到尾都不会知道查理对命运的伟大抗争。\n\n全世界有7%左右的残疾人，其中智力残疾比肢体残疾要少一些。在我的20多年人生中，擦肩而过的可能有10来个，但不曾接触过他们中的任何人。我自认为与人交流时有注意不让对方尴尬难堪，但或许我并不比那些为残障机构捐款却从不与他们交流的富豪更有同情心。我自认为对任何人都没有歧视和偏见，但我实际能做到的只是保持沉默和中立，却不能提供真正的帮助。我无时不希望自己是个善良热情的人，但我身上的冷淡部分总是在阻止与他人的共情。\n\n我的心灵是一块开阔却贫瘠的土地，不会拒绝踏入的脚印，但也找不着一束可以献上的花。\n\n","tags":["感想"],"categories":["读书笔记"]},{"title":"并发/并行&同步/异步","url":"/2022/11/05/my-programing-note1/","content":"\n# 并发vs并行\n\n## 并发(Concurrency)\n\n并发是一个宽泛概念，表示计算机同时执行多项任务。\n\n对于单核处理器，可以通过分配时间片的方式（又称上下文切换context switching）\n\n## 并行(Parallelism)\n\n在多核处理器中，真正意义上同时执行多项任务。\n\n<!--more-->\n\n# 同步vs异步\n\n## 同步编程(Synchronous)\n在执行完一项任务后才执行下一项任务，没有并发并行的概念\n## 异步编程(Async)\n\n在**单线程中**同时执行多个任务的编程方式。无需考虑线程同步，线程竞争的问题。\n\n适用于有网络操作，数据库访问等I/O密集的应用程序。如果使用多线程，线程中的大部分时间在等待，反而浪费了线程切换和线程内存的开销。多线程适合计算量大的程序。\n\n### Javascript\n\nJs中实现异步的方法有callback，Promise，async/await\n\n#### async/await\n\nasync将函数标记为异步函数，返回值为Promise对象。在async函数中可以调用await标记的异步函数。\n","tags":["编程"],"categories":["程序设计"]},{"title":"餐厅管理网页练习","url":"/2022/10/16/my-vue-practice1/","content":"\n记录一下这两天用vue模写网页的过程。\n\n成品：\n\n![my-vue-practice1](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/my-vue-practice1.png)\n\n<!--more-->\n\n※设计图来自IQQNIC Design的[免费餐厅管理模板](https://pixso.cn/community/file/iwhOWVDOeICw39kGAlSxrA)\n\n页面最外层：\n\n* sidebar：固定像素，fixed固定在侧边\n\n* navigationBar+router-view：上下结构，这次只做了home界面所以路由不会切换\n\n黄色框内的元素均为响应式渲染，由store里的数据管理。\n\n# 解决的技术问题\n\n## 滚动条显示异常\n\n在写`Home.vue`时，明明页面超出了屏幕，却不显示滚动条，也无法滑动。\n\n```html\n<!--App.vue-->\n<template>\n    <div class=\"APPcontainer\">\n            <SideBar/>\n        <main class=\"APPmain\">\n            <div class=\"navigation\">\n                <NavigationBar />\n            </div>\n            <div class=\"mainView\">\n                <!--这部分超出了界面-->\n                <router-view />\n            </div>\n        </main>\n    </div>\n</template>\n```\n\n**解决方法**：\n\n```css\n<!--在最外层容器添加-->\n.APPcontainer {\n    overflow-y: scroll;\n    width: 100vw;\n    height: 100vh;\n}\n```\n\n原理没搞懂，`height:100vh`比较关键，不加这句的话滚动条长得会比较奇怪。\n\n## CSS简单动效\n\n`transition:[时间]`可以在元素样式产生变化时自动生成补间，像淡出淡入，侧栏展开等。\n\n`filter`属性可以改变元素的颜色，功能繁多。\n\n  \n","tags":["编程"],"categories":["前端"]},{"title":"网页设计学习笔记","url":"/2022/10/13/my-web-design-note/","content":"\n# 页面尺寸的选择\n\n## 网页宽度&有效可视区\n* **网页宽度**：进行页面设计时画板的宽度\n* **有效可视区**：网页内容所占的宽度\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/2107_01.jpg)\n<!--more-->\n[Statcounter Global Stats](https://gs.statcounter.com/screen-resolution-stats/desktop/worldwide)上可以看到当前PC端显示器的流行尺寸，由此得出结论：\n\n> 网页宽度：1920\n>\n> 有效可视区：900~1200\n\n![image-20221013124444439](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221013124444439.png)\n\n\n# 响应式布局\n\n若不希望可视区占比太小，可以采用响应式布局使得网页在不同的尺寸下有不同的布局。\n\n![リキッドレイアウトの簡単な説明：レイアウトは同じでコンテンツの幅がディスプレイの幅に応じて変化する。](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/0117-1.png)\n\n## 百分比\n\n### %\n相对于父元素，或无父元素则相对于视窗\n\n| 属性              | 百分比基准                         |\n| ----------------- | :--------------------------------- |\n| width             | 基于父级的width                    |\n| height            | 基于父级的height                   |\n| margin(四个方向)  | 基于父级的width                    |\n| padding(四个方向) | 基于父级的width                    |\n| left,,right       | 基于**非static定位**的父级的width  |\n| top,bottom        | 基于**非static定位**的父级的height |\n\n### vw&vh\n* 1vw=1%视窗宽度\n* 1vh=1%视窗高度\n* vmin：vw和vh中较小值\n* vmax：vw和vh中较大值\n\n## rem(font size of the root element)\n\nrem为相对于**根元素字体大小**的单位\n\n## 媒体查询\n\n```css\n//页面宽度大于960px小于1200px\n@media screen \nand (min-width:960px) \nand (max-width:1200px){\n        /*---*/\n}\n```\n\n# flex布局\n\nFlex布局中存在main axis(横向)和cross axis(纵向)两个轴，默认将元素在main axis从左向右排列\n\n## `justify-content`\n可以决定容器中元素在**主轴**方向的位置\n* `flex-start`：将元素对齐主轴首端\n* `flex-end`：将元素对齐主轴末端\n* `center`：将元素居中\n* `space-between`：使第一个元素位于主轴首端，最后一个元素位于主轴末端\n* `space-around`：将元素等距排列，且第一个元素和最后一个元素到边界的距离相当于元素间距离的一半\n\n## `align-items`\n可以决定容器中元素在**副轴**方向的位置\n\n- `flex-start`：将元素对齐副轴首端\n- `flex-end`：将元素对齐副轴末端\n- `center`：将元素居中\n- `stretch`：\n- `baseline`：\n\n## `align-self`\n作用于flex布局内的**元素**。选项与`align-items`相同，用于具体修改某个元素的纵向布局。\n\n## `flex-direction`\n可以修改主轴的方向\n\n- `row`：主轴为横向，从左向右\n- `row-reverse`：主轴为横向，从右向左\n- `column`：主轴为纵向，从上向下\n- `column-reverse`：主轴为纵向，从下向上\n\n## `order`\n作用于flex布局内的**元素**。默认值为0，可选择任意**整数值**。数值大的元素将排列在后面。\n\n## flex实现自动填充\n```html\n<div class=\"box\">\n  <div class=\"header\">头部</div>\n  <div class=\"auto-fill\">自动填充</div>\n</div>\n```\n\n```css\n.box {\n  display: flex;\n  flex-flow: column;\n}\n\n.header {\n  height: 30px;\n}\n\n.auto-fill {\n  flex: 1\n}\n```\n\n\n# Grid布局\n\n`fr`：grid专有单位，表示比例（fraction）\n\n## `grid-template`\n\n**容器属性**，用于定义栅格行列的宽度，数量\n\n* `grid-template-columns`\n* `-rows`\n* 【选项】`repeat(重复次数,值)`：\n\n```less\n//相当于\"100px 100px 100px\"\ngrid-template-columns:repeat(3,100px);\n//自动按照容器宽度填充（响应式）\ngrid-template-columns:repeat(auto-fill,100px);\n```\n\n* 【选项】`minmax(最小值，最大值)`\n* 【选项】`auto`\n* 【选项】`网格线[...]`\n* `-areas`：设定网格区域：\n```less\ngrid-template-areas:'a b c' \n\t\t\t\t\t'd e f'; \n//匿名区域：\".\"\n//在项目上分配区域：\"grid-area:区域名;\"\n//每个区域的起始网格线自动命名为\"区域名-start\"\n//终止网格线自动命名为\"区域名-end\"\n```\n\n## `gap`\n\n**容器属性**，设置行，列的间距。\n\n* `row-gap`\n* `column-gap`\n* `gap`\n\n## `grid-auto`\n\n### `grid-auto-flow`\n\n**容器属性**，设置自动排列的方向\n\n* 【选项1】`row`：按行排放（默认）\n* 【选项1】`column`：按列排放\n* 【选项2】`dense`：用后排项目填补空余部分\n\n![image-20221104105341526](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221104105341526.png)\n\n### `grid-auto-rows/columns`\n\n**容器属性**，设置多出项目的宽(column)和高(row)\n\n## 对齐选项\n\n### `-items`\n\n**容器属性** ：决定项目在**单元格内**的对齐方式\n\n* `justify-items`：水平方向对齐\n* `align-items`：垂直方向对齐\n  * `start|end|center|stretch`：stretch为撑满单元格\n* `place-items`：\\<align-items> \\<justify-items>\n\n### `-content`\n\n**容器属性**：决定网格区域在父元素内的对齐方式\n\n* `justify-content`：水平方向对齐\n* `align-content`：垂直方向对齐\n  * `start|end|center|stretch`\n  * `space-around`\n  * `space-between`\n  * `space-evenly`：等间距分布（包括与边界的距离\n\n## 项目属性\n\n### 指定位置\n\n* `grid-column/row-start/end`\n\n  ※简写:`grid-column:1/3;`\n\n  ※跨行写法：`grid-column-start:span 3;`(占三列)\n\n![image-20221104114016154](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221104114016154.png)\n\n* `grid-area`：指定所在区域\n\n```less\ngrid-area:区域名;\ngrid-area:1/1/3/3;\n//简写column-start/column-end/row-start/row-end\n```\n\n### 对齐\n\n* `justify-self/align-self`：设置项目在单元格内对齐方式\n\n\n# CSS技巧\nbox-shadow: offset-x(x偏移) offset-y(y偏移) blur(模糊半径) spread(扩展半径) color(颜色) position(inset内阴影);\n\n透过上层点击到下层元素：给上层元素添加{pointer-events:none;}\n\n```\noverflow：hidden；--溢出隐藏\n\nwhite-space:nowrap; --文本不换行，文本会继续在一行显示\n\ntext-overflow：ellipsis;  --这时用此属性才能出现省略号\n```\n\ntext-overflow失效：父元素为flex布局\n\n`user-select: none` ：阻止用户选中文本\n\n## 混合模式\n\n```\nmix-blend-mode: normal; //正常\nmix-blend-mode: multiply; //正片叠底\nmix-blend-mode: screen; //滤色\nmix-blend-mode: overlay; //叠加\nmix-blend-mode: darken; //变暗\nmix-blend-mode: lighten; //变亮\nmix-blend-mode: color-dodge; //颜色减淡\nmix-blend-mode: color-burn; //颜色加深\nmix-blend-mode: hard-light; //强光\nmix-blend-mode: soft-light; //柔光\nmix-blend-mode: difference; //差值\nmix-blend-mode: exclusion; //排除\nmix-blend-mode: hue; //色相\nmix-blend-mode: saturation; //饱和度\nmix-blend-mode: color; //颜色\nmix-blend-mode: luminosity; //亮度\nmix-blend-mode: initial; //初始\nmix-blend-mode: inherit; //继承\nmix-blend-mode: unset; //复原\n```\n\n## 使用绝对定位做抽屉\n\n","tags":["编程","设计"],"categories":["前端"]},{"title":"Vue3应用练习","url":"/2022/10/03/my-first-vue-app/","content":"\n在跟着[Vue3通用后台管理](https://www.bilibili.com/video/BV1QU4y1E7qo/)敲完代码，又对着Vue3文档学了个大概后，做了个应用试手。👉[Vue3应用练习 (lzmustb.github.io)](https://lzmustb.github.io/test/#/)\n\n<!--more-->\n\n----\n\n# 技术栈\n* Vue3\n* Vite\n* vue-router\n* pinia\n* element-Plus\n\n----\n\n# 实现的功能\n\n* 通过`增加批注`按钮给文章的选定段落增加批注。\n* 批注包括`名称`，`批注内容`，`时间`，`选定段落`\n* 增加的`批注`会显示在文章的侧栏。\n* **点击批注**会标记该批注和选定的段落，且同时只有一个批注会被选定。\n* 在**批注汇总**页显示所有文章的所有批注。\n* 在**批注汇总**页**点击批注**会跳转到目标批注所在的文章及段落，同时使该批注被选定。\n\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221003124743017.png\" alt=\"image-20221003124743017\" style=\"zoom: 25%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20221003124822698.png\" alt=\"image-20221003124822698\" style=\"zoom: 25%;\" />\n\n----\n# 遇到的问题\n\n## onClick事件内注册的click侦听器会直接被触发\n```javascript\n//按钮绑定了onclick事件\nconst onClickEvent = () => {\n    //update()会在按钮时直接被触发\n    window.addEventListener('click', update);\n}\n```\n\n**解决方法**：将`click`事件换成`mousedown`\n\n## 在点击批注跳转后使该批注变成选定状态\n\n**解决方法**：`onActivated()`\n```javascript\nimport {onActivated} from 'vue'\nonActivated(()=>{\n\t//每当页面被重新加载就会执行\n});\n```\n\n## 多行文字的截取省略\n\n**解决方法**：找准文字所在的块级元素\n\n```css\np {\n    display: -webkit-box;\n    overflow: hidden;\n    -webkit-line-clamp: 2; //限制的行数\n    -webkit-box-orient: vertical;\n}\n```\n----\n\n# 总结\n\n我的前端学习比较断断续续，缺乏练习和规范，导致实际操作起来试错很多。虽然遇到的问题最终都解决了，但做一个省略了UI的小功能应用还花了将近两天时间。而且这次实践也让我体会到UI设计并不容易，得进行系统的学习。更不要妄想不打设计稿，边敲代码边设计。","tags":["编程"],"categories":["前端"]},{"title":"Vue3","url":"/2022/09/25/Vue3-conclusion/","content":"\n# Vue3\nVue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n\n<!--more-->\n\n----\n\n# 开发步骤\n\n\n## step_0_构建\n\n### Vite脚手架\n\n通过脚手架，可以快速构建项目预设，包含`main.js`，`App.vue`以及`/src`文件夹等。\n```shell\n//安装vite脚手架并构建预设vue项目\nyarn[或cnpm] create vite my-vue-app --template vue\n\n//进入项目根目录，安装\ncd my-vue-app\nyarn install\n\n//创建本地服务器，进入开发模式\nyarn dev\n```\n### elementPlus引入\n\n```javascript\n//进入根目录，安装element-Plus\ncnpm install element-plus --save\n\n//安装插件\ncnpm install -D unplugin-vue-components unplugin-auto-import\n\n//插入到vite.config.js\nimport { defineConfig } from 'vite'\nimport AutoImport from 'unplugin-auto-import/vite'\nimport Components from 'unplugin-vue-components/vite'\nimport { ElementPlusResolver } from 'unplugin-vue-components/resolvers'\n\nexport default defineConfig({\n  // ...\n  plugins: [\n    // ...\n    AutoImport({\n      resolvers: [ElementPlusResolver()],\n    }),\n    Components({\n      resolvers: [ElementPlusResolver()],\n    }),\n  ],\n})\n```\n\n完整引入Icon\n```javascript\n//main.js\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\nconst app=createApp(App)\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n  app.component(key, component)\n}\n```\n\n### 安装&配置 vue-router\n```javascript\n//项目根目录，安装4.0以上vue-router\nnpm install vue-router@4\n\n//\"src/router/index.js\"\nimport {createRouter,createWebHashHistory} from 'vue-router'\n\n//存储路径\nconst routes=[\n    {\n        path:'/',\n        name:'intro',\n        component: ()=>import('../views/Intro.vue')\n    },\n]\n\n//创建路由实例\nconst router = createRouter({\n    history: createWebHashHistory(),\n    routes\n})\nexport default router\n```\n\n### 安装&配置 pinia\n```javascript\n//根目录\nnpm install pinia\n\n//\"src/store/index.js\"\nimport {defineStore} from \"pinia\";\nexport const useStore = defineStore('id',{\n    state: () => ({\n        isCollapse:false,\n        currentMenu:null,\n        tabsList:[\n            {\n                path:'/home',\n                name:'home',\n                label:'首页',\n                icon:'home'\n            }\n        ],\n        menu:[\n        ],\n        token:''\n    }),\n})\n```\n\n\n## step_1_创建应用实例\n```javascript\nmain.js//入口文件\n\n<!--1.创建应用实例-->\n//导入createApp，单文件根组件\nimport {createApp} from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport { createPinia } from 'pinia';\n//createApp(根组件,根组件Props[可选])\nconst app = createApp(App)\n/*---外部导入↑或↓内联---*/\nconst app = createApp({\n    /*内联根组件*/\n})\n\n<!--2.引入router,pinia-->\napp.use(router).use(createPinia())\n\n<!--3.将应用实例挂载在一个容器元素中-->\n//mount(DOM元素或CSS选择器)\n//每个应用实例仅能调用一次mount()\napp.mount('#app')\n/*---CSS选择器↑或↓DOM元素---*/\napp.mount(document.body.firstChild)\n```\nApp相关方法，属性\n\n* `unmount()`：卸载一个已挂载的应用\n* [`provide()`](https://cn.vuejs.org/api/application.html#app-provide)：提供一个值，在应用中的所有后代组件中注入使用。\n* [`component()`](https://cn.vuejs.org/api/application.html#app-component)：注册组件\n* [`directive()`](https://cn.vuejs.org/api/application.html#app-directive)：注册指令\n* [`use()`](https://cn.vuejs.org/api/application.html#app-use)：安装一个插件\n* `version`：当前应用所使用的 Vue 版本号\n* [`config`](https://cn.vuejs.org/api/application.html#app-config)：对这个应用的配置设定\n* [`config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties)：注册能够被应用内所有组件访问的全局属性的对象\n\n## step2_组件(component)\n\n命名建议：PascalCase(所有首字母大写)\n\n### pinia的使用\n\n```javascript\nimport { useStore } from '../../store';\nconst store = useStore();\n\n```\n\n\n\n### 创建组件\n\n## step3_测试\n\n### 单元测试\n\n[单元测试](https://cn.vuejs.org/guide/scaling-up/testing.html#unit-testing)侧重于逻辑上的正确性，只关注应用整体功能的一小部分。\n\n----\n\n# 单文件组件\n\n> **前端开发的关注点不是完全基于文件类型分离的**。在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。\n\n将一个Vue组件的模板(html)，逻辑(javascript)，样式(css)封装在单个文件`*.vue`中。\n\n每个文件都由三种顶层语言模块构成：`<template>` `<style>` `<script>` \n\n## \\<template>\n\n* 每个 `*.vue` 文件最多包含一个`<template>`标签。标签中可以使用原生html，`\\<router-view/>`，以及element-Plus等UI框架提供的API等。\n\n## \\<style>\n\n* 每个 `*.vue` 文件可以包含**多个** `<style>` 标签。标签内使用css相关语言\n\n### \\<style scoped>\n带有`scoped`属性的style标签值会影响当前组件内的元素。\n\n```html\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\">hi</div>\n</template>\n-----↓↓↓通过 PostCSS 将内容转化↓↓↓-----\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n※子组件的根元素只有**一个**时<font color=#aaa>(`<template>`内的最外层元素)</font>会附带父组件的`data-v-hash`，同时被父组件的样式和子组件的样式影响。\n\n**当子组件和父组件有同名class的选择器时，父组件样式会覆盖子组件样式**。\n\n子组件设置`inheritAttrs`为`false`，非`props`属性不会应用到子组件根元素上。但父组件使用标签选择器时，子组件样式依然被影响。\n\n#### 选择器\n* `:deep()`\n* `:slotted()`\n* `:global()`\n* **小心递归组件中的后代选择器**！对于一个使用了 `.a .b` 选择器的样式规则来说，如果匹配到 `.a` 的元素包含了一个递归的子组件，那么所有的在那个子组件中的 `.b` 都会匹配到这条样式规则。\n\n### \\<style module>\n编译为CSS Modules([暂略](https://cn.vuejs.org/api/sfc-css-features.html#css-modules))\n\n### v-bind()\n\n```html\n<script>\nexport default {\n  data() {\n    return {\n      color: 'red'\n    }\n  }\n}\n</script>\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n自定义属性会通过内联样式的方式应用到组件的根元素上，并且在源值变更的时候响应式地更新\n\n### 预处理器\n[暂略](https://cn.vuejs.org/api/sfc-spec.html#pre-processors)\n\n## \\<script>\n\n* 每个 `*.vue` 文件最多可以包含一个`<script>`和 `<script setup>`\n\n### 构成\n```html\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n```\n\n### export\n`export`用于导出单文件组件的**选项对象**，以便在其他组件中用`import`引入。`export default`导出为一整个模块，`export`可以分别命名导出的模块。一个js中只能由一个`export default`，但可以有多个`export`。\n\nmain.js在构造根组件时，如果根组件包含其他子组件，那么Vue会通过引入的**选项对象**构造对应的组件。\n\n## 组件使用\n\n### 注册子组件\n\n```html\n//局部组件\n<script setup>\n//注册子组件，可在模板中任意使用\nimport ChildComponent from './ChildComponent.vue'\n</script>\n<template>\n\t<ChildComponent />\n\t<ChildComponent />\n</template>\n\n//全局组件(main.js中)\nimport ChildComponent from './ChildComponent.vue'\napp.component('Child',ChildComponent)\n```\n\n每个组件都是独立的实例，维护独立的属性。\n\n### 组件参数-Props\n* 通过Props属性，子组件可以从父组件接收参数。\n* 当使用对象形式声明props时，值为该prop预期类型的构造函数。该方法可以在prop传入错误类型时抛出警告。\n* 可以用一个`const`变量取接收`defineProps()`返回的对象\n* 所有prop都是可选的，除非声明`required:true`\n* 未传递的prop默认值为`undefined`或Boolean则为`false`\n\n```html\n<!--子组件中-->\n<script setup>\nconst props=defineProps(['title'])\n    <!--或者-->\ndefineProps({\n  title: String,\n  propA: {\n    type: Object,\n    required: true\n    //自定义类型校验\n    validator(value){\n      return { message: 'hello' }\n    }\n  }\n})\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n  </div>\n</template>\n\n<!--父组件中-->\n<div>\n  <BlogPost title=\"Why Vue is so fun\" />\n  <!--也可通过v-bind传递变量-->\n  <BlogPost :title=\"post.title\" />\n  <!--批量传入Props(post对象包含所有props)-->\n  <BlogPost v-bind=\"post\" />\n</div>\n```\n\n所有的 props 都遵循着**单向绑定**原则，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值\n\n<font color=#b00>※prop在子组件中是只读的，当你尝试修改时，vue会抛出警告</font>\n\n>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。\n>\n>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在大多数场景下，子组件应该**抛出一个事件**来通知父组件做出改变。\n\n### 组件事件-Emits\n* 通过Emits属性，子组件可以抛出一个事件，给父组件接收\n\n```html\n<!--子组件中-->\n<script setup>   \ndefineEmits(['enlarge-text'])\n</script>\n\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n\n<!--父组件中-->\n<div :style=\"{ fontSize : postFontSize +'em' }\">\n  <BlogPost title=\"Why Vue is so fun\" @enlarge-text=\"postFontSize += 0.1\"/>\n</div>\n```\n\n#### 事件参数&事件校验\n[略](https://cn.vuejs.org/guide/components/events.html#event-arguments)\n\n\n### 插槽-slot\n通过slot，父组件可以向子组件传递元素，从而在子组件中完成渲染。\n\n※插槽的内容无法访问到子组件的状态\n\n```html\n<!--父组件中-->\n<AlertBox>\n  Something bad happened.\n</AlertBox>\n\n<!--子组件中,slot部分会被父组件传入的元素取代-->\n<template>\n  <div class=\"alert-box\">\n    <slot>可在此填入默认内容</slot>\n  </div>\n</template>\n```\n\n#### 具名插槽\n\n带 `name` 属性的插槽被称为具名插槽 (named slots)，未提供`name`则隐式地命名为“default”。\n```html\n<!--子组件中-->\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n</div>\n\n<!--父组件中-->\n<BaseLayout>\n  <template v-slot:header>\n  <!--或简写-->\n  <template #header>\n  <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n#### 作用域插槽\n[略](https://cn.vuejs.org/guide/components/slots.html#scoped-slots)\n\n### 动态切换组件\n通过`component`元素和`is`属性可以实现动态组件，`is`的值可以是**被注册的组件名**或**导入的组件对象**。一般情况下，被切换的组件会被销毁。在下次切换回该组件时，会创建一个初始状态的新实例。\n\n通过`<KeepAlive>`内置组件包装动态组件，可以缓存被切换的组件。\n\n可选属性：\n\n* `max`：限制被缓存的数量\n* `include/exclude`：可以筛选需要缓存的组件，传入正则表达式或数组，匹配组件的`name`\n\n```html\n<router-view v-slot=\"{Component}\">\n    <KeepAlive :max=\"3\" :include=\"/a|b/\">\n  \t\t<component :is=\"Component\"/>\n\t</KeepAlive>\n</router-view>\n```\n\n### 透传属性\n当一个属性传递给子组件时，若该属性未被子组件声明为`props`,`emits`,`v-on`事件监听器，则称为**透传attribute**或`Non-props`。\n\n* 当子组件**只含单个根元素**，则透传属性会被自动添加到该元素上，并和元素上原有的属性合并。\n\n* 如果子组件A中是另一个组件B，透传属性会传递给组件B\n* 在组件`export default`中设置`inheritAttrs: false`可以禁用组件透传。\n* 在设为禁用后，在子组件中可以通过`$attrs`[访问](https://cn.vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance)所有透传属性，并通过`v-bind=\"$attrs\"`将透传属性绑定到任意元素上。\n\n```html\n<!--MyButton组件只含一个button元素-->\n<button class=\"child\">click me</button>\n\n<!--父组件中-->\n<MyButton class=\"father\" msg=\"hello\" @click=\"onClick\"/>\n\n<!--最终渲染-->\n<button \nclass=\"child father\" msg=\"hello\" @click=\"onClick\">\nclick me\n</button>\n```\n\n#### 在Js中访问attrs\n以下`attrs`为非响应式。\n```html\n<script setup>\nimport { useAttrs } from 'vue'\nconst attrs = useAttrs()\n</script>\n\n<script>\nexport default {\n  setup(props, ctx) {\n    // 透传 attribute 被暴露为 ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n</script>\n```\n\n# 组合式API\n\n>* 使用函数而不是声明选项的方式书写Vue组件\n>* 包括响应式API，生命周期钩子，依赖注入\n\n## 组合式API的优势\n更灵活地组织代码，让逻辑相关的代码能够集中在一处\n>组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着**你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践**。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。\n\n## 响应式API\n\n### 理解响应性\n[Vue的解释](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#what-is-reactivity)\n> 响应性是可以声明式地处理变化的编程范式，使一个对象发生变化时，与其相关联的对象也能随之发生变化。\n\n响应式对象： Vue 能够跟踪，访问，修改其属性的对象，实际是JavaScript Proxy。\n\n### 定义响应式变量-reactive()\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n```\n#### reactive()规则\n* Proxy和原始对象并非全等，因此使用Vue 的响应式系统应**仅使用你声明对象的代理版本**。\n\n* 已存在的代理对象传入`reactive()`会返回该代理本身。\n\n* 同一个对象传入`reactive()`总是会返回同一个代理对象。\n\n* `reactive()`对原始数据类型无效。\n\n* 将`reactive()`响应式对象解构或传入函数时，失去响应性连接。\n\n* 当一个变量多次接受`reactive()`返回的代理对象，旧的响应式连接会丢失。\n\n```javascript\n  let state = reactive({ count: 0 })\n  // 上面的 ({ count: 0 }) 将不再被追踪\n  state = reactive({ count: 1 })\n```\n### 定义响应式变量-ref()\n`ref()`可以创建任何值类型的响应式，且传给函数或是从一般对象上被解构时，不会丢失响应性，可用于将逻辑提取到 [组合函数](https://cn.vuejs.org/guide/reusability/composables.html) 中\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\nconst object = {foo:ref(1)}\n//ref()将创建一个带value属性的对象\n//count={value:0}\n//count.value=0\n</script>\n```\n\n当ref是模板渲染上下文的顶层属性或文本插值计算的最终值时将自动解包\n```vue\n<template>\n<!-- ↓解包，结果为：0 -->\n{{ count }}\n<!-- ↓解包，结果为：1 -->\n{{object.foo}}\n<!-- ↓不解包，结果为：[object Object]1 -->\n{{object.foo+1}}\n</template>\n```\n\n[ref在响应式对象中的解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref-unwrapping-in-reactive-objects)（略）\n\n### 计算属性\n`computed()`方法接收一个getter函数，并返回一个计算属性**ref**，与一般ref用法类似。计算属性会自动追踪响应式依赖并随之变化。\n\n```javascript\n//setup内\nimport {computed} from 'vue'\nlet number = ref(1);\nlet sign = computed(()=>{\n    return number>0?'plus':'minus'\n});\n```\n与直接调用方法相比，计算属性会有**缓存**功能，只要其响应式依赖不改变，计算属性就会立即返回先前的结果而不重复计算。\n一般方法会在每次页面重渲染时执行\n<font color='#aaa'>※计算函数不应进行计算以外的作用(如更改DOM或做异步请求)</font>\n\n## 生命周期钩子\n\n在**某一时刻**会**自动执行**的函数\n\n![组件生命周期图示](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/lifecycle.16e4c08e.png)\n\n```javascript\n//在实例生成之前\nbeforeCreate()\n//在实例生成之后\ncreated()\n//组件渲染前\nbeforeMount()\n//在组件被渲染到页面后\nmounted()\n//在数据发生变化前\nbeforeUpdate()\n//在数据发生变化，页面重新渲染后\nupdated()\n//当实例销毁前\nbeforeUnmounted()\n//实例销毁后\nunmounted()\n```\n\n以上API全部在`setup()`阶段被调用\n\nrouter-view切换时调用：\n\n```html\n<script setup>\nimport { onActivated, onDeactivated } from 'vue'\n    \nonActivated(() => {\n  // 调用时机为首次挂载\n  // 以及每次从缓存中被重新插入时\n})\n\nonDeactivated(() => {\n  // 在从 DOM 上移除、进入缓存\n  // 以及组件卸载时调用\n})\n</script>\n```\n\n## 依赖注入\n\n## 使用组合式API\n### setup()\n`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n\n1. 需要在非单文件组件中使用组合式 API 时。\n2. 需要在基于选项式 API 的组件中使用组合式 API 的代码时。\n\n**其他情况下，都应优先使用\\<script setup>语法。**\n\n```vue\n<script>\nimport { ref } from 'vue'\nexport default {\n    props:{    \n    },\n    setup(props,context) {\n    const count = ref(0)\n    // 通过return返回的变量会暴露给模板和其他的选项式API钩子\n    return {\n      count\n    }\n  },\n</script>\n```\n\n>在模板中访问从 `setup` 返回的 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref) 时，它会[自动浅层解包](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity)，因此你无须再在模板中为它写 `.value`。当通过 `this` 访问时也会同样如此解包。\n>`setup()` 自身并不含对组件实例的访问权，即在 `setup()` 中访问 `this` 会是 `undefined`。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n### \\<script setup>\n\n* `defineProps()`：声明\n\n# Vue指令\n\n## 动态属性\n```html\n<template>\n<input :[name]='message'/>\n</template>\n\n<script setup>\nconst name='title'\nconst message='helloworld'\n</script>\n```\n\n## v-text\n更新文本内容\n```vue\n<span v-text=\"msg\"></span>\n<!-- 等同于 -->\n<span>{{msg}}</span>\n```\n\n## v-show\n设置内联`display`属性\n\n## v-if/v-else-if/v-else\n可用于`<template>`表示仅包含文本或多个元素的条件块。\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n## v-for\n\nv-for中对**对象**迭代时，最多可使用值，键，索引三个相关变量(顺序固定)\n\n```html\n<script setup>\n    const list={\n        key1:value1,\n        key2:value2\n    }\n</script>\n\n<div v-for=\"(value,key,index) in list\"></div>\n//循环十次\n<div v-for=\"item in 10\"></div>\n```\n\n## v-on\n\n### 修饰符\n```\n事件修饰符:stop,prevent,capture,self,once,passive\nclick:left,right,middle...\nkeydown:enter,tab,delete\n精确修饰符:exact\n```\n\n## v-bind\n\n## v-once\n\n## v-model\n\n```html\n<script setup>\nconst message=[];\n</script>\n<template>\n<input \ntype=\"checkbox\" \nv-model=\"message\" \nvalue=\"VALUE\"\n>\n</template>\n```\n### v-model.lazy\n数据同步减慢，当事件不再被触发的时候再更新数据\n\n### v-model.number\n绑定时进行数据类型转换\n\n### v-model.trim\n去除前后空格\n\n\n\n# TIPS\n\n* 内容超出屏幕不显示滚动条：父元素设置`overflow:scroll`\n\n* flex布局单个子元素靠右：`margin-left:auto`\n\n* 绝对定位居中：\n  * `margin:auto`\n  * `top:50%;left:50%`\n  * `transform:translate(-50%,-50)`\n\n# 路由切换/router\n","tags":["编程"],"categories":["前端"]},{"title":"Java坦克大战个人总结","url":"/2022/04/29/my-TankWar-conclusion/","content":"\n&emsp;&emsp;刚学完Java，为了巩固所学，做了个坦克大战。这次主要挑战了下自定义地图和敌人寻路两个功能。\n\n<!--more-->\n\n## 自定义地图\n\n自定义地图比较简单，只要将地图作为外部文件读取就可以了。\n\n如这么一个txt文件，W是墙壁，P是玩家起始位置，E是敌人起始位置（可以有多个）：\n\n>WWWWWW\n>WPOOOW\n>WOOOEW\n>WWWWWW\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar.png)\n\n读取文件基本结构：\n\n```Java\n\t String filePath=\"../maps/\"+name+\".txt\";//用String生成文件路径，可以根据传入的name读取不同文件\n        InputStream inputStream=getClass().getResourceAsStream(filePath);\n        int data;\n        try {\n            while((data=inputStream.read())!=-1){//read()返回-1，说明读取完毕\n                char ele=(char)data;//将以整数读取的数据转换为字符\n                ......\n            }\n        }\n```\n\n## 敌人寻路\n&emsp;&emsp;常用的寻路算法有广度优先搜索，A-star算法等等。但这次我还是打算自己挑战一下写一个适合这个程序的算法。~~其实是没学会怎么写~~\n最后经舍友启发，写出了一个虽然不是最优路径，但很简短的寻路算法。\n\n### 核心思路\n从起点开始依次遍历相邻方格，并让它们指向起点的方向（好比单向链表），形象点说就是在所有可以行走的方格画上箭头，指向起点。待所有方格填完，再从**终点**沿着箭头寻回起点，就形成了一条唯一的路径。（最后还要反转一下）\n\n![](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/tankwar2.png)\n\n### 地图存储方式\n对于寻路来说，不需要知道地图的所有信息，只要知道每个方格能否通过就行。\n```Java\n//单个结点\npublic class Node {\n    int Px;\n    int Py;\n    boolean canPass;//是否可以通过（水流，墙壁为无法通过的地形）\n    Node last=null;//用于在寻路算法中形成指向起点的链表\n}\n//用Vector存储结点集合\nVector<Node> nodes=new Vector<Node>();\n//用于获取相邻4个结点中可以通过的方格的方法，在后续寻路时起到重要作用\n    Vector<Node> neighbors(int x,int y){\n        Vector<Node> neighborNodes=new Vector<Node>();\n        for(Node n:nodes){\n            if((n.Px-x==-1||n.Px-x==1)&&(n.Py==y)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n            if((n.Px==x)&&(n.Py-y==-1||n.Py-y==1)&&(n.isOpen&&n.canPass)){\n                neighborNodes.add(n);\n            }\n        }\n        return neighborNodes;\n    }\n```\n\n用Graph类存储所有方格的信息，并提供寻路中要用到的算法：\n```Java\npublic class Graph {\n    Vector<Node> nodes=new Vector<Node>();\n     void setGraph();//根据读取的文件初始化所有方格的信息（略）\n     void clearAll();//使所有node的last=null，以便下一轮寻路（略）\n     Node findNode(int x,int y);//根据坐标找到相应的node（略）\n     void setVector(Node now);//核心算法，给所有方格填上箭头\n     void setRoute(Node start,Node goal,Vector<Node> route);//寻回起点，形成路径\n     Vector<Node> reverseRoute(Vector<Node> route);//反转路径【Vector竟然没提供（略）\n}\n```\n\n### 寻路算法\n\n```Java\nvoid findRoute(){\n    Vector<Node> newRoute=new Vector<Node>();\n    int Tx=MyPanel.player1.p_x;\n    int Ty=MyPanel.player1.p_y;\n    Node start=graph.findNode(p_x,p_y);//自身所在位置\n    Node goal=graph.findNode(Tx,Ty);//目标所在位置\n    graph.setVector(start);//“画箭头”的方法\n    graph.setRoute(start,goal,newRoute);//从终点寻回起点，形成路径\n    route=graph.reverseRoute(newRoute);//反转路径，从起点指向终点\n    graph.clearAll();//清除所有箭头\n}\n```\n### 用递归\"画箭头\"\n\n```Java\nvoid setVector(Node now){\n    for(Node n:neighbors(now.Px,now.Py)){\n    \t//对于now相邻的每个方格n，如果还没有画上箭头，就让n.last=now\n        if(n.last==null){\n            n.last=now;\n            setVector(n);//递归，直到其相邻方格均画上箭头就停止\n        }\n    }\n}\n```\n\n### 从终点寻回起点，形成路径\n```Java\nvoid setRoute(Node start,Node goal,Vector<Node> route){\n    Node now=goal;\n    route.add(now);//将now从终点开始沿着箭头位移，并加入到route\n    while(!now.equals(start)){\n        now=now.last;\n        route.add(now);\n    }\n}\n```\n\n## 多线程能做的事\n&emsp;&emsp;本次坦克大战和飞机大战相比，最大的不同还是用到了多线程。在专业的游戏中，渲染引擎，物理引擎等都是在不同线程下以不同频率工作。相比单线程，更加发挥出了硬件的性能，流畅地运行计算量更大的游戏。\n我在坦克大战中，将每个敌人作为一个线程，同时每个敌人的【攻击判断，移动，路径生成】为单独的线程，路径每隔3秒生成一次，攻击判断和移动间隔为30毫秒。\n将行为包装为抽象类，子类行为只要重写job()和canUse()方法就行\n```Java\n//run()为启用线程时执行的方法，job()为抽象方法，子类须重写\n    public void run(){\n        while(KEY!=0){\n            if(canUse()){\n                job();\n            }\n            try {\n                Thread.sleep(30);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    };\n```\n\n刚刚接触多线程，设计还不到位（比如没有把渲染和物理分离），希望在将来的学习中改进。","tags":["大学生活","编程","游戏","Java"],"categories":["游戏制作"]},{"title":"飞机大战-详细流程","url":"/2022/04/09/my-GameMakingProcess/","content":"\n记录一下详细的流程\n<!--more-->\n\n## easyX库\n\n[easyX](https://easyx.cn/)是针对C++的免费绘图库，在制作飞机大战时，需要用该库中的函数来绘制图像。\n**下载安装该库后，使用时需要包含头文件<graphics.h>**\n下面是一定需要用到的函数：\n\n### initgraph(width,height)\n&emsp;&emsp;用于初始化一个宽为width，高为height的绘图窗口\n&emsp;&emsp;默认不会打开控制台，但如下填入第三个参数，可同时打开控制台，用于调试。\n（比如给一个函数加上cout<<\"success\",检测有没有调用这个函数）\ninitgraph(width,height,EW_SHOWCONSOLE)\n&emsp;&emsp;第三个参数还可以填入其他值，详见[文档](https://docs.easyx.cn/zh-cn/initgraph)\n\n### cleardevice()\n&emsp;&emsp;使用当前背景色（默认为黑）清空绘图窗口。在显示新画面前一般都要调用这个函数\n### loadimage(&img,_T(\"./image.png\"))\n&emsp;&emsp;将图片加载到img(该变量名可以自定义)这个对象上。至少填入两个值，前一个为easyX的IMAGE类的对象（要传入其地址），后一个在引号内填图片的路径\n&emsp;&emsp;IMAGE类是easyX这个库自带的对象，用于保存图片的各种数据。\n&emsp;&emsp;其成员函数getwidth()/getheight()返回图片的宽/高\n&emsp;&emsp;为了在其他电脑上也能正确找到图片地址，路径应使用相对路径\n\n### putimage(x,y,&img)\n将先前加载的图片绘制到窗口上。参数为**图像的左上角在窗口上对应的坐标**\n\n### easyX的坐标系\n需要注意的是，easyX的坐标系默认是以**向右为正，向下为负，以窗口左上角为原点**。且所有图片的定位都是看其左上角对应的坐标。\n绘制图像时，坐标可以为负数或超出窗口的宽高，这样的话会绘制一半在窗口中，或完全不显示在窗口中。（但该图像依然存在）\n\n## 文件的结构\n和以往的作业不同，这是一个较大的项目。一方面，代码里包含了许多的类，另一方面，在程序本身之外还有图像等资源文件（统称为assets）。如果把所有类写在一个文件，改写的时候就非常难找，因此最好尝试把各个类分文件写\n大致这样👇\n\n```\nspacewar//根目录\n\t├── main.cpp\n\t└── player.cpp\n\t└── enemy.cpp\n\t└── images//文件夹，用于存放所有图像文件\n```\n\n在包含另一文件时，有以下两种方法：\n\n>#include <graphics.h> //用尖括号表示优先查找系统文件\n>#include \"player.cpp\" //用引号表示优先从当前文件夹查找，自己写的文件都最好用这个方法\n\n\n## 游戏的架构\n\n### 外层结构\n要想做一个画面实时变化的游戏，就要像视频一样，以人眼难以分辨的频率去不断绘制画面，因此，程序的最简结构如下：\n```C++\nint main()\n{\n\tinitgraph();//初始化绘图窗口\n\tinit各种东西();\n\t//初始化需要用到的所有变量，包括但不限于玩家飞机，敌人系统，分数，道具系统等等\n\twhile(1)\n\t{\n\t\t//游戏的主循环，每一轮循环都要画出所有元素，一次循环为一帧\n\t}\n}\n```\n### 主循环\n\n虽然每个人做的游戏规则不同，但在主循环中，大致要做如下的事情（执行顺序要视情况调整）：\n* 判断玩家，敌人，子弹间的碰撞\n* 按照一定频率生成敌人，道具等\n* 接收玩家输入的操作，并处理结果\n* 绘制玩家，敌人，子弹，分数等元素，同时处理移动\n* 控制帧率\n\n其中控制帧率最简单的方法是在循环的结尾加Sleep()\n```C++\n\tSleep(time);//需要头文件<windows.h>\n\t//time为毫秒，例如time=33.3时，帧率(FPS)为30，即每秒刷新30次画面\n```\n实际上在sleep()前执行函数的时间也要计算，但飞机大战这个规模还没有什么影响，就忽略不计了\n\n### 接收玩家指令的方式\n\n\"\\_kbhit()\"函数在用户按下按键时返回true，否则返回false\n\"\\_getch()\"函数**等待并返回**用户按下按键的ASCII码\n只使用\\_getch()，程序需要等待用户输入按键，也就会导致玩家不动，敌人也不动的现象。\n这里专门给玩家设置一个执行指令的函数，是为了后续能清楚地分清与玩家相关的指令和不相关的指令。\n\n```C++\n\tif (_kbhit())\n\t{\n\t\tchar cmd = _getch();\n\t\tswitch (cmd)\n\t\t{\n\t\t//调用玩家对象的command函数\n\t\tdefault:Player.command(cmd); break;\n\t\t}\n\t}\n```\n\n### 试着先让自己的飞机动起来\n我自己在写的时候也不是一次性就加入敌人，子弹等等内容，先别想那么多，让飞机在窗口上动起来🎵\n\n```C++\nclass player{\nprivate:\n\tint m_x;\n\tint m_y;\n\tint m_speed;\n\tIMAGE m_img;\npublic:\n\tplayer()\n\t{\n\t\t//载入图片\n\t\tloadimage(&m_img, _T(\"./images/player.png\"));\n\t\t//先随便给个值，但注意不要超出窗口大小！\n\t\tm_x=100;\n\t\tm_y=100;\n\t\tm_speed=10;\n\t}\n\tvoid drawPlayer()\n\t{\n\t\t//绘制玩家的函数\n\t\tputimage(m_x, m_y, &m_img,);\n\t}\n\tvoid command(char cmd)\n\t{\n\t\t//执行玩家指令的函数\n\t\tswitch (cmd)\n\t\t{\n\t\t//根据指令让对应坐标+或-速度\n\t\tcase 'w':m_y-= m_speed; break;\n\t\tcase 'a':m_x-= m_speed; break;\n\t\tcase 's':m_y+= m_speed; break;\n\t\tcase 'd':m_x+= m_speed; break;\n\t\t}\n\t}\n```\n将它放到main函数中：\n```C++\nint main()\n{\n\tinitgraph(500,800);\n\tplayer Player;\n\twhile(1)\n\t{\n\t\tcleardevice();\n\t\tPlayer.drawPlayer();\n\t\tif (_kbhit())\n\t\t{\n\t\t\tchar cmd = _getch();\n\t\t\tswitch (cmd)\n\t\t\t{\n\t\t\tdefault:Player.command(cmd); break;\n\t\t\t}\n\t\t}\n\t\tSleep(50);\n\t}\n}\n```\n\n## 设计类\n\n以我的做法，最少需要4个类：玩家，子弹，敌人，敌群\n其中【玩家，敌人，子弹】都有共通的属性：坐标，速度，宽高，因此可以继承自一个Object类。\n**敌群**这个类的作用，在于管理所有的敌人。因为所有的敌人都需要和玩家判断碰撞，并且在超出屏幕时及时删除\n敌群类(enemies)和敌人类(enemy)不同于继承，叫做组合，是“A有B”的关系。\n\n#### object类\nobject基类很简洁，只需要记录几个必要信息，并做所有物体通用的碰撞检测\n```C++\nclass object {\nprotected:\n\tint m_x;//横坐标\n\tint m_y;//纵坐标\n\tint m_width;//图像宽度\n\tint m_height;//图像高度\n\tint m_speed;//速度\n\tint map_width=550;//窗口宽度(用于判断越界)\n\tint map_height=850;//窗口高度\npublic:\n\t//判断碰撞的函数，使用时传入子类指针就行。不用static其实也可以\n\tstatic bool isHit(object* ptr1,object* blt);\n```\n\n※isHit()详见[第一次游戏制作](https://ustb-lzm.gitee.io/ustb-lzm/2022/03/26/my-firstGame/)\n\n#### 敌人类&敌群类\n敌人最少只要object所继承的属性外加一张图片就可以。\n敌群要控制敌人的生成，\n```C++\nclass enemy:public object {\n\tfriend class enemies;//将权限给敌群类\nprivate:\n\tIMAGE m_img;//用于保存敌机图片的IMAGE对象\n\t…………\n}\n\nclass enemies {\n\tint enemyCount;//记录敌人数量(但我并没用到)\n\tint interval;//敌人产生的间隔\npublic:\n\tenemy* ePtr[30] = { 0 };//敌人类指针数组,上限为30个敌人\n\tvoid createEnemy();//生成敌人\n\tvoid drawEnemies();//绘制所有敌人\n\tvoid deleteEnemies();//删除死亡/超出屏幕的敌人\n\tint isEnemiesHit();//给每个敌人判断碰撞\n\tvoid shoot();//如果敌人可以发射子弹，最好在敌群类统一管理（要和玩家判断碰撞）\n```\n\n### 子弹类\n```C++\nclass bullet:public object {\nprivate:\n\tIMAGE m_bullet;\n\tdouble m_angle;//发射角度\npublic:\n\tvoid drawBullet()\n\t{\n\t\tputimage(m_x, m_y, &m_bullet);\n\t\tm_x += m_speed * sin(m_angle);//所有子弹通用的移动，只需确定方向和速度\n\t\tm_y += m_speed * cos(m_angle);//但要注意x和y为整数，角度太细会丢失精度\n\t}\n\tbool isOut();//判断子弹是否超出屏幕\n```\n\n### 玩家类\n```C++\nclass player:public object {\nprivate:\n\tIMAGE m_img;\n\tbullet* m_blt[50] = { 0 };\npublic:\n\tvoid shoot();//发射子弹\n\tvoid command(char cmd);//接收指令\n\tbool judgeOverflow(char cmd);//移动时判断防止超出屏幕\n\tvoid drawPlayerAndBullet();//绘制玩家和子弹\n}\n```","tags":["大学生活","编程","游戏","C++"],"categories":["游戏制作"]},{"title":"第一次游戏制作","url":"/2022/03/26/my-firstGame/","content":"\n&emsp;&emsp;因学校程序设计课的作业要求，第一次游戏制作献给了飞机大战。一开始还嫌麻烦，但基本框架打好之后就得心应手了，开始添加各种元素，比玩游戏还上头🤩三天能交的作业硬是拖了一周\n&emsp;&emsp;本来还有各种主意想要实现，但再做下去也学不到什么新东西了，就暂且割爱了。\n\n<!--more-->\n\n## 起因\n\n>游戏的编写能用到C++学习过程中的很多知识，数组、函数和面向对象。这个练习是一个开放式的练习，你可以在基本要求的基础上进行任何扩充。\n>游戏编写的基本要求，参看附件。\n>\n>>扩充下游戏1定义的飞机大战游戏的功能：\n>>增加多个界面，初始化界面，说明游戏功能；结束界面，提示用户的得分情况，以及是否开始一个新的游戏；\n>>随着积分的增加，可以考虑增加难度，加快敌机的下落速度，和出现的速度；\n>>功能上做更多的性能处理：例如防止玩家操控飞机飞出边界，击中/碰撞检测的处理\n>>增加按Esc键后游戏暂停的功能\n>>增加图形界面（EasyX,Qt, MFC）以及面向对象的程序设计\n\n>要求：提交完成一定功能或性能扩充后的源代码，以及一个word文档，说明你做的功能完善的目标，设计以及程序实现和测试效果。\n\n虽说是作业，但毕竟是值得纪念的第一作，因此我决定发挥自己目前最大水平做个完整的游戏。\n\n## 游戏下载\n\n※有闲空的可以玩玩看，就是普通的飞机大战。\n（Win10应该能正常运行，Win7没试过）\n\n规则：\n* wasd移动，空格切换子弹类型，q使用道具，esc暂停，道具只能存一个\n* 敌人的血量，频率，移速会随着score增加而增加\n\n>链接：https://pan.baidu.com/s/1iB6d0R82fL6XXXTTvJWdIA \n>提取码：0519\n\n## 游戏制作\n### 绘图库的选择\n&emsp;&emsp;使用的是[EasyX](https://easyx.cn/),在上学期刚入门C++的时候正好用过就沿用了，简单易上手。\n\n### 文件结构\n![image-20220326132332034](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/image-20220326132332034.png)\n图中父子结点表示class的继承关系（右继承左）\n其中（itemSystem--itemBlock),(enemies--enemy)是友元关系\n\n* enemies（敌群）用于初始化敌人的类型，速度等参数，并随着得分情况而改变产生敌人频率。\n* itemSystem作用和enemies相同，控制道具的生成类型和生成频率\n* object父类成员为所有和物体位置相关的变量，以及一个处理碰撞的函数\n* player包含一个bullet指针数组，用于一并管理玩家发出的所有子弹，方便和敌人进行碰撞判断(enemies同理)\n\n### 操作输入结构\n\n这个方法一次只能接收一个指令，无法做到斜方向的丝滑移动。希望在今后的学习中找到改进方案\n```C++\n//判断输入暂停还是玩家操作\nif (_kbhit())\n{\n\tchar cmd = _getch();\n\tswitch (cmd)\n\t{\n\t\tcase 27:systemPause(); break;\n\t\tdefault:p1.command(cmd); break;\n\t}\n}\n```\n\n```C++\n//玩家操作输入（judgeOverflow用于判断玩家是否超出窗口）\nvoid command(char cmd)\n{\n\tswitch (cmd)\n\t{\n\tcase 'w':\n            if (judgeYOverflow(cmd))m_y-= m_speed; break;\n\tcase 'a':\n            if (judgeXOverflow(cmd))m_x-= m_speed; break;\n\tcase 's':\n            if (judgeYOverflow(cmd))m_y+= m_speed; break;\n\tcase 'd':\n            if (judgeXOverflow(cmd))m_x+= m_speed; break;\n\tcase 'q':\n            useItem(); break;\n\tcase ' ':\n            //实现在0~3号子弹发射模式中切换\n            bltType = ((bltType == 3) ? 0 : bltType+1); break;\n\t}\n}\n```\n\n\n### 问题-1 解决运行时闪屏问题\n&emsp;&emsp;在绘制图像过多时，EasyX会出现不定时闪屏问题，为此需要使用批量绘图函数\n详见：https://docs.easyx.cn/zh-cn/BeginBatchDraw\n\n```C++\n\tBeginBatchDraw();\n\twhile(1)\n\t{\n\t\t//各种元素的绘制函数\n\t\tFlushBatchDraw();//将之前绘制的图像一并输出倒窗口上\n\t}\n\tEndBatchDraw();\n```\n\n### 问题-2：对不规则物体判断碰撞\n&emsp;&emsp;常规的判断碰撞就是用两物体的x,y,width,height比较，但由于子弹和飞船形状都不是矩形，使用上述方法会导致判定过于宽松，玩家死都不知道怎么死的🐕。\n\n我的改进方案：\n在常规判断法之外，利用EasyX库中getpixel()扫描子弹即将达到的位置区域内有没有背景色以外的颜色。这样的话就可以把误差减小到子弹的方格(大概3px内)\n\n缺点：\n\n* 因判断条件，背景色不能过多(最终我的背景是双色)。\n* 如果子弹面积过大的话边角误差也较大\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/hitRange.png)\n\n```C++\n\tstatic bool isHit(object* ptr1,object* blt)\n\t{\n\t\tif (ptr1 == 0 || blt == 0)\n\t\t\treturn false;\n\t\tif (ptr1->m_x - blt->m_x > blt->m_width || ptr1->m_x+(ptr1->m_width)<blt->m_x)\n\t\t\treturn false;\n\t\tif (ptr1->m_y - blt->m_y > blt->m_height || ptr1->m_y+(ptr1->m_height)< blt->m_y)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < blt->m_width;i++)\n\t\t{\n\t\t\tfor (int j = 0; j < blt->m_height; j++)\n\t\t\t{\n\t\t\t\tif (getpixel(blt->m_x + i, blt->m_y + j) != BLACK\n                    && getpixel(blt->m_x + i, blt->m_y + j) != 0x000033)\n\t\t\t\t{return true;}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n```\n\n### 问题-3：无法输出透明图片\n&emsp;&emsp;EasyX不支持输出带Alpha通道的png图片，但在游戏进行时会出现很多元素重叠的情况，为了防止图片的黑边挡住下面的图片，需要做透明化处理\n解决方案：利用三元光栅操作，对图片进行位运算\n详见：https://blog.csdn.net/q781634081/article/details/108107639\n```C++\n\t//加载图片\n\tloadimage(&m_img, _T(\"./images/enemy_normal.png\"));\n\tloadimage(&m_alpha, _T(\"./images/enemy__normal_alpha.png\"));\n\t//输出图片\n\tputimage(m_x, m_y, &m_alpha, SRCAND);\n\tputimage(m_x, m_y, &m_img, SRCPAINT);\n```\n\n### 问题-4：窗口大小受系统设置影响，显示不全\n&emsp;&emsp;在打包游戏发给室友测试的时候，发现游戏窗口的大小和预想中的不一样，原因是显示设置中修改了缩放比例。为了在不同缩放比例的电脑上都能正常显示，使用了以下方式。\n\n详见[创建一个不受系统缩放设置（DPI）影响的绘图窗口 - CodeBus](https://codebus.cn/yangw/dpi-awareness)\n\n```C++\n#define WINVER 0x0A00\n#define _WIN32_WINNT 0x0A00\n#include <ShellScalingApi.h>\n#pragma comment(lib, \"Shcore.lib\")\n\nSetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE);  \n```\n\n## 心得\n&emsp;&emsp;生涯第一次制作完整的游戏，还是非常兴奋的。此前一直想学Unity，但作为计算机专业还是要加强底层设计能力。耗时一周，共900多行代码，虽然对我来说算是一次不小的挑战，但跟独立游戏的规模比起来，还是“路漫漫其修远兮，任重而道远。”【By初中物理老师\n&emsp;&emsp;除了代码之外，图像制作也是一大麻烦事，而且技术要求也不低。本次游戏只有爆炸效果有3帧的动画，其他元素都是一图流🏳\n\n","tags":["大学生活","编程","游戏","C++"],"categories":["游戏制作"]},{"title":"unsignedchar的学习","url":"/2022/01/27/my-study-UnsignedChar/","content":"\n实际上是借助容量最小的unsigned char类型学习位运算的应用\n\n<!--more-->\n\n## unsigned char 与 char 的区别\n\nchar的最高位为符号位，而unsigned char无符号位，因此：\n>char：-127~127\n>unsigned char：0~255\n\n## unsigned char 闭环\n当unsigned char取得负数**x**时，其值相当于**(256-|x|)**\n\n例：![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201272027432.png)\n<details>\n<summary>答案</summary>\n<b>10 + 246 = 256, C</b>\n</details>\n\n\n## 将unsigned char作为Flag使用 \n```c++\nunsigned char flags = 0; //共8位,每位表示一个Flag\n//用枚举类型保存至多8个flag\n//（实际情况下每个flag都有具体名称表示）\nenum{\n    Flag1,Flag2,Flag3,Flag4,\n    Flag5,Flag6,Flag7,Flag8,\n};\n//检测某个Flag开闭状态的函数\nbool checkFlag(unsigned char f){\n    //\n    unsigned char t = flags;\n    t >>= f;//相当于t = t/(2^f);\n    t <<= 7;//相当于t*128,如果t为奇数，结果为128，否则为0\n    return (t != 0) ? true : false;\n}\n//开启某个Flag的函数\nvoid setFlag(unsigned char f){\n    flags |= (1 << f);\n}\n//关闭某个Flag的函数\nvoid resetFlag(unsigned char f){\n    flags &= ~(1 << f);\n}\n//验证，输出‘success’\nint main(){\n    setFlag(Flag2);\n    if (checkFlag(Flag2))\n    {\n        cout << \"success\";\n    }\n    else\n        cout << \"failure\";\n}\n\n```\n\n上述代码中，enum型的Flag1~8的值为0~7，为了让它们对应到8bit中的每位，在setFlag()和resetFlag()中要进行位移操作：\n```C++\n1<<f //将1向左移动f位,相当于2^f\n```\n","tags":["编程","C++"],"categories":["程序设计"]},{"title":"程序设计题目——整数分治","url":"/2022/01/15/my-programing-Problem/","content":"\n## 题目\n&emsp;&emsp;程序设计专业课期末考试上的一道题：\n>**输入两个整数n，k，将n划分为k个整数，且每份均不能为0。求共有多少种划分方案**\n>※没有顺序之分，比如对于n=4,k=3,(1,1,2)和(2,1,1)只能算一种方案。\n>输入样例：7 3\n>输出样例：4\n\n当时考试还剩20分钟，本想着绰绰有余，但没带草稿纸而本人又是心算苦手，就直接白给 ~~但最后还是抖机灵把样例输出凑上了~~\n\n<!--more-->\n\n## 思路\n&emsp;&emsp;对于每个数据**n**(n>k)，由于每一份都不能为“0”，所以我们可以首先从**n**中拿出**k**个“1”而不改变结果。假设我要使用 **Func(n,k)** 使其输出答案 **A**，则：\n```\n\tA == Func(n,k) == Func(n-k,k) + S\n```\n&emsp;&emsp;在拿出**k**个“1”后，要注意剩下的 **(n-k)** 是可以分出“0”的，所以在 **Func(n-k,k)** 的基础上还要加一个**S**。\n&emsp;&emsp;而S为：将**n**分成**k**份，且其中有**1~(k-1)** 个“0”。\n&emsp;&emsp;由此推出，对于给定的 **n**和**k**，：\n\n```\n\tS == Func(n,k-1)+Func(n,k-2)+…+Func(n,1)\n```\n将第一条等式中的S替换，就可以得出：\n```\n\tA == Func(n,k) == Func(n-k,k)+…+Func(n-k,1)\n```\n到这一步，递推关系已经出来了，接下来是寻找结束条件。\n* 首先不难想到，**k==1**时，**Func(n,1)==1**\n* 其次考虑当**n==k**时，**Func(n,k)==1**\n* 当**n<k**时，**Func(n,k)==0**\n\n## 代码\n```cpp\nint Func(int n, int k)\n{\n    if (k == 1||n == k)\n        return 1;\n    else if (n < k)\n        return 0;\n    else\n    {\n        int sum = 0;\n        n = n - k;\n        while (k >= 1)\n        {\n            sum += Func(n,k); \n            k--;\n        }\n        return sum;\n    }\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    cout << Func(n,k);\n}\n```\n递归题虽然思考过程很痛苦，但看到写出来的代码如此简介还是很爽👍\n","tags":["大学生活","编程","C++","递归","算法"],"categories":["程序设计"]},{"title":"【翻译】大学生为了制作一部游戏而经历的地狱","url":"/2022/01/14/trans-make-game-bymyself/","content":">原文链接：\n>[大学生が自作ゲームを1本作るまでに経験した数々の地獄のお話](https://note.com/dom_cob1/n/n8eaf211cba2b?magazine_key=mcaf9d5648d65)\n>原作者：\n>[Matsumoto](https://note.com/dom_cob1/)\n\n## 译者摘要\n这篇文章讲述了一位非科班的大学生从学习编程，到最后制作出一款完整的游戏所经历的种种磨难。从他的回忆中，我能感受到作者满溢的创作热情，其中的许多经验，以及最后的话语也给我莫大的鼓励和启发。\n<!--more-->\n\n## 前言\n&emsp;&emsp;初次见面。虽然有些唐突，但各位！\n&emsp;&emsp;一定也有过“人生至少要做一次游戏制作者！”这样的想法吧。\n&emsp;&emsp;这篇文章讲述的就是我，从大二开始学习制作游戏，到实际完成所经历的种种地狱。\n&emsp;&emsp;至于为什么把这件事特意写成文章，在最后会解释。\n&emsp;&emsp;不限于游戏，如果你正想要开始某些事情，请务必看一看。\n\n## 经济学院的地狱\n&emsp;&emsp;常说“如果没有想做的事，就先去大学增加未来的选项”,但我想对高中时的自己说，并不是到了大学就会找到想做的事情。\n&emsp;&emsp;什么都没考虑就选择了经济学。\n&emsp;&emsp;课程对我而言很无聊不说，还因为看不起经济学院那群逼王，没有交到朋友，大概有一年没去学校。\n&emsp;&emsp;在那个时期我开始思考就职的事情，而一看同学的求职方向大多都是银行，证券公司，周围的人就像坏掉的机器人一样一天到晚求职咨询。而且大家比起说是对工作内容感兴趣，嘴上聊的都是年收入和头衔的话题。而我，一边觉得他们扯淡，却也找不到自己想做的事。\n&emsp;&emsp;从这个时候，我开始思考自己真正想做的事情。\n\n## 编程的地狱\n&emsp;&emsp;因为觉得编程就像黑客一样酷炫，我决定学习编程。\n&emsp;&emsp;因为编程的话题根本不好玩，所以我就不展开来谈了，但大约遇到过5次挫折。\n&emsp;&emsp;看不懂写着“猫也能看懂”的书而对猫肃然起敬；搞不来环境配置而扬言自己的电脑不适合编程；去向工学院的教授问“安装”是什么意思被批了一通等等。\n&emsp;&emsp;但我想对接下来要学习编程的所有人说一句话。\n**就算完全不懂也没关系，尝试着自己去使用它**\n&emsp;&emsp;这点非常重要，像考试科目那样“先掌握基础，再去理解整体~”这样的学法对编程是不怎么管用的。\n&emsp;&emsp;还有就是不要去看推特上的大佬。  \n\n经过一段时间后，我就试着用python做了一个2048。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141420300.png' width=60%></span>\n&emsp;&emsp;当看到程序按照自己所想的一样运作时，我从中第一次感受到了游戏制作的乐趣。\n&emsp;&emsp;建议在学编程学完函数和类左右的时候，可以试着自己思考做些程序。\n\n## 从Python转到C++的地狱\n&emsp;&emsp;因为有人说做游戏的话学C更好，我就开始学习C++。\n&emsp;&emsp;了解过的人应该知道，C++和Python完全不同。差不多就像Wii Sports的保龄球和真实的保龄球那种程度不同。\n&emsp;&emsp;开始出现指针，变量声明之类从未接触的术语，而且又败在了环境配置这一步。\n&emsp;&emsp;编程初学者的最大敌人就是环境配置。具体就不展开说了，但如今我更喜欢易阅读的C++。\n\n## Unity的天堂\n&emsp;&emsp;就算是没有做过游戏的人，想必也听说过Unity。简而言之就是能做游戏的工具。\n&emsp;&emsp;第一次接触的时候，得知它能演算重力，判定碰撞等等各种事情，让我非常感动。\n&emsp;&emsp;在Unity中需要用到C#这门语言，但就算没学过也问题不大，在想要实现某种功能时现查就可以了。\n&emsp&emsp;就像先前说过的，“尝试着自己去使用它”。我就在按照书本制作游戏的途中记住了编程的方法。\n&emsp;&emsp;实际看到自己的角色动起来的时候，真的是很有乐趣。\n\n## 实习的地狱\n&emsp;&emsp;就在这个时期，我看机会难得，就参加了游戏公司的实习。\n&emsp;&emsp;因为要进行作品评比，我花了一个月左右，从ddl三天前开始熬夜赶工做出了以下这款游戏。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141437310.png' width=60%></span>\n&emsp;&emsp;游戏机制什么的都比较单薄，而且说实话比看上去还要不好玩，道具按钮也只是个单纯的按钮。\n&emsp;&emsp;但毕竟是独立完成的游戏，就自信满满参加了评比会。\n&emsp;&emsp;轮到我发表的时候，本来还自信满满的，但被问到有趣在哪里，怎么游玩的时候却几乎答不上来。\n&emsp;&emsp;轮到下一个人——“这是日本游戏大奖的获奖作品……”\n&emsp;&emsp;再下一个人——“这是我拿去参加韩国的比赛的作品……”\n&emsp;&emsp;再下一个人——“这是可以在Wii上运行的……”\n&emsp;&emsp;差不多到这个时候我就感觉社死了，心情非常消沉，觉得自己完全不是一个水平。\n&emsp;&emsp;轮到最后一个人——“对不起，看了别人的作品我还是决定不拿出来献丑了……”\n&emsp;&emsp;正当我为找到同伴而稍微安心的时候，评委说就算这样也可以拿出来看一看。确实作为游戏的完成度还不够，但想法非常有创意。很难具体表达，但我感觉像是能火的有趣作品。\n&emsp;&emsp;那天以后，我想着自己又没技术，又没创意，全都玩完了，过了一段暴饮暴食的日子。\n\n## 想不出创意的地狱\n&emsp;&emsp;后来我的精神又恢复了过来，准备再次挑战的时候，却迟迟没法下手。\n&emsp;&emsp;以往我只是把角色动起来就很满意了，但这次开始觉得如果不好玩的话做出来也没有意义。\n&emsp;&emsp;无法忘记在评比会上看到的那些游戏专业学生的作品，或是有足够创意的作品，尤其是那个拿了大奖的作品，我还经常想起来，在油管上反复观看。\n&emsp;&emsp;那个悲惨时期的我就只能跟朋友吹吹“我跟这样的大佬一起参加过实习”。\n&emsp;&emsp;只是，多亏实习的失败经历，我查阅了很多GameJam，游戏奖，独立游戏等等相关的资料，并认识了很多优秀的游戏。\n&emsp;&emsp;然后我想着先不管怎么说要做点东西出来，就把想到的主意逐个做成了demo。\n&emsp;&emsp;以下是我废弃的辣鸡游戏，追悼。\n\n* 边躲避激光边搬运武器的游戏\n* 移动箭头对战的游戏\n* 数字俄罗斯方块（想法还可以就是没能做出来）\n* 把战车和洗车混合的游戏<font color='gray'>(※日文中战车和洗车发音相同)</font>\n* 通过预知能力躲避攻击的游戏\n* 在自动扶梯上逆行的游戏\n* 让电梯恰好停住的游戏\n* 很多隐藏砖块的坑人游戏\n* 不容易被敌人干掉的游戏\n* 血条和蓝条共用的游戏\n* 改变角色大小的游戏\n* 立体停车场（没想好要怎么玩）\n* 屏幕画面之外非常乱的游戏\n* 变成虫子诱导人（已经有了）\n\n&emsp;&emsp;像这样做了很多游戏，虽然大部分都不是很有趣。但是！！最后有两个游戏存活了下来。\n* 关卡会旋转的游戏\n* 和透明的敌人战斗，然后重播后观看自己动作的游戏\n&emsp;&emsp;它们会在后文提到。\n\n## 编程的地狱 Part2\n&emsp;&emsp;既然做不出创意，就用编程能力一决胜负吧！然而，从结果来看就是我的错觉。在技术上取胜是世界第一难事。\n&emsp;&emsp;但总之，不能全部依赖引擎！要自己写出重力和画面！！！这么想着，我买了一本书——《在成为游戏工程师之前应该记住的技术》。\n&emsp;&emsp;真的是地狱。\n&emsp;&emsp;看了书之后我才发现自己至今的编程都只是图一乐。\n&emsp;&emsp;必须在完全理解了指针，继承，二进制等等才能看得进去。\n&emsp;&emsp;现在来看，那个时期学的知识都有很大的帮助，但我也不希望萌新看了这本书而被劝退。\n&emsp;&emsp;不过对于学编程比较轻松的人来说，我还是非常推荐这本书。\n&emsp;&emsp;顺便一提，我因为实在是搞不懂，至少敲了100次桌子，还在阳台大喊“谁tm搞这个”，也因为太过挫败深夜骑自行车去金阁寺，在推特上发过“我真是一无是处”，在麦当劳暴饮暴食吃胖了15kg。\n\n## 自制游戏的地狱\n&emsp;&emsp;好不容易看了书，事实后该不用引擎制作游戏了！这么想着，我完成了“关卡会旋转的游戏”。\n&emsp;&emsp;别看只有“完成了”这么三个字，过程是真的累死累活。当遇到报错的时候，那个波浪线总是划在不是我写的代码的地方（标准库），让我完全不知道哪里出了错。\n&emsp;&emsp;就好像是迷路的时候看一眼手机发现导航显示自己在大海上一样。\n&emsp;&emsp;这样的事情一天至少要发生10次。\n&emsp;&emsp;或许大佬不同，但我的话至少有70%左右的时间花在了寻找出错原因上面。\n&emsp;&emsp;这段时间又因为真的搞不懂而经历了暴饮暴食，去银阁寺的路上迷路，无所事事地改改字体大小等等。\n&emsp;&emsp;结果就完成了这么个游戏。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201141716419.jpg' width=60%></span>\n&emsp;&emsp;图画是朋友帮忙画的，右下角的猫是玩家。\n&emsp;&emsp;虽然我写的都是怎么怎么受挫，但一旦不用引擎完成了自制游戏，那成就感是非同一般的。\n&emsp;&emsp;比如，从菜单到关卡选择的迁移方式都需要自己考虑，还自制了保存制成的关卡名的时候的文本框。\n&emsp;&emsp;一边怀疑自己是不是走偏了，一边又用谁也想不到的方法制作，运行成功的时候，我是发自内心感到兴奋的。\n&emsp;&emsp;我真是天才！！（然后30分钟后因为各种报错而崩溃)\n&emsp;&emsp;可惜最后还是有判定奇怪等种种问题，没能达到发行的质量。\n\n## 虚幻引擎的天国\n&emsp;&emsp;具体时间有些搞不清了，但我偶然看到这个视频，大受感动，开始使用虚幻引擎。\n\n>&emsp;&emsp;[虚幻5技术演示(B站)](https://www.bilibili.com/video/BV1Y5411s7Sa)\n\n&emsp;&emsp;就算现在再看也让我起鸡皮疙瘩，让我觉得“可以亲手创造这样美丽而充满激情的世界吗！”\n&emsp;&emsp;然后我就回想起纯粹制作游戏的感觉，开始学习虚幻引擎。\n&emsp;&emsp;虚幻引擎不需要任何编程就可以做游戏，利用一种叫蓝图的可视化脚本语言，让角色动起来，或是制作机关。顺便一提，我用它制作的游戏也一次都没有写代码。\n&emsp;&emsp;然后我就想，和之前不同，既然用了引擎就一定要做出有趣的游戏，把技术力抛在脑后，一个劲打磨游戏的趣味性。\n&emsp;&emsp;就在这时，我想到了“和透明的敌人战斗，然后重播后观看自己动作的游戏”，因为重播自己的动作很有趣，从而想到制作一款把自己的动作倒放，然后和倒放的自己合作的游戏。\n\n## 自制游戏的地狱 Part2\n&emsp;&emsp;虽然写着地狱，但和先前的游戏制作比起来，这次的经历绝对是最让我快乐的。\n&emsp;&emsp;一方面是自己对这个游戏的有趣程度有自信，一方面是由于引擎而让想法的实现变得简单了。\n&emsp;&emsp;但也有一些比较心累的地方：\n1. 看到推特上的大佬会无法避免地产生自卑感\n2. 存档和包装等为了游戏发行而不得不考虑的事情\n\n&emsp;&emsp;第一点想必对哪个领域都一样。真正厉害的人是真的厉害，不去看他们更好。写Qiita<font color='gray'>(日本一个工程师论坛)</font>的人也都是天才。他们的人生估计已经五周目了，一周目的我就满怀感激地接受教导吧。\n&emsp;&emsp;第二点应该是大多数人受挫的原因。同样是做游戏，随意制作的人和完整地制作一部的人是完全不同的。就像做意大利面也有买酱回来做的人和从酱开始做的人。除了包装之外，我也考虑了美工和建模等等问题。\n&emsp;&emsp;即便如此，这也是真的很快乐的事情。\n&emsp;&emsp;**不用去学会所有的东西**\n&emsp;&emsp;**只要查阅自己创作所需要的就行**\n&emsp;&emsp;**制作自己认为有趣的东西**\n&emsp;&emsp;**想象着自己的游戏大卖然后出名**\n&emsp;&emsp;以上这些应该就是感到快乐的原因。关于游戏的设计，我也看了不少制作人的演讲，游戏分析博主的视频等等，还疯狂拜托别人去试玩。\n\n## 开始怀疑是否有趣的地狱\n&emsp;&emsp;中途开始患上了担心这个游戏实际上没意思的病。不过后来知道这种情况在游戏开发者身上是常有的。\n&emsp;&emsp;当时问了朋友们对试玩版的感想，大家可能是比较善良，都说很好玩。我就坚信他们的话坚持了下来。\n&emsp;&emsp;顺便一提其中有一个朋友因为太过热衷而把大学考试全翘掉了，学科全挂。\n&emsp;&emsp;爱死你了！经济学院！\n\n## 游戏被别人玩的天国\n&emsp;&emsp;历经坎坷，游戏终于在steam上公开了试玩版，推特上的宣传也被转发了3742次！当时太过开心，给试玩的朋友门疯狂打电话。\n<font color='gray'>（※游戏名【Relash】steam上可以看到商店界面，现已停止试玩）</font>\n\n## 想说的话\n&emsp;&emsp;在刚刚接触游戏制作时，我觉得那些爆火的都是天选的人。但实际上到现在，我也依然边抱怨搞不懂边做着游戏。\n&emsp;&emsp;我写这篇文章，就是想让那些今后想要制作游戏的人意识到，“原来大家都会受挫折”，“做出没有意思的作品也是理所当然的”。\n&emsp;&emsp;我在开始制作游戏时，最想知道的，就是**不知道也没关系**。\n&emsp;&emsp;就是因为不知道这点，我好几次都差点放弃制作游戏。\n&emsp;&emsp;我还只是完成了一款游戏，但因为不想被别的开发者认为是在装逼，所以我会马上就说我并不厉害。\n&emsp;&emsp;但这正是在过去让我痛苦的话语。\n&emsp;&emsp;因为那些比我厉害的人，摆着一副这种程度理所应当的表情，所以才会觉得“是我不适合”。\n&emsp;&emsp;正因如此我才要勇敢地说出来，我能制作一款完整的游戏，是一件很厉害的事情，但更多地，是一件非常吃力的事情，充满了未知的事情。\n&emsp;&emsp;所以我才希望今后想要制作游戏的人意识到**不知道也没关系**，以“做出来就很厉害！”的心态去面对。\n&emsp;&emsp;以上就是我制作一款游戏所经历的种种地狱。\n\n## 笔记\n>肩書き(かたがき)：头衔，官衔\n>殆ど(ほとんど)：几乎\n> 垢(あか)：污垢，油泥\n> 遷移(せんい)：变迁，迁移\n> ダントツ：压倒性地出众，领先\n> 語呂合わせ(ごろあわせ)： 双关，谐音\n> 別格(べっかく)：特别处理，特殊待遇\n","tags":["游戏"],"categories":["游戏制作","翻译"]},{"title":"【翻译】古川本铺-聊聊作词的方法","url":"/2022/01/14/trans-hurukawa-lyric/","content":">原文链接：\n>https://sp.uta-net.com/today/news.php?id=12288\n>原作者：\n>古川本铺\n\n## 译者摘要\n古川本铺是我最喜欢的音乐创作者之一，在舒适的旋律之外，他的歌词也总是充满文艺，清新的色彩。本篇文章来自Uta-Net，日本的音乐资讯网站，讲述了古川本人创作歌词的过程。\n<!--more-->\n\n## 正文\n&emsp;&emsp;新年好，我是古川。\n&emsp;&emsp;从去年时隔六年复出，到现在也有一年了。创立个人事务所后打拼至今，还是手忙脚乱的状态。\n&emsp;&emsp;去年11月末，我发行了复出后的第三首曲子[「Ordinaries feat.古川亮」](https://www.bilibili.com/video/BV1X44y1a7f9)。关于歌词，以往我都以让它在乐曲的世界里完结为理想，但大概从这首曲子开始，我逐渐会去思考“如何让歌词和日常生活有所关联”。这首歌在我的作品中也是非常独特新颖的一首，请一定听听看。\n&emsp;&emsp;那么，今天既然是歌词随笔，我就聊一聊我平时作词时的方法和小技巧。\n&emsp;&emsp;作词首先要从确保词曲对应的舒适开始。\n<font color='gray'>※这里原词是**譜割り**，是在歌曲创作中把歌词细分到音符的行为，没找到中文对应的术语，还请谅解</font>\n比如，无论如何都需要4个音符(字)的歌词，却强行填入三个字。\n>⭕おにぎり(饭团，o ni gi ri)\n>❌うどおん(乌冬，原本是 u do n，此处填成：u do o n)\n\n&emsp;&emsp;你可能会吐槽什么鬼歌词，但只是举个例子。这个时候如果一定要用うどん(乌冬)这个词，就必须强行拉长元音以对应音符，但通常在作词过程中我会尽量避免这种情况出现。\n&emsp;&emsp;话虽如此，也不是说从一开始就要考虑这个问题，实际创作过程也没有那么顺利。因此，我的作词过程有一定程度的模式化，并且总是先作曲，再作词。\n1. 先作曲到能进行部分弹唱为止。\n2. 用既不是英文也不是日语的谜之语言弹唱录音。\n3. 挑选出弹唱过程中有意义的单词和句子。\n4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n5. 修改文章，使其能够对应音符。\n6. 尝试用有特色的词句插入或替换。\n7. 加入感叹号、句号等，让歌词更像文章。\n8. 再弹唱，录音，如果没有违和感就OK。\n9. 第二天重新听一遍，然后弃用。\n\n&emsp;&emsp;理想是不达到⑨完成创作，但现实没有这么简单。\n&emsp;&emsp;在上述工序中比较重要的是③。在用比较随便的词句反复哼唱旋律的过程中，总会有那么一两个词跟旋律非常搭配。我把它当成是**歌曲在呼唤的文字**，并从此衍生出整个歌词。所以我通常不会定下主题或对象开始创作。\n\n---\n\n### 1. 先作曲到能进行部分弹唱为止。\n不用说也知道，创作歌词不是写诗，如果最后不成曲调就没有意义。所以首先要确定旋律，到能唱的状态。不过最终可能会优先歌词而改变旋律。\n\n### 2. 用既不是英文也不是日语的谜之语言弹唱录音。\n&emsp;&emsp;这个阶段，我认为用什么语言其实无所谓，最优先的是作为歌词发音的舒适程度。\n&emsp;&emsp;偶尔会有人说英语歌词比较逊，但我想告诉作词者的是，这种意见全部可以无视掉。只是，如果一段歌词能统一语言的话，节奏会更舒适。\n\n### 3. 挑选出弹唱过程中有意义的单词和句子。\n&emsp;&emsp;如果没有做到这点就从1重新开始。实在找不出的话，就弃用。\n\n### 4. 从挑选出的词句衍生出文章，这个阶段先无视旋律。\n&emsp;&emsp;如果在这个阶段考虑音符的对应，我就感觉会变成所谓“平庸的歌词”。这道工序应该是形成世界观的过程，但我并不是很喜欢“世界观”这个用法，所以也不会特别在意这方面的好坏。我比较关注的是曲子的气氛和文章的气氛是否一致。\n\n### 5. 修改文章，使其能够对应音符。\n&emsp;&emsp;这个过程我做的比较机械，主要是检查字数是否吻合音符，有没有强行延长元音，等等。\n\n### 6. 尝试用有特色的词句插入或替换。\n&emsp;&emsp;这是给歌词添加个性的重要环节，因此我在这个部分会花比较多的时间。比如在「Ordinaries」中，既有“溜息を燃やす”这样的表达，也会刻意加入“ブラリと歩いた”这样比较土的词句。如果让听众在读词的时候感到“哦？”，或者“哦！”就是我的胜利。\n\n### 7. 加入感叹号、句号等，让歌词更像文章。\n&emsp;&emsp;这是我个人特色的部分，也是我每次作词必做的环节。加句号是为了确认歌词是否作为文章产生美感，加感叹号是为了表现出歌曲不足以表达完整的那部分情感。\n&emsp;&emsp;可能也有人认为只用音乐表现就可以了，但在我心中，歌词有歌词，乐曲有乐曲的表现领域，而这两者不一定需要完全一致，也可以从不同的角度表达出深意。\n\n### 8. 再弹唱，录音，如果没有违和感就OK。\n&emsp;&emsp;本来在这一步还会制作**歌词卡**，但因为只是个人兴趣所以不展开谈了。只是检查一下歌词作为文章排版之后是否够帅。至于有什么好坏标准，我自己也不是很清楚。\n\n### 9. 第二天重新听一遍，然后弃用。\n&emsp;&emsp;80%的作品都是这个结局。我会努力不走到这一步。\n\n---\n\n&emsp;&emsp;古川的歌词就是通过上述的方法创作的。要点在于，不是先**决定想要表现的内容**，而是**给想要表现的事物创造轮廓**。\n&emsp;&emsp;在此之后，我会一边思考它究竟适合表现什么事物，一边进行修正，添加。\n&emsp;&emsp;这次，在11月发行的曲子「Ordinaries」表现的是“日常”。并不是像“平凡的日常也非常美丽”这样含蓄的话题，而是说**“今天是普通的，普通的一天”**，仅此而已的曲子。很难说它是美丽或者无趣，但看来至少不是糟糕的一天。我希望这首曲子能为这样的日子增添一抹光亮。\n\n## 笔记\n>段取り：计划，方法\n>手合い(てあい)：小子，家伙/对局/种类\n>お蔵(おくら)：电影戏剧等停止公映，或事物不再使用\n>省く(はぶく)：省略，减去\n","tags":["音乐","古川本铺"],"categories":["翻译"]},{"title":"【翻译】拓宽版面设计的视角","url":"/2022/01/13/trans-LayoutDesign/","content":"\n>原文链接：\n>[レイアウトデザインの視点を増やす 思考＆Tips](https://note.com/harahiroshi/n/n3af079dc17e9)\n>原作者：\n>[ハラヒロシ](https://note.com/harahiroshi/)\n\n## 译者摘要\n本文面向入门设计者，用了图例和很多比喻，生动形象地介绍了布局排版，留白处理的技巧。\n在上一篇文章中，我把“情報”照搬成情报，而后认为翻译成信息更合适，因此在这篇文章中全部采用了后者。\n\n<!--more-->\n\n## 形似水流\n&emsp;&emsp;在布局的时候，通常先决定信息的优先级，再用板块面积区分主次。光到这一步，还只是单纯地堆在一起，而没有流动感。为了让视线能平滑地浏览内容，在创造留白的时候可以想象河流的感觉。\n![picture_pc_519942b46e253091dc646bfcf05c209d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131539348.jpg)\n\n<details>\n<summary>原文</summary>\n<b>川の流れのように</b>\n<p>レイアウトするにあたっては、情報の優先順位を決めてそれをボリュームで割り当てるのが基本です。ただし、これだけだと単に積み重ねているだけで流れが悪いので、視線が滑らかに移動するように“川の流れ”を意識して余白を作っていきます。流れが明確であれば、左右入れ替えてもOKです。\n</details>\n\n## 画面要有纵深感\n&emsp;&emsp;网页虽然只是一个平面，但也和实景一样，人们通常会先识别最吸引眼球的地方，再按顺序获取信息。作为设计者，必须有意识地利用这点去调整画面的纵深。\n&emsp;&emsp;在下面的例子中，文字标题和橙色的方块是最抢眼的，然后再是绿色区域，蓝色区域。所以并不是说全都从上往下排列就ok了。\n&emsp;&emsp;刚上手的时候，思路可能容易局限于单纯地将元素上下堆积。内容之间的关联，视线的动向，下一步的响应都考虑到的同时，从纵深，左右，时间等多重角度审视设计，就可以拓宽思路。\n![picture_pc_d2eb1880b7c33ee76cd1ffeb82a2e56a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131603983.jpg)\n\n<details>\n<summary>原文</summary>\n<b>画面には「奥行き」がある</b>\n<p>webは画面という「平面」に対してだいたい同じ距離感で見るものですが、実は景色と同じで、誘目性の高いものから認識し、順を追って情報を得ていきます。つまりそこには「奥行き」があります。\n<br>作り手としてはそれを意識し、利用しながら、画面から離れたり近づいたりしながらデザインを調整していくことが大事です。\n<p>以下の例では、文字とともにその下のオレンジ色が誘目性が高く、次に緑、青と順を追って認識していきます。決して「上から順に」配置していけばいいというわけではありませんね。\n<p>最初のうちは上下にブロックを積みあげていくだけの思考に留まってしまう場合が多いです。コンテンツの関係性や視線の流れ、次へのアクションなどをしっかりおさえつつ、奥行き、左右、時間…という複数の重なりの視点を持つとそこから抜け出せると思います。\n</details>\n\n## “通风透气”\n&emsp;&emsp;留白可以诱导视线，让用户注意力转向设计者期望的内容。在布局的时候，不是将元素填入空间，而是通过制作留白让画面“通风透气”。要点在于，制造一条通道，让气流能刚好触碰到重要的信息。\n以下的例子中，如果用户的视线跟着留白走，就能自然地注意到文字内容。\n![picture_pc_0adf0b12355d3a0c60b166110560dc00](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131611974.jpg)\n&emsp;&emsp;要想验证是否做到有效的视线诱导，可以试着在自己的设计上画箭头，如果画箭头的时候感到犹豫，就可以说没有起到很好的诱导效果。\n![picture_pc_df8185ba06f7e71cc1de7c63a66954f5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131613870.jpg)\n\n<details>\n<summary>原文</summary>\n<b>空気の流れを良くする</b>\n<p>「余白」は視線誘導し、意図した情報に注目させることに利用できます。レイアウトするとき、要素をスペースに埋めようとするのではなく、余白を作って「風通しよく」してあげます。ポイントは、逃げ道をつくり、重要な情報を空気の流れに触れさせてあげること。余白がなく、息が詰まるな、と思ったら空気の流れがしっかり通っているかチェックするとよいでしょう。\n<p>以下は、余白を追っていくとコピーが自然と視界に入ってくるレイアウト例です。\n<p>なお、ちゃんと視線誘導できているかは、自分のデザインに矢印を描きこんでみるとよいです。矢印に迷いがあれば、誘導が上手くいっていないといえます。\n</details>\n\n## 从树干衍生出枝叶\n&emsp;&emsp;就拿刚才的素材，这次将关注点从留白转向构图。在布局的时候，要决定一条轴线。扎实的轴线可以增强可读性，也可以在引入变化时不让整体垮掉\n![picture_pc_9a28de0112cc45b698575e7f97b26591](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131655643.jpg)\n&emsp;&emsp;要点在于把轴线当成树干，像衍生出旁支一样布局。（轴线可以不在画面中心)在枝叶上可以自由变换。\n\n<details>\n<summary>原文</summary>\n<b>「木の幹」を意識して枝を作っていく</b>\n<p>では同じ素材で、今度は「余白」ではなく「図」に目を向けてみましょう。レイアウトするとき「軸」を決めます。軸がしっかりしていると読みやすいし、崩しを入れても破綻しにくいのです。\n<p>ポイントは「木の幹」を意識して枝を作っていくことです（軸は真ん中でなくてもよいです）。枝で変化つけると自由さが広がります。\n</details>\n\n## 重心意识\n&emsp;&emsp;进行有动向的布局时，需要有重心意识。以对角线作为辅助线就一目了然。通过调整元素的大小和位置，让重心不偏向画面的一边，就可以平衡地布局。\n![picture_pc_e7811a7a4d67d790ecc87bd05be51a17](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131702816.jpg)\n\n<details>\n<summary>原文</summary>\n<b>重心を意識する</b>\n<p>上下・左右に要素を散らすなど、動きのあるレイアウトを行うときは「重心」を意識することが重要です。その際、対角線などの補助線を描くとわかりやすいです。重心がどちらかに傾かないようにオブジェクトのサイズと位置を調整するとバランスよく配置できます。\n</details>\n\n## 布局要整齐划一\n&emsp;&emsp;**对齐**是设计的四大原则之一，但通常在设计中会要引入**变化**和**强调**，以吸引用户的注意力。但这个变化必须建立在保持协调之上，设计者应该牢记先整齐布局后再加入变化。\n![picture_pc_0a13a8c3767ee3bf1db201fc5603def5](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131731290.jpg)\n\n<details>\n<summary>原文</summary>\n<b>レイアウトは整理整頓</b>\n<p>デザイン四原則には「整列」がありますが、それだけだと注意を引きつけられない場合があるので「変化」「強調」という引っかかりをつける必要があります。ただし、その変化は、あくまでも調和を守ったうえでのことです。調和の中でしか変化は成り立ちません。まずはしっかりと整理整頓したうえで、変化をつけるように心がけたいものです。\n</details>\n\n## 检验分组好坏的技巧\n&emsp;&emsp;当担心分组恰当与否时，可以采取模糊全图，看看期望的分组是否形成一个整体。\n![picture_pc_0eda9846d1b9f6bf79685cbe5c0a625d](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131745255.png)\n\n<details>\n<summary>原文</summary>\n<b>グルーピングを確認するためのTips</b>\n<p>整列に関連して。グルーピングがうまくいっているか迷ったときは、全体をぼかしてみて、意図したグループが塊として見えるかどうかを試してみるとよいです。\n</details>\n\n## 从正反两面观察\n&emsp;&emsp;对于难以制造留白的场合，试着调换留白和信息所占的区域。通过这个方法，可以更清楚地捕捉留白的形状，从而判断留白究竟是杂乱的还是协调的。要点在于能否同时从正反两种视角去调整。\n\n![picture_pc_ea7c171d1905b0e31e46373735059369](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131813323.jpg)\n\n<details>\n<summary>原文</summary>\n<b>ポジとネガで見てみる</b>\n<p>余白つくるのが苦手な場合は、ポジとネガの視点切り替えを意識するとよいです。ネガ（余白）の形をしっかり捉えてみると、ネガとの対比でポジ（図）が見えていることや、余白がバラバラになっていることなどに気づけます。ポジとネガ、両方見てコントロールできるかがポイントです。\n</details>\n\n## 地平线的位置\n&emsp;&emsp;有时在叠加背景和图像时会拉一条地平线，而地平线的位置也会改变整体的印象。\n![picture_pc_d9b0d3264d28589dabe43c913a7186d4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131818593.png)\n左：图像与背景重叠部分较多，体现安定感，一体感。\n中：地平线在图像下方，使图像突出，更有动感。\n右：让背景渐变，加强纵深感。\n\n<details>\n<summary>原文</summary>\n<b>地平線をどこに引くか</b>\n<p>図と背景を重ねるときの「地平線」を引くことがあると思いますが、その地平線の位置で随分印象は変わります。安定させるか、動きを感じさせたいか、なじませたいか、など。相手の視点を決める重要なポイントです。\n<p>上のほう：図と背景の重なりが多い分、安定感、一体感があります\n<br>下のほう：逆に関わりが薄くなる分、不安定となり動きを感じます\n<br>グラデーションを引くと馴染んで、奥行きを感じさせるレイアウトになります。\n</details>\n\n## 点，线，面\n&emsp;&emsp;在需要体现出叙事性，或强弱区分的时候，可以将分散的点排布到轨迹上，构造动作或流向。\n\n![picture_pc_dccfb3714b3f0665908d90c378196831](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132002194.png)\n\n<details>\n<summary>原文</summary>\n<b>点、線、面に展開していく</b>\n<p>ストーリー性を出したい場合や強弱を意識する際に、バラバラの点を軌跡に並べて動きや流れを作り、ひとつひとつの大小つけて大きなものは面にし、変化や奥行きを出します。webの場合、手前と奥、上下、左右の流れをうまく活用したいですね。\n</details>\n\n## 俯瞰全体\n&emsp;&emsp;网页通常在纵向较长，但同一时刻只有一部分会展示在显示屏上。为了保障用户在滚动网页的过程中的观感，需要俯瞰网页整体的设计。\n&emsp;&emsp;这是我自己过去做的案例，有意识地连成一体的设计比较多。交互，交叉，重叠，突出，反复，等等，要考虑怎样让网页能够有序，有节奏地连续呈现。\n![picture_pc_75e7292ef3e7335a5a7dee406a5e1d9b](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201132009352.jpg)\n\n<details>\n<summary>原文</summary>\n<b>俯瞰してみて、リズムがあるかどうかを確認する</b>\n<p>Webサイトは縦に長くても、視界に入るのは画面の面積のごく一部。しかし、スクロールしていく中で心地よく見せられるかどうか、それには俯瞰の視点も必要です。デザイン全体をみたときに美しくレイアウトされているかはチェックしたほうがいいでしょう。\n<p>自身の過去案件の事例ですが、「ひとつながり」を意識することが多いです。交互、交差、重なり、押し出し、繰り返し…など。ページ全体を見たときに、どうやってリズムよく、秩序を保ちながら連続的に見せるかを考えます。\n</details>\n\n## 结语\n&emsp;&emsp;通过效仿设计原则，就可以做出表面上优美的设计，但是如果没有属于自己的美的标准，就很难对其认定。像上文提到的一样，拓宽视角去审视设计，我认为也对启发自身美的标准有所帮助。\n&emsp;&emsp;多设计，多欣赏，在积累经验的途中就会逐渐对美的基准有手感。如果能在绘制一个单纯的矩形时感受到美，那就最好不过了。\n\n<details>\n<summary>原文</summary>\n<b>さいごに</b>\n<p>「デザインの原則」で語られる「美しさ」は真似すれば表面上は会得できるますが、やはり自分の中に「美しさ」の基準がないとなかなか定着しないと思います。その基準は、この記事でまとめたような「見方」にヒントがあるでしょう。\n<p>たくさんデザインして、いいものを見て、経験を積むことで「これが基準」の手応えを感じられるようになるはずです。ただ一つの矩形を描く手の感覚の中に「美しい」を感じられたら最高だな、と思うのです。\n</details>\n\n## 笔记\n\n>* 奥行き(おくゆき)：纵深，进深\n>* 木の幹(きのみき)：树木的茎\n>* 破綻(はたん)：失败，破裂，破产\n>* 際立つ(きわだつ)：显著，突出\n\n","tags":["设计"],"categories":["翻译"]},{"title":"【翻译】设计留白","url":"/2022/01/12/trans-WhiteSpaceDesign/","content":">原文链接：\n>https://note.com/toffy_bon/n/na73bb66846a2#OJ1BV\n>https://note.com/toffy_bon/n/n38475f161c31\n>原作者：\n>[assassin@Web屋](https://note.com/toffy_bon/)\n\n## 译者摘要\n本文面向入门设计者，简明扼要地介绍了留白的概念，作用，和部分应用场景。\n<!--more-->\n\n## 何为留白\n\n&emsp;&emsp;“留白”顾名思义就是空白的空间，英文又称WhiteSpace或NegativeSpace。乍一看可能会觉得它起不到任何作用，但留白绝不等同于多余的空间。留白是在设计中非常重要的元素，通过让其起到应有的作用，可以提高设计档次，改善用户体验。\n\n<details>\n<summary>原文</summary>\n<b>「余白」とはなにか。</b>\n<p>「余白」とは文字通り「空白のスペース」のことで、ホワイト・スペースやネガティブ・スペースとも呼ばれたりします。\n一見すると、何の役割も成さないものと捉えがちですが、「余白」＝「余分な空間」では決してありません。「余白」はデザインにおいて重要な要素であり、しっかり意味や役割を持たせてあげることで、デザインをグッと良くしてくれたり、UXの向上に一役買ってくれたりします。\n</details>\n\n## 设计师的一项重要任务\n&emsp;&emsp;“不让用户感到压力的设计” 是设计师的任务之一，而用户主要的压力因素如下：\n* 难以阅读\n* 难以理解\n* 看着会感到疲劳，烦乱\n* 难以找到想要的情报\n* 难以使用\n……etc.  \n&emsp;&emsp;除此之外，根据实际情况会有各种各样的因素，但通过适当地引入留白，可以有效缓和，甚至消解上述压力。\n\n<details>\n<summary>原文</summary>\n<b>デザイナーにとっての重要なミッション</b>\n<p>この大きなテーマの一つとして、「ユーザーにストレスを感じさせないデザインをすること」が挙げられると思います。<p>考えられるユーザーの主なストレス要因は以下の通りです。\n<br>・読みづらい\n<br>・分かりづらい\n<br>・見ていると疲れる（ざわざわする）\n<br>・目的の情報がなかなか見つからない\n<br>・使いづらい<br>…などなど。\n<p>他にもシチュエーションによって様々な要因があると思いますが、余白を上手くデザインに取り入れることで、これらのストレス要因を解消してくれたり、緩和する力を持っています。\n</details>\n\n## 留白的效果和职责\n留白的主要效果和职责大致分为五项。\n* 缓和情报间的干涉\n* 对情报进行分组\n* 层次体现\n* 诱导视线\n* 给用户留下特定的印象  \n\n<details>\n<summary>原文</summary>\n<b>「余白」の効果と役割</b>\n<p>先ず肝心なのは、余白の効果と役割について理解しておくことです。\n<p>余白の主な効果と役割は、大きく分けて5つあります。\n<br>・情報の干渉緩和\n<br>・情報の区分け（グルーピング）\n<br>・階層表現\n<br>・視線誘導\n<br>・印象操作\n</details>\n\n### 1.缓和情报间的干涉\n&emsp;&emsp;可以加强文字情报的可读性，或刻意孤立重要情报，起到强调作用。![picture_pc_8c188bf741c0f521a474f4a26635e9fc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130801361.png)\n&emsp;&emsp;图中举了两个例子。  \n&emsp;&emsp;图右通过在区块内添加适度的留白，消除了**拥挤感**，给人清爽的印象。\n![picture_pc_4d8f6abb7f3bb979c737d4cf462f167a](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130808625.png)\n&emsp;&emsp;除此之外，行间距也是留白的一种，尤其在文字情报中需要注意。\n&emsp;&emsp;通常行间距是字体大小的1.5~1.6倍，但近年来也有网站采用2倍左右的宽松行距。虽然相同范围内的情报量减少了，但行距的宽松也给整体设计带来了宽裕舒适感。\n\n<details>\n<summary>原文</summary>\n<b>１．情報の干渉緩和</b>\n<p>コンテンツ内の文字情報を読みやすく（可読性向上）したり、または重要な情報をあえて孤立させて強調させたりすることが出来ます。\n<p>上に例を２つ挙げました。\n<br>どちらが「見やすい」と感じるでしょうか。\n<br>右下はブロック内に適度な余白が設けられていることで、「窮<br>屈さ」が無くなり、スッキリした印象になっていると思います。\n<p>また、「行間」も「余白」の一つです。\n<br>文字情報は特に注意が必要で、一般的な行間はフォントサイズの1.5～1.6倍程度と言われていますが、近年では、2倍程度までゆったり行間を取っているサイトも多く見かけます。同範囲内の情報量は減ってしまいますが、行間にゆとりを持たせると、デザインにも「ゆとり」が生まれるのです。\n</details>\n\n### 对情报进行分组\n&emsp;&emsp;通过适度的间隔，可以明确情报间的从属关系。\n![picture_pc_065874a10a1b4d75dc032103685d99e2](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130823526.png)\n&emsp;&emsp;乍一看左右两图都有整齐的感觉，但实际在读取情报的时候，图左的标题和文章内容的位置区分显得有些模糊。相比之下，图右中标题与文章内容就一目了然。\n\n<details>\n<summary>原文</summary>\n<b>２．情報の区分け（グルーピング）</b>\n<p>間隔を適度に取ることで、情報がどこに属するのか明確にしてくれます。\n<p>上の例を見比べてみてください。\n<p>一見すると、どちらも整っているように感じるかも知れませんが、情報を読み取ろうとしたとき、左上はタイトルと文章の位置付けが曖昧だと感じないでしょうか。対して右下は、どれがタイトルでどれがタイトルに属する文章なのかが、すぐに把握できるのではないかと思います。\n</details>\n\n### 层次体现\n&emsp;&emsp;当情报之间有嵌套关系，通过使用缩进可以清楚地表现层次。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130831718.png'></span>\n&emsp;&emsp;需要注意的是，使用缩进的时候不能半半拉拉。至少要缩进一个字距左右，让人一眼就能看出的程度，否则用户在阅读的时候反而会产生没有对齐的不适感。\n\n<details>\n<summary>原文</summary>\n<b>３．階層表現</b>\n<p>情報が入れ子になっているものは、インデントを使うことで階層を分かりやすく表現してくれます。\n<p>良く見かける例がこれですね。\n<p>この階層表現を使うことで、情報整理にもなります。\n<br>ただ、インデントで余白を取る時は、中途半端は禁物です。最低一文字分くらい、パッと見で分かる程度の余白を持たせておかないと、ユーザーが見たとき、逆に「ズレている？」と見られ兼ねませんので、ご注意を。\n</details>\n\n### 诱导视线\n&emsp;&emsp;通过在纵向采取更多的留白，可以起到诱导视线的作用。\n<span align='center'><img src='https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130840369.png'></span>\n&emsp;&emsp;大多数人在看到上图时，视线应该是从左向右，Z型移动。\n&emsp;&emsp;如果图片间的留白没有规律，用户的视线就会犹疑。在某些随机展览的网站中可能不限于此，但如果希望用户按照顺序阅读，这个手法就显得尤为重要。\n\n<details>\n<summary>原文</summary>\n<b>４．視線誘導</b>\n<p>「前へ」「次へ」「下へ」「上へ」や、横より縦の余白を多く取ることも視線誘導の一つです。\n<p>上のような画面を見たとき、視線はどのように動くでしょうか。\n<br>恐らく多くは左から右へ、Z型に移動していくものと思います。\nこの余白の取り方がバラバラだと、視線は迷い、自由に画面を見ようとします。ランダムなギャラリーサイトのような例においてはこの限りではありませんが、一般的にはユーザーに順序正しく見せたいのであれば、この手法は鉄則と言えると思います。\n</details>\n\n### 给用户留下特定的印象\n&emsp;&emsp;使用留白，可以制造高级感，宁静感，实惠感，繁华感等印象。\n![picture_pc_4a8c8e615e7acd8dc1aa5d57d4a0b4f8](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130853272.png)\n&emsp;&emsp;为画像准备的空间也是留白的一种。\n&emsp;&emsp;使用较多留白，可以体现高级感，宁静感，清爽感。而采取较少的留白可以体现紧迫感或实惠感。\n因此，有关酒店或奢华商品，会多采取留白，而促销广告，或网络商场等需要成列大量商品时，会使用较窄的留白。\n\n<details>\n<summary>原文</summary>\n<b>５．印象操作</b>\n<p>余白を上手に扱うことで、「高級感」「静けさ」「お得感」「賑やかさ」などの印象を持たせてくれます。\n<p>上に挙げたサイトは一例です。\n<br>ちなみに、画像に設ける空間も「余白」です。\n<br>余白を多く取っているものは、「高級感」や「清潔感」「静けさ」などが演出できます。逆に取らずにレイアウトすると「緊迫感」や「お得感」「賑やかさ」などが演出できます。\nなので、ホテルやラグジュアリーな商材を取り扱う場合は余白を多く取り、特売の広告媒体やインターネットモールなど多くの商品を取り扱う場合は、余白を狭くレイアウトすることで有効な訴求ができるかも知れません。\n</details>\n\n## 应用留白\n&emsp;&emsp;在设计之前，**充分理解内容**显得尤为重要。面向的用户群体，产品的种类，情报说明的对象等等，都应把握到位。  \n\n<details>\n<summary>原文</summary>\n<b>余白を上手に扱うコツ</b>\n<p>まずはじめにデザインを行う前提として、「コンテンツを十分に理解すること」がとても重要になります。どんなユーザーに向けた、どんなクリエイティブ（制作物）なのか、この情報はどれに対する説明なのか…など、内容をしっかり把握しておきましょう。\n<p>「土台」が理解できていなければ、良いものは生まれません。\n</details>\n\n### 1.了解适合的留白量\n\n&emsp;&emsp;如同前面提到的一样，留白有着制造印象的作用。虽然具体情况要具体分析，但基本可以按照以下思路进行\n![picture_pc_eaaab23be1d54ebaf1a80a1112b8b275](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130926768.png)\n<font color='gray'>从左到右分别是：电商·情报网站；博客，画廊；企业网站；品牌网站</font>\n\n&emsp;&emsp;需要注意的是情报量。情报量和留白量基本呈反比例，例如电子商务平台（淘宝，京东等）需要一次性展示大量商品，如果采取大量留白，会导致商品界面的页数大涨，用户也难以找到心怡的产品，影响销售额。\n&emsp;&emsp;而品牌网站需要将少量商品的魅力完整地展现出来，如果采用较少留白，虽然能一次性展示更多的情报，但难以给用户留下深刻的印象。\n\n<details>\n<summary>原文</summary>\n<b>ポイント１：適切な余白量の目安を知る</b>\n<p>余白にクリエイティブの印象を左右する効果があるのは、前半でもお話した通りです。そのものの背景によって断言できない部分もありますが、基本的には以下のような考え方で分類できます。\n<p>チェックすべきポイントは「情報量」です。\n<br>情報量と余白の割合は反比例しており、情報が多いほど余白は小さく、情報が少ないほど余白を大きく取るのが効果的と言われています。\n<p>たとえばウェブサイトを例に挙げるとすると、膨大な商品数を扱うECサイトと、高級ブランドの公式サイトを見比べるとどうでしょうか？\n<p>全く余白の取り方が違っていると思います。\n<p>想像してみてください。\n<p>もし、これが真逆の状態になったら、どのようになるでしょう。\n<p>ECサイトの場合は、余白が大きくなることで一度に閲覧できる商品数が減ってしまい、そのぶんサイト全体のページ数も更に膨れ上がり、ユーザーが目的の商品を見付けにくくなったりと、売上げにも影響を及ぼしかねません。\n<p>ブランディングサイトなどの場合は、余白が小さくなることで一度に閲覧できる情報量は増えますが、本来伝えたいイメージがユーザー側に伝わりにくくなったり、商品の魅力が損なわれることすらあるのです。\n</details>\n\n### 2.对各部分的留白设定规则\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130945808.png)\n&emsp;&emsp;上图中，将相同规则的留白用相同颜色做了标记。  \n&emsp;&emsp;像这样，对同属性的元素制定统一的规则，不光美观，还能让用户产生安心感。\n![picture_pc_d6184179795c17511a43c77501254abb](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951631.png)\n&emsp;&emsp;反过来，就算只相差几个像素，或者只有一处的留白不同，也会很明显地让用户感到混乱，违和。\n![picture_pc_4742ef42919cc939f6c8d1cb5b91f437](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201130951323.png)\n&emsp;&emsp;通过调整其中的规则，也可以像前面提到的一样发挥视线诱导的效果，使内容之间产生阅读顺序。\n\n<details>\n<summary>原文</summary>\n<b>ポイント２：セグメント内の余白にルールを設ける</b>\n<p>上の図は、同じルールで配置された余白を色分けしたものです。（テキストが英文のため、左右の余白が違って見えてしまっていますが…；）\n<p>分かりやすく少し大袈裟な例を挙げてみましたが、たとえこれが数pxの違いだったり、1箇所だけ余白の取り方が違っているだけでも、ユーザーを混乱させてしまったり、意外に違和感を覚えるものです。見た目にもまとまりがないだけでなく、見ている側のストレス要因にもなります。\n<br>このルールを調整すると、前半でもお話した通り、視線誘導の効果が発揮され、コンテンツの見方に順序が生まれるわけです。\n<p>数px単位でも印象は微妙に変わって来ますので、デザインを俯瞰で眺めてみると気付くことが多いと思います。\n</details>\n\n### 3.片段中的留白要有层次\n![picture_pc_34a3312d606bb370ce271a0718043980](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131001801.png)\n\n&emsp;&emsp;通过使内侧的留白比外侧的留白小，整体布局会显得更加清楚。就像俄罗斯套娃一样，把一个内容块想象成一个盒子。如果里盒的留白和外盒一样，或更多，就会丧失平衡感。\n\n<details>\n<summary>原文</summary>\n<b>ポイント３：セグメント内の余白は入れ子にする</b>\n<p>基本的に、内側は外側の余白より小さくすることで、全体的にまとまりが出てスッキリしたレイアウトになります。マトリョーシカのような要領で、各コンテンツブロックを１つの箱として考えてみましょう。\n<br>内ブロックの余白が外ブロックと同じ、または外ブロックより大きかったりすると、アンバランスで、見ている側は何だか落ち着かない（ざわざわした）気持ちになるものです。\n</details>\n\n### 思考内容和留白之间的关系\n![picture_pc_cd1383153dd33cf247bbcd55fbd04da4](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131007174.png)\n\n&emsp;&emsp;左右两边的内容完全相同，但第一眼看过去，通常图左会把“Sweets”看作图片的标题，而图右会把它看作文章的标题。\n&emsp;&emsp;元素之间距离越近，越能体现从属关系。因此如果希望“Sweets”和图片分为一组，就让它们之间的间距减小，而与下方文章的间距增大就行，反之亦然。在上图中，无论采取哪种都可，但根据具体内容，有些情况下其中一种会是更优解。\n\n![picture_pc_534608440f345b0583c71615176e28dc](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201131021666.png)\n<font color='gray'>标题是“多彩的甜点”</font>\n\n在改变标题内容后，图左的布局就更合适了。因为图像和“多彩的甜点”搭配更自然，而与文章内容的关联不大。\n\n<details>\n<summary>原文</summary>\n<b>ポイント4：内容と余白の関係を意識する</b>\n<p>上の２つをパッと見たとき、どのように読み取ったでしょうか。\nどちらも内容は同じですが、左は「Sweets」が画像のタイトル、右は<br>文章のタイトルに見えたのではないかと思います。\n<p>これは前半でお話した「情報の区分け（グルーピング）」効果に属しますが、違いは余白の取り方にあります。距離が近い方に属しているように見えるので、画像とセットで見せたければ、画像間の余白を小さくし文章との余白を大きく、文章とセットで見せたければ、逆にするだけで良いのです。\n<br>なので、内容によって「余白のあり方」は変わってきます。\n<p>さて、テキスト情報を変更してみました。\n<br>どちらの余白の取り方が適切だと思いますか？\n<br>答えは左です。この場合「カラフルなスイーツ」の文言は、画像に所属させる方が自然です。文章寄りにしてしまうと、本文内容と噛み合わずチグハグな印象を与えてしまいます。\n</details>\n\n## 总结\n&emsp;&emsp;设计的基础遵循[格式塔组织原则](https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%A1%94%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99/10544754)。\n\n&emsp;&emsp;设计没有正确答案，正因为如此，设计师自身在制作中要有明确的意向。当被问到“为什么这么设计”时，如果能明确地说出理由，就能提高产品设计的说服力。留白的应用很难一概而论，但如果你之前没有过多留意，不妨根据上面的介绍实践一下。\n\n<details>\n<summary>原文</summary>\n<b>まとめ</b>\n<p>いかがでしたか。\n<br>デザインのイロハはゲシュタルトの法則に基づいています。\n<p>デザインに正解はありません。だからこそ、デザイナー自身がしっかりとした意向を持って制作に取り組むことが重要です。「なぜこうしたの？」と聞かれたら、明確に理由を説明できるとクリエイティブの説得力も増します。余白の取り方はデザインによって変わりますので一概には言えませんが、「今まで特に意識したことなかった」という方は、前半と後半でご紹介したポイントを念頭において、ぜひ実践してみてください。\n</details>\n\n## 笔记\n>* 一役買う(ひとやく かう)：主动承担任务，主动帮助\n>* 挙げる(あげる)：逮捕/举行/**举例**/扬名/尽力\n>* ゆとり：宽裕，余地\n>* 入れ子(いれこ)：套盒，套匣\n>* 賑やか(にぎやか)：热闹，繁华\n>* 設ける(もうける)：准备，设立\n>* ラグジュアリー(luxury)：奢华的，豪华的\n>* 商材(しょうざい)：商品\n>* ECサイト(electronic commerce)：电子商务平台\n>* コーポレートサイト(corporate website)：企业网站\n>* ブランディングサイト(branding website)：品牌网站\n>* セグメント(segment)：切片，部分，程序段\n>* ちぐはぐ：不配对，不协调，龃龉\n>* 基づく(もとづく)：根据，按照\n\n","tags":["设计"],"categories":["翻译"]},{"title":"网站图标","url":"/2022/01/12/my-AvatarIcon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121316093.png\" width=40%>\n</span>\n<!--more-->\n\n\n初版是在小学4年级左右的时候设计的，长这个样子👇\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121141859.jpg\" width=60%>\n</span>\n还取了个名字叫**魔鬼的讴歌**🙈（中二爆棚）\n\n之前正愁博客logo用什么好的时候突然想起来，就直接用了，所以其实没什么内涵💦\n\n","tags":["设计"],"categories":["个人作品","平面设计"]},{"title":"欢迎光临🎉","url":"/2022/01/11/my-first-blog/","content":"\n## 📃Intro\n2021级大学本科生，计算机专业。此前在QQ空间写一些感想，但是感觉发挥受限，也不好排版和整理。于是趁大一时间充裕，建了一个博客用来记录我的学习成果和思考。目前专业水平不足，写不出有价值的技术性文章，因此会以翻译日语的文章为主，一方面备考N1（~~前提是抢得到考位~~），一方面也能学习和分享知识。\n<!--more-->\n\n## 🎮兴趣\n* 音乐：J-POP听的比较多，最近沉迷Vaundy的[napori](https://music.163.com/#/song?id=1450922612)。\n\n    [#古川本铺]()  [#真夜中]()  [#夜鹿]()  [#匹老板]()  [#Vaundy]()  [#優里]()\n* 番剧：虽然是老二次元，但看番比较挑，很多经典都没看过。心中的神作是三月的狮子。（但是不出续集💔\n\n    [#三月的狮子]()  [#Sonny Boy]()  [#扳机社]()  [#冰菓]()  [#春物]()\n* 游戏：进入大学后开始少玩商业，多玩独立。明日方舟会时不时回来过个年。\n\n    [#Hades]()  [#Jonathan Blow]()  [#传说之下]() [#麦哲伦(明日方舟)]()  [#YGOmobile]()\n\n* 电影：了解的不是很多，兴致来了就看。\n\n    [#韦斯·安德森]()  [#汤浅政明]() \n\n*\t书：卡尔维诺，神。\n* [#卡尔维诺]()  [#毛姆]()  [#塞林格]() \n\n最近开始有目的地去欣赏作品，提高审美，欢迎朋友们推荐🙏。\n\n## 💡个人能力\n终极目标是做独立游戏，所以各方面都在努力中，大学期间主要以提高编程能力为主。\n大一上学期给班级做了班徽，班服设计，然后个人参加了学院的明信片设计大赛拿了三等奖。\n还做了微电影的导演和后期，但那个实在是太花时间，大学期间不打算再做了。\n日语是第二母语，有语感的那种，就是词汇量还有待提高。\n\n## 📫联系方式\n* QQ：499061152\n* Bilibili：[@神秘的哇哇](https://space.bilibili.com/1394852578)\n"},{"title":"年末总结——2021","url":"/2021/12/31/conclusion-2021/","content":"2021，无论是对我，还是对我的同学们来说想必都是意义重大的一年。\n<!--more-->\n大学里也有乱七八糟的事务和浪费时间的水课，但至少我们有了选择的权利。可以选择放下冗杂的一切去钻研自己所热爱的，也可以发挥江苏学生的应试能力，杀出一条保研道路。\n\n## 来到大学觉得比较香的地方\n\n首先是食堂，总体价钱和初高中差不多，更不必说还有烤腿饭这种神的存在。（不过感觉没高中那么耐吃😭怀念芝士焗饭）\n然后是图书馆。从宿舍走路5分钟就能到。虽然装修得像个仓库一样，但藏书还是相当齐全。座位和研修室的预约管理系统也很完善，很抢手，不过井井有条。👍\n还有本学期加了两个技术社团，培训了一学期，学到了一些课外的知识，也认识了很多优秀学长。\n\n## 今年的收获\n\n看网课把C++，java，Js，html和css入了个门，本来想两个月学会web前端但发现想多了，现在处于知识非常零散的状态😫（其实就是屁都不会)希望利用寒假能把它融会贯通。\n参加了学院的明信片设计，班徽班服设计，宿舍风采，微电影制作，还有摇篮杯这几个比赛，有的拿了不错的名次，有的不是我一人能决定结果，有的主办方拉垮，但总的来说还行，也得到了同学们的肯定。👌\n因为一些原因开始时隔多年写“空间非主流文案”🐷虽然有些羞耻，实际写起来发现是个整理思绪的好方法。\n今年想通了很多事情，但随着思考深入，也更加意识到自己的不足。我不追星，但也不禁会仰望那些在舞台发光的人，也免不了为自己太过遥远的理想焦虑。💦\n>做不了天才，那就大器晚成。\n\n2022，请多指教。(^^ゞ\n","tags":["大学生活"],"categories":["总结","年末总结"]},{"title":"【The Witness】","url":"/2021/12/12/game-The-Witness/","content":"\n起初，它们只是有着固定规则的符号，只是一个个死的谜题。\n<!--more-->\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120987.jpeg)\n\n有些谜题很难，能卡我好几天。有些谜题需要先去其他区域，掌握新的规则再做。\n有些谜题，我用上了手机摄像头的彩色滤镜，或是录视频后逐帧播放，才能破解。\n还有圆柱上的，树荫下的，映在水里的谜题，我一笔一画将它铺开来，呈现在纸上才能破解。\n花了16小时，破解400多道谜题后，我以为的终点却只是把我带回起点。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120536.jpeg)\n\n然后我才发现，这不是充满谜题的世界，而是谜题组成的世界。\n是生起第一把火，点亮第一盏灯的人，他们眼里的世界。\n\n![img](https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121120069.jpeg)\n","tags":["Jonathan Blow","游戏","感想"],"categories":["游戏鉴赏","解谜"]},{"title":"班徽设计","url":"/2021/10/26/my-class-icon-design/","content":"<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121648261.jpg\" width=60%>\n</span>\n<!--more-->\n据同学说黑底背景更有感觉\n但现在看右下角那缺了一块好不爽ヾ(≧へ≦)〃\n\n## 弃用方案：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121651470.png\" width=60%>\n</span>\n只有一个8实在是太单调了（说不定可以用在球服？）\n\n\n\n## 中途版本：\n<span align='center'>\n<img src=\"https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/202201121709946.png\" width=60%>\n</span>\n一开始那个“计”放在头顶上像是要寄了x，后来做成表盘就不那么容易联想🐕\n\n","tags":["大学生活","设计"],"categories":["个人作品","平面设计"]}]