<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Distant Dreamer</title>
  
  <subtitle>No More Wasted Nights.</subtitle>
  <link href="https://lzmustb.github.io/atom.xml" rel="self"/>
  
  <link href="https://lzmustb.github.io/"/>
  <updated>2025-08-02T13:31:16.145Z</updated>
  <id>https://lzmustb.github.io/</id>
  
  <author>
    <name>Lzm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>my-maya-note</title>
    <link href="https://lzmustb.github.io/2025/07/16/my-maya-note/"/>
    <id>https://lzmustb.github.io/2025/07/16/my-maya-note/</id>
    <published>2025-07-16T06:22:09.000Z</published>
    <updated>2025-08-02T13:31:16.145Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="注意事项"   >          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1>      <ul><li>建模中，不允许出现超过四个点组成的面（多边面）</li><li>UV展开前先冻结变换</li></ul>        <h1 id="显示"   >          <a href="#显示" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示" class="headerlink" title="显示"></a>显示</h1>              <h2 id="面数"   >          <a href="#面数" class="heading-link"><i class="fas fa-link"></i></a><a href="#面数" class="headerlink" title="面数"></a>面数</h2>      <p>[Display]-&gt;[heads up display]-&gt;[poly count]</p>        <h1 id="操作"   >          <a href="#操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作" class="headerlink" title="操作"></a>操作</h1>              <h2 id="变换"   >          <a href="#变换" class="heading-link"><i class="fas fa-link"></i></a><a href="#变换" class="headerlink" title="变换"></a>变换</h2>      <p><code>G</code>：重复操作</p><p><code>alt + 鼠标左键</code>：视角旋转</p><p><code>alt + 鼠标中键</code>：视角移动</p><p><code>alt + 鼠标右键</code>：视角缩放</p><p><code>alt + shift + 鼠标</code>：单轴缩放&#x2F;移动&#x2F;旋转</p><p><code>F</code>：聚焦物体</p><p><code>w</code>：平移物体</p><p>​<code>ctrl + shift + 左键</code>：沿着边滑动</p><p><code>E</code>：旋转物体</p><p><code>R</code>：缩放物体</p><p>​<code>J</code>：固定变换比例</p>        <h2 id="显示-1"   >          <a href="#显示-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示-1" class="headerlink" title="显示"></a>显示</h2>      <p><code>1</code>：普通</p><p><code>2</code>：带线框的平滑着色</p><p><code>3</code>：平滑着色</p><p><code>4</code>：线框</p><p><code>5</code>：面着色</p><p><code>6</code>：带纹理的着色</p><p><code>alt + H</code> ：只显示选中的模型</p><p>[Display]-&gt;[Show]-&gt;[All]显示outliner的所有物体</p>        <h2 id="soft-select"   >          <a href="#soft-select" class="heading-link"><i class="fas fa-link"></i></a><a href="#soft-select" class="headerlink" title="soft select"></a>soft select</h2>      <p><code>B</code>：启动</p><p>选中顶点，<code>B + 鼠标中键</code>：改变影响范围</p>        <h2 id="multi-cut"   >          <a href="#multi-cut" class="heading-link"><i class="fas fa-link"></i></a><a href="#multi-cut" class="headerlink" title="multi-cut"></a>multi-cut</h2>      <p><code>ctrl</code>：环状切</p><p><code>shift</code>：整数百分比</p>        <h2 id="挤出边Extrude"   >          <a href="#挤出边Extrude" class="heading-link"><i class="fas fa-link"></i></a><a href="#挤出边Extrude" class="headerlink" title="挤出边Extrude"></a>挤出边Extrude</h2>      <p><code>ctrl + E</code></p>        <h2 id="参考图的导入"   >          <a href="#参考图的导入" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考图的导入" class="headerlink" title="参考图的导入"></a>参考图的导入</h2>      <p>[View]-&gt;[Image Plane]-&gt;[Import Image Plane]</p><p>在Layers窗口可以添加Layer，将参考图添加到Layer中后，可以锁定</p>        <h2 id="右键菜单"   >          <a href="#右键菜单" class="heading-link"><i class="fas fa-link"></i></a><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h2>      <p><code>右键</code>：切换选择的组件</p><p><code>shift + 右键</code>：</p><p><code>ctrl + shift + 右键</code>：(在放射变换选中的情况下)可以将仿射变换的参照在世界&#x2F;物体&#x2F;组件之间切换</p>        <h2 id="冻结变化"   >          <a href="#冻结变化" class="heading-link"><i class="fas fa-link"></i></a><a href="#冻结变化" class="headerlink" title="冻结变化"></a>冻结变化</h2>      <p>应用并重置物体的变换</p>        <h2 id="移动中心点"   >          <a href="#移动中心点" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动中心点" class="headerlink" title="移动中心点"></a>移动中心点</h2>      <p><code>D</code></p><p>居中中心点</p>        <h2 id="吸附"   >          <a href="#吸附" class="heading-link"><i class="fas fa-link"></i></a><a href="#吸附" class="headerlink" title="吸附"></a>吸附</h2>      <p><img src="/../images/image-20250717103626720.png" alt="image-20250717103626720"></p><p>吸附网格<code>x</code></p><p>吸附曲线<code>c</code>：选定物体，打开线框显示，对着曲线中键</p><p>吸附端点<code>v</code>：按住<code>ctrl</code></p><p>吸附多边形面</p><p>吸附视锥体：吸附到摄像机投影平面</p><p>吸附物体：选中物体开启，吸附到选中物体表面</p>        <h2 id="复制Transform"   >          <a href="#复制Transform" class="heading-link"><i class="fas fa-link"></i></a><a href="#复制Transform" class="headerlink" title="复制Transform"></a>复制Transform</h2>      <p>① 选中复制目标</p><p>②选中复制源</p><p>③在Channel Box中，对需要复制的属性按<code>Tab</code></p>        <h2 id="选择"   >          <a href="#选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择" class="headerlink" title="选择"></a>选择</h2>      <p>选择循环面：①选中一个面，按住<code>Shift</code>双击相邻面</p>        <h2 id="合并顶点工具"   >          <a href="#合并顶点工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#合并顶点工具" class="headerlink" title="合并顶点工具"></a>合并顶点工具</h2>      <ul><li>合并顶点到中心</li><li>根据阈值合并顶点</li><li>目标焊接工具</li></ul>        <h2 id="反转法线"   >          <a href="#反转法线" class="heading-link"><i class="fas fa-link"></i></a><a href="#反转法线" class="headerlink" title="反转法线"></a>反转法线</h2>      <p>在maya中，正面为<strong>灰色</strong>，北面为<strong>黑色</strong></p><p>反转：[Mesh Display]-&gt;[Reverse]</p>        <h2 id="复制"   >          <a href="#复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#复制" class="headerlink" title="复制"></a>复制</h2>      <p><code>ctrl + D</code>：原位置复制</p><p><code>shift + 平移</code>：（物体模式下）复制并移动</p>        <h3 id="特殊复制"   >          <a href="#特殊复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#特殊复制" class="headerlink" title="特殊复制"></a>特殊复制</h3>      <p>[Edit]-&gt;[Duplicate Special]</p><p>复制类型改为实例，可以与复制源关联</p>        <h2 id="清理"   >          <a href="#清理" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理" class="headerlink" title="清理"></a>清理</h2>      <p>[Mesh]-&gt;[Clean Up]</p>        <h2 id="隔离选择"   >          <a href="#隔离选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#隔离选择" class="headerlink" title="隔离选择"></a>隔离选择</h2>      <p><code>alt + H</code> ：只显示选择的物体</p><p><code>ctrl + H</code>：隐藏选择的物体</p><p><code>ctrl + Shift + H</code>：显示隐藏的物体</p>        <h2 id="面提取-x2F-面复制"   >          <a href="#面提取-x2F-面复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#面提取-x2F-面复制" class="headerlink" title="面提取&#x2F;面复制"></a>面提取&#x2F;面复制</h2>      <p><img src="/../images/image-20250717103529450.png" alt="image-20250717103529450"></p><p>面提取：从模型分离选中的面</p>        <h2 id="晶格"   >          <a href="#晶格" class="heading-link"><i class="fas fa-link"></i></a><a href="#晶格" class="headerlink" title="晶格"></a>晶格</h2>      <p>[Deform]-&gt;[Lattice]</p><p><img src="/../images/image-20250717170607119.png" alt="image-20250717170607119"></p><p>删除晶格：[Edit]-&gt;[Delete by Type]-&gt;[History]</p>        <h2 id="弯曲"   >          <a href="#弯曲" class="heading-link"><i class="fas fa-link"></i></a><a href="#弯曲" class="headerlink" title="弯曲"></a>弯曲</h2>      <p>[Deform]-&gt;[Nonlinear]-&gt;[bend]</p>        <h2 id="Outliner分组"   >          <a href="#Outliner分组" class="heading-link"><i class="fas fa-link"></i></a><a href="#Outliner分组" class="headerlink" title="Outliner分组"></a>Outliner分组</h2>      <p><code>Ctrl + G</code>或[Edit]-&gt;[Group]</p>        <h1 id="纹理"   >          <a href="#纹理" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1>      <p>Panels-&gt;UV Editor</p>        <h2 id="材质"   >          <a href="#材质" class="heading-link"><i class="fas fa-link"></i></a><a href="#材质" class="headerlink" title="材质"></a>材质</h2>      <p><code>右键</code>-&gt;[Material Attributes]</p>        <h2 id="AO-bake"   >          <a href="#AO-bake" class="heading-link"><i class="fas fa-link"></i></a><a href="#AO-bake" class="headerlink" title="AO bake"></a>AO bake</h2>      <p>[Arnold]-&gt;[Utilities]-&gt;[Render Selection to Texture]</p>        <h2 id="输出snapshot"   >          <a href="#输出snapshot" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出snapshot" class="headerlink" title="输出snapshot"></a>输出snapshot</h2>      <p>在UV Editor中，选中切割后的UV，菜单[Image]-&gt;[UV snapshot]</p>        <h1 id="骨骼"   >          <a href="#骨骼" class="heading-link"><i class="fas fa-link"></i></a><a href="#骨骼" class="headerlink" title="骨骼"></a>骨骼</h1>              <h2 id="Joint"   >          <a href="#Joint" class="heading-link"><i class="fas fa-link"></i></a><a href="#Joint" class="headerlink" title="Joint"></a>Joint</h2>      <ul><li>[Menu Set] -&gt; [Rigging]</li><li>Skeleton-&gt;Create Joints</li></ul><p>在Ourliner中，<code>中键</code>拖拽可以添加子节点</p>        <h3 id="显示节点的旋转轴"   >          <a href="#显示节点的旋转轴" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示节点的旋转轴" class="headerlink" title="显示节点的旋转轴"></a>显示节点的旋转轴</h3>      <p>[DIsplay]-&gt;[Transform Display]-&gt;[Local Rotate Axis]</p>        <h3 id="修改旋转轴"   >          <a href="#修改旋转轴" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改旋转轴" class="headerlink" title="修改旋转轴"></a>修改旋转轴</h3>      <p>[Skeleton]-&gt;[Orient Joints]</p>        <h3 id="镜像"   >          <a href="#镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3>      <p>[Skeleton]-&gt;[Mirror Joints]</p>        <h2 id="Skin"   >          <a href="#Skin" class="heading-link"><i class="fas fa-link"></i></a><a href="#Skin" class="headerlink" title="Skin"></a>Skin</h2>              <h3 id="绑定"   >          <a href="#绑定" class="heading-link"><i class="fas fa-link"></i></a><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3>      <p>选中模型&amp;骨骼，[Skin]-&gt;[Bind Skin]</p>        <h3 id="调整权重"   >          <a href="#调整权重" class="heading-link"><i class="fas fa-link"></i></a><a href="#调整权重" class="headerlink" title="调整权重"></a>调整权重</h3>      <p>[Skin]-&gt;[Paint Skin Weights]</p><p>笔刷大小：<code>B + 左键</code></p>        <h2 id="Rig"   >          <a href="#Rig" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rig" class="headerlink" title="Rig"></a>Rig</h2>      <p><img src="/../images/image-20250719222900082.png" alt="image-20250719222900082"></p>        <h3 id="IK"   >          <a href="#IK" class="heading-link"><i class="fas fa-link"></i></a><a href="#IK" class="headerlink" title="IK"></a>IK</h3>      <p>[Skeleton]-&gt;[Create IK Handle]</p>        <h3 id="HumanIK"   >          <a href="#HumanIK" class="heading-link"><i class="fas fa-link"></i></a><a href="#HumanIK" class="headerlink" title="HumanIK"></a>HumanIK</h3>      <p>[Windows]-&gt;[Animation Editor]-&gt;[HumanIK]</p><p>Create Character definition</p><p>在Outliner中选择骨骼，在任务面板右键骨骼选择[assign selected bone]</p><p>绑定完后，点击[Create Control Rig]（垃圾桶旁边）</p><p><img src="/../images/image-20250720123420924.png" alt="image-20250720123420924"></p>        <h3 id="Constrain"   >          <a href="#Constrain" class="heading-link"><i class="fas fa-link"></i></a><a href="#Constrain" class="headerlink" title="Constrain"></a>Constrain</h3>      <p>Rigging模式下：[Constrain]</p><ul><li>用一个物体约束另一个物体的某些属性</li></ul><p>[Parent]：相对位置</p><p>[Point]：绝对位置</p><p>[Orient]：方向</p><p>[Scale]：缩放</p><p>[Aim]：物体B朝向物体A所在方向</p><p>[Pole Vector]：物体B(IK Handle)折向物体A</p>        <h1 id="光源"   >          <a href="#光源" class="heading-link"><i class="fas fa-link"></i></a><a href="#光源" class="headerlink" title="光源"></a>光源</h1>      <p>创建：[Create]-&gt;[Light]</p>        <h1 id="Blender"   >          <a href="#Blender" class="heading-link"><i class="fas fa-link"></i></a><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h1>              <h2 id="物体半透明"   >          <a href="#物体半透明" class="heading-link"><i class="fas fa-link"></i></a><a href="#物体半透明" class="headerlink" title="物体半透明"></a>物体半透明</h2>      <p><code>alt + z</code></p>        <h2 id="选择循环边"   >          <a href="#选择循环边" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择循环边" class="headerlink" title="选择循环边"></a>选择循环边</h2>      <p><code>alt 左键</code></p>        <h2 id="Edge-Crease"   >          <a href="#Edge-Crease" class="heading-link"><i class="fas fa-link"></i></a><a href="#Edge-Crease" class="headerlink" title="Edge Crease"></a>Edge Crease</h2>      <p>Shift + E</p>        <h2 id="贝塞尔曲线"   >          <a href="#贝塞尔曲线" class="heading-link"><i class="fas fa-link"></i></a><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2>      <p><code>F</code>连接两个端点</p><p><code>ctrl + 右键</code>：在指针处添加端点</p><p>[subdivide]：在两个端点之间添加一个端点</p><p><code>p</code>：分离选中的两个端点之间的线段</p><p><code>v</code>：修改曲线定义</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;注意事项&quot;   &gt;
          &lt;a href=&quot;#注意事项&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="https://lzmustb.github.io/2025/06/23/my-java-notes/"/>
    <id>https://lzmustb.github.io/2025/06/23/my-java-notes/</id>
    <published>2025-06-23T00:32:19.000Z</published>
    <updated>2025-06-23T12:47:11.611Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="Java"   >          <a href="#Java" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java" class="headerlink" title="Java"></a>Java</h1>      <div class="table-container"><table><thead><tr><th>Java开发</th><th></th></tr></thead><tbody><tr><td>JDK</td><td>Java开发</td></tr><tr><td>JRE</td><td>Java运行环境（JVM+核心类库）</td></tr></tbody></table></div>        <h2 id="基本语法-amp-数据类型"   >          <a href="#基本语法-amp-数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本语法-amp-数据类型" class="headerlink" title="基本语法&amp;数据类型"></a>基本语法&amp;数据类型</h2>      <p>输出 <code>System.out.println()</code></p><div class="table-container"><table><thead><tr><th>数据类型</th><th></th></tr></thead><tbody><tr><td>引用数据类型（地址传递）</td><td>String，Array</td></tr><tr><td>基本数据类型（值传递）</td><td>整数 {<code>byte</code>(1); <code>short</code>(2); <code>int</code>(4); <code>long</code>(8); }<br />浮点数 {<code>float</code>(4); <code>double</code>(8); }<br />字符 {<code>char</code>(2); }<br />布尔值 {<code>boolean</code>(1); }</td></tr></tbody></table></div><p>数据后+L：long</p><p>+F：float</p><ul><li>标识符：不能以数字开头，不为关键字</li><li><strong>变量</strong>首字母小写，<strong>类</strong>首字母大写</li></ul><p>+号与字符串运算时算作连接符：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(a + <span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 5+97=102</span></span><br><span class="line">System.out.println(<span class="number">15</span> + <span class="string">&quot;abc&quot;</span>); <span class="comment">// &quot;15abc&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span> + a + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// &quot;abc5a&quot;</span></span><br></pre></td></tr></table></div></figure><ul><li>双与 优先级 高于 双或</li></ul><p>键盘录入：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></div></figure>        <h3 id="数组"   >          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h3>      <p>定义：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = (<span class="keyword">new</span> 数据类型[])&#123;&#125;</span><br><span class="line">数组名[] = ...</span><br></pre></td></tr></table></div></figure><p>扩容：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">arr = newArr</span><br></pre></td></tr></table></div></figure>        <h3 id="结束外层循环"   >          <a href="#结束外层循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#结束外层循环" class="headerlink" title="结束外层循环"></a>结束外层循环</h3>      <p>使用标签结束外层循环</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OUT:</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">        <span class="keyword">break</span> OUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Java内存分配"   >          <a href="#Java内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h3>      <div class="table-container"><table><thead><tr><th>空间</th><th></th></tr></thead><tbody><tr><td>栈</td><td>方法运行时进入，存储变量（数组名）</td></tr><tr><td>堆</td><td>new产生的对象</td></tr><tr><td>方法区</td><td>class文件（字节码文件加载，未被调用时存放，调用时入栈），引用类型</td></tr></tbody></table></div><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个变量指向同一个数组</span></span><br><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = arr1;</span><br></pre></td></tr></table></div></figure>        <h3 id="String"   >          <a href="#String" class="heading-link"><i class="fas fa-link"></i></a><a href="#String" class="headerlink" title="String"></a>String</h3>      <ul><li>判断相等的方法<code>s.equals(&lt;String&gt;)</code></li><li>基本数据类型转String：<code>String s = n + &quot;&quot;;</code></li><li>String转基本数据类型：<code>int n = Integer.parseInt(s);</code></li></ul>        <h2 id="方法"   >          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法" class="headerlink" title="方法"></a>方法</h2>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;Java&quot;   &gt;
          &lt;a href=&quot;#Java&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>my-fluid-material-editor</title>
    <link href="https://lzmustb.github.io/2025/03/21/my-fluid-material-editor/"/>
    <id>https://lzmustb.github.io/2025/03/21/my-fluid-material-editor/</id>
    <published>2025-03-21T01:25:32.000Z</published>
    <updated>2025-03-21T02:25:44.475Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎编程学习笔记</title>
    <link href="https://lzmustb.github.io/2025/02/25/my-gameEngine-learning/"/>
    <id>https://lzmustb.github.io/2025/02/25/my-gameEngine-learning/</id>
    <published>2025-02-25T11:14:54.000Z</published>
    <updated>2025-03-20T07:35:55.139Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>      <p>观看Cherno <span class="exturl"><a class="exturl__link"   href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqa3FXT0VLbHctcGxTWFB0LVEyVjVxN0kwa05oUXxBQ3Jtc0tsc082bWs3YmFPVXY3WE5WMlJrUU1URlFxaXIxa1ZGMFhwVU1xQ29DT0ZIVzVNbFdDenJ0MXFTY25QT2hoUEh1V3lHV0pEUWhQZ0hBOUZkelNzb2NVU2Y2T0JJUzdBUWVKX3VHTU9Ob2w1eThtZll5WQ&q=https://thecherno.com/engine&v=5mlziHwq90k" >GameEngine系列教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>所做的笔记</p>        <h1 id="游戏引擎编程"   >          <a href="#游戏引擎编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏引擎编程" class="headerlink" title="游戏引擎编程"></a>游戏引擎编程</h1>              <h2 id="项目架构"   >          <a href="#项目架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2>      <ul><li>引擎本体（生成dll，给sandbox使用）</li><li>Sandbox（依赖engine的dll，继承engine的<code>Application</code>类）</li></ul><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GameEnginePractice</span><br><span class="line">├─ GameEnginePractice</span><br><span class="line">│  ├─ src</span><br><span class="line">│  │  ├─ Core</span><br><span class="line">│  │  │  ├─ Application.cpp【引擎应用层】</span><br><span class="line">│  │  │  ├─ Application.h</span><br><span class="line">│  │  │  ├─ Core.h【通过宏配置dllexport/import】</span><br><span class="line">│  │  │  ├─ EntryPoint.h【应用程序入口】</span><br><span class="line">│  │  │  ├─ Log.cpp【日志类】</span><br><span class="line">│  │  │  └─ Log.h</span><br><span class="line">│  │  └─ pEngine.h【用于包含整个项目，用户只需include这个头文件】</span><br><span class="line">│  └─ vendor【第三方库文件夹】</span><br><span class="line">├─ Sandbox</span><br><span class="line">│  └─ src</span><br><span class="line">│     └─ Source.cpp</span><br><span class="line">└─ vendor</span><br></pre></td></tr></table></div></figure>        <h2 id="单头文件"   >          <a href="#单头文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#单头文件" class="headerlink" title="单头文件"></a>单头文件</h2>      <p>在<code>pEngine.h</code>中，统一include其他文件，则用户在使用该dll时，只需包含<code>pEngine.h</code>。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core/Application.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core/Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --Entry Point--</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core/EntryPoint.h&quot;</span></span></span><br><span class="line"><span class="comment">// ---------------</span></span><br></pre></td></tr></table></div></figure>        <h2 id="EntryPoint"   >          <a href="#EntryPoint" class="heading-link"><i class="fas fa-link"></i></a><a href="#EntryPoint" class="headerlink" title="EntryPoint"></a>EntryPoint</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PE_PLATFORM_WINDOWS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> pEngine::Application* <span class="title">pEngine::CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">pEngine::Log::<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Run Application&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> app = pEngine::<span class="built_in">CreateApplication</span>();</span><br><span class="line">app-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">delete</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>在dll文件的<code>EntryPoint.h</code>中定义<strong>main函数</strong>，而不是在Sandbox中。Sandbox中只需继承Application类，并定义<code>CreateApplication()</code></p>        <h2 id="日志系统"   >          <a href="#日志系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2>      <p>本教程采用的是<span class="exturl"><a class="exturl__link"   href="https://github.com/gabime/spdlog" >spdlog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><ul><li>包装为log类：未来更换日志库时，不影响用户的使用</li><li>用宏代替直接调用：通过<code>undef</code>可以轻易屏蔽日志</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> pEngine &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> Log</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetCoreLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_CoreLogger; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetClientLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_ClientLogger; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt; s_CoreLogger;</span><br><span class="line"><span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt; s_ClientLogger;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core log macros</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_CORE_ERROR(...)::pEngine::Log::GetCoreLogger()-&gt;<span class="keyword">error</span>(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_CORE_WARN(...)::pEngine::Log::GetCoreLogger()-&gt;warn(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_CORE_INFO(...)::pEngine::Log::GetCoreLogger()-&gt;info(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_CORE_TRACE(...)::pEngine::Log::GetCoreLogger()-&gt;trace(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_CORE_FATAL(...)::pEngine::Log::GetCoreLogger()-&gt;fatal(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//client log macros</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_ERROR(...)::pEngine::Log::GetClientLogger()-&gt;<span class="keyword">error</span>(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_WARN(...)::pEngine::Log::GetClientLogger()-&gt;warn(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_INFO(...)::pEngine::Log::GetClientLogger()-&gt;info(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_TRACE(...)::pEngine::Log::GetClientLogger()-&gt;trace(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PE_FATAL(...)::pEngine::Log::GetClientLogger()-&gt;fatal(__VA_ARGS__)</span></span><br></pre></td></tr></table></div></figure><p>Init:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;%^[%T] %n: %v%$&quot;</span>);</span><br><span class="line">s_CoreLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;pEngine&quot;</span>);</span><br><span class="line">s_CoreLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line"><span class="built_in">PE_CORE_WARN</span>(<span class="string">&quot;CoreLogger Initialized.&quot;</span>);</span><br><span class="line"></span><br><span class="line">s_ClientLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;APP&quot;</span>);</span><br><span class="line">s_ClientLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line"><span class="built_in">PE_INFO</span>(<span class="string">&quot;ClientLogger Initialized.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="premake"   >          <a href="#premake" class="heading-link"><i class="fas fa-link"></i></a><a href="#premake" class="headerlink" title="premake"></a>premake</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://github.com/premake/premake-core" >github</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>用于项目构建的程序，cmake的替代方案</p>        <h3 id="使用"   >          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用" class="headerlink" title="使用"></a>使用</h3>      <p>下载premake5.exe</p><p>在项目根目录创建<code>premake5.lua</code>，写配置脚本</p><p>创建<code>GenerateProjects.bat</code>：</p><figure class="highlight bat"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> vendor\bin\premake\premake5.exe vs2022</span><br><span class="line"><span class="built_in">PAUSE</span></span><br></pre></td></tr></table></div></figure>        <h2 id="EventSystem"   >          <a href="#EventSystem" class="heading-link"><i class="fas fa-link"></i></a><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h2>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ Events</span><br><span class="line">│  ├─ Event.h</span><br><span class="line">│  ├─ KeyEvent.h</span><br><span class="line">│  ├─ MouseEvent.h</span><br><span class="line">│  ├─ ApplicationEvent.h</span><br></pre></td></tr></table></div></figure>        <h3 id="Event基类"   >          <a href="#Event基类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Event基类" class="headerlink" title="Event基类"></a>Event基类</h3>      <p>枚举类型EventType用于标注事件具体类型，EventCategory用于区分事件标签</p><p><strong>Event基类</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Event</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Handled = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetCategoryFlags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetName</span>(); &#125;</span><br><span class="line">    <span class="comment">//一个事件可以有多个category，用与运算判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInCategory</span><span class="params">(EventCategory category)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetCategoryFlags</span>() &amp; category;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>事件发送类</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> EventDispatcher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">EventDispatcher</span>(Event&amp; event)</span><br><span class="line">: <span class="built_in">m_Event</span>(event)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// F will be deduced by the compiler</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(<span class="type">const</span> F&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_Event.Handled |= <span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;T&amp;&gt;(m_Event));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Event&amp; m_Event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h3 id="KeyEvent类"   >          <a href="#KeyEvent类" class="heading-link"><i class="fas fa-link"></i></a><a href="#KeyEvent类" class="headerlink" title="KeyEvent类"></a>KeyEvent类</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeyEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">KeyCode <span class="title">GetKeyCode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_KeyCode; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义EventCategory</span></span><br><span class="line"><span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">KeyEvent</span>(<span class="type">const</span> KeyCode keycode)</span><br><span class="line">: <span class="built_in">m_KeyCode</span>(keycode) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">KeyCode m_KeyCode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KeyPressedEvent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeyPressedEvent</span> : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">KeyPressedEvent</span>(<span class="type">const</span> KeyCode keycode, <span class="type">bool</span> isRepeat = <span class="literal">false</span>)</span><br><span class="line">: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_IsRepeat</span>(isRepeat) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRepeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_IsRepeat; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (repeat = &quot;</span> &lt;&lt; m_IsRepeat &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//定义EventType</span></span><br><span class="line"><span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> m_IsRepeat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyReleasedEvent，KeyTypedEvent类似</span></span><br></pre></td></tr></table></div></figure>        <h2 id="precompiled-header"   >          <a href="#precompiled-header" class="heading-link"><i class="fas fa-link"></i></a><a href="#precompiled-header" class="headerlink" title="precompiled header"></a>precompiled header</h2>      <p>预编译头文件是一种C++编译技术，用于提高<strong>编译速度</strong></p><p><code>xxpch.h</code>：预编译头文件，包含了<strong>不常修改的api头文件</strong>(标准库头文件等)</p><p><code>xxpch.cpp</code>：对应的源文件，通常只有一句<code>include &quot;xxpch.h&quot;</code>，用于生成<code>xxpch.h</code>的二进制文件。</p>        <h3 id="premake中使用"   >          <a href="#premake中使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#premake中使用" class="headerlink" title="premake中使用"></a>premake中使用</h3>      <p>在引擎的project中：</p><figure class="highlight lua"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pchheader <span class="string">&quot;pepch.h&quot;</span></span><br><span class="line">pchsource <span class="string">&quot;pepch.cpp所在路径&quot;</span></span><br></pre></td></tr></table></div></figure>        <h3 id="Visual-Studio-中使用"   >          <a href="#Visual-Studio-中使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Visual-Studio-中使用" class="headerlink" title="Visual Studio 中使用"></a>Visual Studio 中使用</h3>      <p>在Visual Studio的项目属性中：</p><p>Precompiled Header 设为<code>Use</code>，File设为<code>pepch.h</code></p><p><img src="/../images/image-20250227194015335.png" alt="image-20250227194015335"></p><p>在pepch.cpp的属性中：</p><p>Precompiled Header 设为<code>Create</code>即可启用。</p><p><img src="/../images/image-20250227193811006.png" alt="image-20250227193811006"></p>        <h2 id="Window"   >          <a href="#Window" class="heading-link"><i class="fas fa-link"></i></a><a href="#Window" class="headerlink" title="Window"></a>Window</h2>      <p>抽象Window类，将逻辑，API从实现平台分离。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─ Core</span><br><span class="line">│  ├─ Window.h</span><br><span class="line">│  ├─ Window.cpp</span><br><span class="line">├─ Platform</span><br><span class="line">│  ├─ Windows</span><br><span class="line">│  │  ├─WindowsWindow.cpp</span><br><span class="line">│  │  ├─WindowsWindow.h</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Window</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window attributes</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Window* <span class="title">Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props = WindowProps())</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h3 id="Window-amp-Event"   >          <a href="#Window-amp-Event" class="heading-link"><i class="fas fa-link"></i></a><a href="#Window-amp-Event" class="headerlink" title="Window&amp;Event"></a>Window&amp;Event</h3>      <p>在不同平台的事件api中调用抽象类的事件api</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line">        <span class="comment">//调用抽象类的回调函数</span></span><br><span class="line">data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">data.Width = width;</span><br><span class="line">data.Height = height;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>        <h2 id="Layer"   >          <a href="#Layer" class="heading-link"><i class="fas fa-link"></i></a><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h2>      <p>在主循环中，按照顺序处理不同Layer的逻辑</p>        <h3 id="Layer-1"   >          <a href="#Layer-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Layer-1" class="headerlink" title="Layer"></a>Layer</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Layer</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Layer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDetach</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在主循环中，每一帧调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在应用的OnEvent中，自底向上调用所有layer的onevent</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp; event)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_DebugName; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">std::string m_DebugName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h3 id="LayerStack"   >          <a href="#LayerStack" class="heading-link"><i class="fas fa-link"></i></a><a href="#LayerStack" class="headerlink" title="LayerStack"></a>LayerStack</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PENGINE_API</span> LayerStack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LayerStack</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">LayerStack</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushLayer</span><span class="params">(Layer* layer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushOverlay</span><span class="params">(Layer* overlay)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopLayer</span><span class="params">(Layer* layer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopOverlay</span><span class="params">(Layer* overlay)</span></span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">end</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">rend</span>(); &#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">end</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">rend</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Layer*&gt; m_Layers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m_LayerInsertIndex = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h2 id="导入ImGui"   >          <a href="#导入ImGui" class="heading-link"><i class="fas fa-link"></i></a><a href="#导入ImGui" class="headerlink" title="导入ImGui"></a>导入ImGui</h2>              <h2 id="RenderAPI"   >          <a href="#RenderAPI" class="heading-link"><i class="fas fa-link"></i></a><a href="#RenderAPI" class="headerlink" title="RenderAPI"></a>RenderAPI</h2>              <h3 id="API架构"   >          <a href="#API架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#API架构" class="headerlink" title="API架构"></a>API架构</h3>      <p><strong>※确定平台相关&#x2F;非相关API的分界线</strong></p><p>RenderAPI：(platform specific)</p><ul><li>Render Context</li><li>Swap chain</li><li>Framebuffer</li><li>Vertex Buffer</li><li>Index Buffer</li><li>Texture</li><li>Shader</li><li>states</li><li>pipelines</li><li>Render passes</li></ul><p>Renderer：(platform agnostic)</p><ul><li>2D&amp;3D renderer（forward, defferred, etc）</li><li>scene manager</li><li>sorting</li><li>culling</li><li>materials</li><li>LOD</li><li>animation</li><li>camera</li><li>VFX</li><li>PostFX</li></ul>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;前言&quot;   &gt;
          &lt;a href=&quot;#前言&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="图形学" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="游戏" scheme="https://lzmustb.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://lzmustb.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记</title>
    <link href="https://lzmustb.github.io/2025/01/08/my-cpp-learning-note/"/>
    <id>https://lzmustb.github.io/2025/01/08/my-cpp-learning-note/</id>
    <published>2025-01-08T04:07:12.000Z</published>
    <updated>2025-03-21T11:57:18.288Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="Cmake"   >          <a href="#Cmake" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1>              <h1 id="头文件"   >          <a href="#头文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1>      <p>头文件通常包含那些只能被定义一次的实体，如类，const和constexpr变量等。</p><blockquote><p>※头文件不应使用using声明，否则会导致每个使用了该头文件的文件都有这个声明</p></blockquote>        <h2 id="预处理器"   >          <a href="#预处理器" class="heading-link"><i class="fas fa-link"></i></a><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2>      <p>在编译之前执行，用于部分改变我们所写的程序</p><p>预处理指令：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用指定的头文件代替include</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>        <h1 id="基本类型"   >          <a href="#基本类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1>              <h2 id="标识符identifier"   >          <a href="#标识符identifier" class="heading-link"><i class="fas fa-link"></i></a><a href="#标识符identifier" class="headerlink" title="标识符identifier"></a>标识符identifier</h2>      <p>标识符identifier由字母，数字，下划线组成，<strong>必须以字母或下划线开头</strong>，长度无限制，大小写敏感。</p>        <h3 id="c-关键字"   >          <a href="#c-关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-关键字" class="headerlink" title="c++关键字"></a>c++关键字</h3>      <p><img src="/../images/image-20250108151203596.png" alt="image-20250108151203596"></p>        <h3 id="作用域scope"   >          <a href="#作用域scope" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域scope</h3>      <p>同一个名字在不同作用域可能指向不同的实体。</p><p>一个名字的有效区域始于名字的声明，在作用域末端结束。</p><p>使用<code>using</code>引入命名空间的成员：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使所有库函数都默认std（不常用）</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//个别引入</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></div></figure>        <h2 id="无符号-x2F-有符号"   >          <a href="#无符号-x2F-有符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#无符号-x2F-有符号" class="headerlink" title="无符号&#x2F;有符号"></a>无符号&#x2F;有符号</h2>      <blockquote><p>※在同一个表达式中，有符号类型会转换为无符号类型</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; a + b; <span class="comment">//输出1+2^32-2==2^32-1</span></span><br></pre></td></tr></table></div></figure></blockquote>        <h2 id="变量初始化"   >          <a href="#变量初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2>              <h3 id="声明和定义"   >          <a href="#声明和定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3>      <p>※声明不分配空间，定义申请空间并赋初值</p><p>※变量可以被多次声明，但只能被定义一次</p><p>仅声明：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;<span class="comment">//仅声明</span></span><br><span class="line"><span class="type">int</span> j;<span class="comment">//声明并定义</span></span><br></pre></td></tr></table></div></figure>        <h3 id="默认初始化"   >          <a href="#默认初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3>      <p>定义变量时没有指定初值，将会被默认初始化</p><ul><li><p>函数体外的基本类型变量初始化为0</p></li><li><p>函数体内部的基本类型变量将<strong>不被初始化</strong></p></li></ul>        <h3 id="列表初始化"   >          <a href="#列表初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表初始化" class="headerlink" title="{}列表初始化"></a>{}列表初始化</h3>      <p>禁止类型的自动转化，防止因自动转换而丢失信息</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">7.2</span> <span class="comment">//自动转换为7</span></span><br><span class="line"><span class="type">int</span> i2 &#123;<span class="number">7.2</span>&#125; <span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> i3 = &#123;<span class="number">7.2</span>&#125; <span class="comment">//报错</span></span><br></pre></td></tr></table></div></figure>        <h3 id="auto"   >          <a href="#auto" class="heading-link"><i class="fas fa-link"></i></a><a href="#auto" class="headerlink" title="auto"></a>auto</h3>      <p>c++11</p><p>编译器自动推断类型</p><p>※auto定义的变量必须有初始值</p>        <h3 id="decltype"   >          <a href="#decltype" class="heading-link"><i class="fas fa-link"></i></a><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3>      <p>c++11</p><p>表达式的返回类型作为类型声明</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = x;</span><br><span class="line"><span class="comment">//将func()的返回值类型作为sum的类型，但不调用func()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = &amp;i;</span><br><span class="line"><span class="comment">//c的类型为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = <span class="number">1</span>; <span class="comment">//传入解引用，则得到引用类型，必须初始化</span></span><br></pre></td></tr></table></div></figure><blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) c;<span class="comment">//正确，c的类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) c;<span class="comment">//错误，c的类型为int&amp;,必须初始化</span></span><br></pre></td></tr></table></div></figure><p>加上括号的变量可以作为赋值语句左值的特殊表达式，所以<strong>一定</strong>得到引用类型</p></blockquote>        <h2 id="常量"   >          <a href="#常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量" class="headerlink" title="常量"></a>常量</h2>              <h3 id="字面值常量"   >          <a href="#字面值常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3>      <p>字面值常量（literal）</p><ul><li>整型</li></ul><p>不同进制的20声明：</p><p>十六进制：<code>0x14</code></p><p>八进制：<code>024</code></p><p>十进制：<code>20</code></p><ul><li>浮点型</li></ul><p><code>3.14159</code>，<code>3.14159E0</code>，<code>0.</code>，<code>.001</code></p><ul><li>字符型</li></ul><p><code>&#39;a&#39;</code>：字符只占一个字节</p><p><code>&quot;a&quot;</code>：字符串是字符数组，多占一个字节存储空字符<code>&#39;\0&#39;</code></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串字面值可以分多行书写</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a really long string literal&quot;</span></span><br><span class="line">    <span class="string">&quot;that spans two lines&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></div></figure>        <h4 id="字符转义"   >          <a href="#字符转义" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4>      <div class="table-container"><table><thead><tr><th>转义序列(escape sequence)</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>横向制表符(tab)</td></tr><tr><td>\a</td><td>报警(响铃)符</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\\</td><td>反斜线</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\‘</td><td>单引号</td></tr></tbody></table></div>        <h4 id="指定字面值类型"   >          <a href="#指定字面值类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#指定字面值类型" class="headerlink" title="指定字面值类型"></a>指定字面值类型</h4>      <p><img src="/../images/image-20250108145832735.png" alt="image-20250108145832735"></p>        <h3 id="常量标识符"   >          <a href="#常量标识符" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量标识符" class="headerlink" title="常量标识符"></a>常量标识符</h3>              <h4 id="const"   >          <a href="#const" class="heading-link"><i class="fas fa-link"></i></a><a href="#const" class="headerlink" title="const"></a>const</h4>      <blockquote><p>※默认情况下，<code>const</code>定义的变量只在文件内有效。</p><p>跨文件使用：都使用<code>extern</code>关键字</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//file1</span></span><br><span class="line">&gt;<span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">func</span>();</span><br><span class="line">&gt;<span class="comment">//file2</span></span><br><span class="line">&gt;<span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></div></figure></blockquote><p>常量引用：</p><blockquote><p>※不能用普通引用去引用一个常量</p><p>本质：创建一个临时变量的引用</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = temp;</span><br></pre></td></tr></table></div></figure></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = a;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = a;<span class="comment">//错误，引用也必须声明为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = b;<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r4 = <span class="number">42</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r5 = r;<span class="comment">//错误，引用也必须声明为常量</span></span><br></pre></td></tr></table></div></figure><p><code>const</code>修饰形参，防止修改：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span></span>;</span><br></pre></td></tr></table></div></figure>        <h4 id="constexpr"   >          <a href="#constexpr" class="heading-link"><i class="fas fa-link"></i></a><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4>      <p>c++11</p><p>常量表达式（const expression）是指不会改变且在编译过程就能预知结果的表达式</p><p><strong>非</strong>常量表达式：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">27</span>;<span class="comment">//在后续可能改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="built_in">random</span>();<span class="comment">//编译时不确定</span></span><br></pre></td></tr></table></div></figure><p>用于指针：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>;<span class="comment">//p是一个const pointer，顶层const</span></span><br></pre></td></tr></table></div></figure>        <h2 id="复合类型"   >          <a href="#复合类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2>      <p>基于其他类型定义的类型</p><ul><li>引用</li><li>指针</li></ul>        <h3 id="左值引用"   >          <a href="#左值引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;<span class="comment">//b指向a，当a改变b也改变</span></span><br><span class="line"><span class="type">int</span> &amp;c;<span class="comment">//报错，引用必须被初始化</span></span><br><span class="line"><span class="type">int</span> &amp;d = <span class="number">10</span><span class="comment">//报错,引用的初始值不能为字面值</span></span><br></pre></td></tr></table></div></figure><p>引用的本质：指针常量（无法修改指向的地址）</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ref = &amp;a;</span><br></pre></td></tr></table></div></figure><p>引用传递：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></div></figure><p>引用返回：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//使得函数调用可以作为左值</span></span><br><span class="line"><span class="comment">//※不能返回局部变量的引用（会被释放）</span></span><br></pre></td></tr></table></div></figure>        <h3 id="指针"   >          <a href="#指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针" class="headerlink" title="指针"></a>指针</h3>      <blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1,p2;<span class="comment">//p1为指针，p2为int</span></span><br></pre></td></tr></table></div></figure></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//指针无需在定义时赋值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;a;<span class="comment">//指针存放地址，因此使用取址符</span></span><br></pre></td></tr></table></div></figure><p>指针的解引用：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; *p;<span class="comment">//获取p指向的值</span></span><br><span class="line">*p = <span class="number">0</span>;<span class="comment">//给指针所指的变量赋值</span></span><br></pre></td></tr></table></div></figure><p>c++11空指针：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></div></figure><p>指向指针的指针：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** p = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">10</span>]; <span class="comment">//指向一个int指针数组</span></span><br><span class="line">cout&lt;&lt; **p;<span class="comment">//解引用到int</span></span><br></pre></td></tr></table></div></figure><p>指向指针的引用：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span>* &amp;r = p;</span><br></pre></td></tr></table></div></figure><p>※面对比较复杂的指针或引用声明时，从右向左有助于弄清真实含义。</p>        <h4 id="指针和const"   >          <a href="#指针和const" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4>      <p>pointer to const（low-level const）：不能改变值，可以改变指向的地址</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * ptr = &amp;a;</span><br></pre></td></tr></table></div></figure><p>const pointer（top-level const）：不可改变指向（引用的本质）</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ref = &amp;a;</span><br></pre></td></tr></table></div></figure>        <h4 id="void"   >          <a href="#void" class="heading-link"><i class="fas fa-link"></i></a><a href="#void" class="headerlink" title="void*"></a>void*</h4>      <p>可以用于存放任意类型的指针</p>        <h3 id="声明"   >          <a href="#声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#声明" class="headerlink" title="声明"></a>声明</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p;</span><br><span class="line"><span class="type">char</span> v[<span class="number">6</span>]; <span class="comment">//变量&#x27;v&#x27;存的是数组第一个值的地址</span></span><br></pre></td></tr></table></div></figure>        <h3 id="取值-amp-取址"   >          <a href="#取值-amp-取址" class="heading-link"><i class="fas fa-link"></i></a><a href="#取值-amp-取址" class="headerlink" title="取值&amp;取址"></a>取值&amp;取址</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = &amp;v[<span class="number">3</span>]; <span class="comment">//前置&amp;获取变量的地址</span></span><br><span class="line"><span class="type">char</span> x = *p;     <span class="comment">//前置*获取变量的值</span></span><br></pre></td></tr></table></div></figure>        <h2 id="遍历"   >          <a href="#遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2>              <h3 id="for"   >          <a href="#for" class="heading-link"><i class="fas fa-link"></i></a><a href="#for" class="headerlink" title="for"></a>for</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制v中的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : v)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用v中的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : v)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="类型别名"   >          <a href="#类型别名" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1>              <h2 id="类型别名type-alias"   >          <a href="#类型别名type-alias" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型别名type-alias" class="headerlink" title="类型别名type alias"></a>类型别名type alias</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;<span class="comment">//wages是double的同义词</span></span><br></pre></td></tr></table></div></figure><blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="comment">//cstr是const pointer</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></div></figure><p>不能简单将pstring替换为char*来理解</p></blockquote>        <h2 id="别名声明alias-declaration"   >          <a href="#别名声明alias-declaration" class="heading-link"><i class="fas fa-link"></i></a><a href="#别名声明alias-declaration" class="headerlink" title="别名声明alias declaration"></a>别名声明alias declaration</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;<span class="comment">//SI是Sales_item的同义词</span></span><br></pre></td></tr></table></div></figure>        <h1 id="标准库类型"   >          <a href="#标准库类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准库类型" class="headerlink" title="标准库类型"></a>标准库类型</h1>              <h2 id="string"   >          <a href="#string" class="heading-link"><i class="fas fa-link"></i></a><a href="#string" class="headerlink" title="string"></a>string</h2>      <blockquote><p>为了与c兼容，字符串字面值与string类型不同，字符串字面值为char array</p></blockquote><p>可变长的字符序列</p><p>引入：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></div></figure>        <h3 id="定义"   >          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;a&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（将创建临时变量）</span></span><br><span class="line">string a = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></div></figure>        <h3 id="读取"   >          <a href="#读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#读取" class="headerlink" title="读取"></a>读取</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.按单词读取（空格截断）</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)&#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.整行读取（换行符截断）(string中不包含换行符)</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))&#123;</span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="empty"   >          <a href="#empty" class="heading-link"><i class="fas fa-link"></i></a><a href="#empty" class="headerlink" title="empty"></a>empty</h3>      <p>用于判断字符串是否为空</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!line.<span class="built_in">empty</span>())</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure>        <h3 id="size"   >          <a href="#size" class="heading-link"><i class="fas fa-link"></i></a><a href="#size" class="headerlink" title="size"></a>size</h3>      <p>返回字符数量（不包括空字符）</p><p>返回类型：<code>size_type</code>，无符号整数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">size</span>();<span class="comment">//为3</span></span><br><span class="line">a[<span class="number">3</span>]<span class="comment">//得到空字符</span></span><br></pre></td></tr></table></div></figure>        <h3 id="运算"   >          <a href="#运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算" class="headerlink" title="运算"></a>运算</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s3 = s1 + s2;</span><br><span class="line">string s3 = s1 + <span class="string">&quot;, &quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></div></figure><blockquote><p>必须确保每个<code>+</code>运算符两边至少有一个string对象</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误！</span></span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//正确，前面的运算返回string类型</span></span><br><span class="line">string s4 = s1 + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></div></figure></blockquote>        <h3 id="遍历-1"   >          <a href="#遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)&#123;</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="c风格字符串"   >          <a href="#c风格字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h3>      <p>定义在cstring头文件中</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回长度，不包含空字符</span></span><br><span class="line"><span class="comment">//※strlen会找到空字符才停下来，因此不能用于不包含空字符的字符数组</span></span><br><span class="line"><span class="built_in">strlen</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较p1p2</span></span><br><span class="line"><span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将p2附加到p1后</span></span><br><span class="line"><span class="built_in">strcat</span>(p1,p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将p2拷贝给p1</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1,p2);</span><br></pre></td></tr></table></div></figure><p>string和c风格字符串的转换：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将string转换为const char</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></div></figure>        <h2 id="vector"   >          <a href="#vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#vector" class="headerlink" title="vector"></a>vector</h2>      <p>vector不是一个类，而是<strong>类模板</strong></p><p>引入：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></div></figure><p>vector包含vector：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//早期版本中右尖括号之间要有空格</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;</span><br></pre></td></tr></table></div></figure>        <h3 id="初始化"   >          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表初始化 c++11,创建一个元素，值为10</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建10个元素，值为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建10个元素，每个值为1</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建2个元素，值分别为10和1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></div></figure>        <h3 id="遍历-2"   >          <a href="#遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范围for语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>范围for语句中不应出现向vector添加元素的语句（遍历序列的大小会改变）</p></blockquote>        <h3 id="迭代器"   >          <a href="#迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3>      <div class="table-container"><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td><code>v.begin()</code></td><td>第一个元素的迭代器</td></tr><tr><td><code>v.end()</code></td><td>尾后迭代器（最后一个元素的后一个位置）</td></tr></tbody></table></div><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    *it...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取中间位置迭代器(返回difference_type，有符号整数)</span></span><br><span class="line"><span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br></pre></td></tr></table></div></figure>        <h2 id="数组"   >          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h2>              <h3 id="初始化-1"   >          <a href="#初始化-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前两个元素初始化为1，2，后面元素为默认值</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></div></figure><blockquote><p>※字符数组可以用字符串字面值初始化，<strong>但字符串末的空字符也会被存入</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[]&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误，&quot;apple&quot;要占6个元素</span></span><br><span class="line"><span class="type">char</span> arr[<span class="number">5</span>] = <span class="string">&quot;apple&quot;</span>;</span><br></pre></td></tr></table></div></figure><p>※不能直接把另一个数组拷贝初始化或赋值</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> a2[] = a;</span><br><span class="line">a2 = a<span class="comment">//(一些编译器支持)</span></span><br></pre></td></tr></table></div></figure></blockquote><p>复杂数组声明：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="comment">//没加括号会报错</span></span><br><span class="line"><span class="comment">//arr大小不是10会报错</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;</span><br></pre></td></tr></table></div></figure><blockquote><p>数组的对象实际上是指向该数组首元素的指针</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">2</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia2的类型被推断为int*</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span><span class="comment">//等价</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(ia)</span><span class="comment">//推断为int[10]</span></span></span><br></pre></td></tr></table></div></figure></blockquote>        <h3 id="遍历-3"   >          <a href="#遍历-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3>      <p>c++11 begin，end：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> *begin = <span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="type">int</span> *end = <span class="built_in">end</span>(arr);<span class="comment">//返回尾元素的下一位置(不能解引用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrdiff_t类型，有符号</span></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr);</span><br></pre></td></tr></table></div></figure>        <h3 id="多维数组"   >          <a href="#多维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3>      <blockquote><p>本质是数组的数组</p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内层花括号可以省略</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="表达式"   >          <a href="#表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1>              <h2 id="算数运算"   >          <a href="#算数运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2>      <p>c++11除法运算int类型，向0取整（直接去除小数部分），且结果的符号看m和n</p><p>m%n如果不等于零，则符号与m相同</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span> % <span class="number">-5</span> == <span class="number">1</span></span><br><span class="line"><span class="number">21</span> / <span class="number">-5</span> == <span class="number">-4</span></span><br><span class="line">    </span><br><span class="line"><span class="number">-21</span> % <span class="number">-8</span> == <span class="number">-5</span></span><br><span class="line"><span class="number">-21</span> / <span class="number">-8</span> == <span class="number">2</span></span><br></pre></td></tr></table></div></figure>        <h3 id="递增递减"   >          <a href="#递增递减" class="heading-link"><i class="fas fa-link"></i></a><a href="#递增递减" class="headerlink" title="递增递减"></a>递增递减</h3>      <blockquote><p>除非必须，否则不用后置递增递减：后置版本需要<strong>额外</strong>将修改前的原始值存储下来</p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter !=v.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">//解引用后递增</span></span><br><span class="line">    cout &lt;&lt;*iter++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="逻辑和关系运算"   >          <a href="#逻辑和关系运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑和关系运算" class="headerlink" title="逻辑和关系运算"></a>逻辑和关系运算</h2>              <h3 id="短路求值"   >          <a href="#短路求值" class="heading-link"><i class="fas fa-link"></i></a><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; ||</span><br></pre></td></tr></table></div></figure>        <h2 id="赋值"   >          <a href="#赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2>      <p>c++新标准：初始值列表</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = &#123;<span class="number">3.14</span>&#125;;<span class="comment">//错误，窄化转换</span></span><br></pre></td></tr></table></div></figure><p>赋值满足<strong>右结合律</strong>：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;<span class="comment">//0赋值给jval,jval赋值给ival</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>;<span class="comment">//错误，pval无法转换为ival</span></span><br></pre></td></tr></table></div></figure>        <h2 id="位运算符"   >          <a href="#位运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2>      <p>位运算符作用于<strong>整数类型</strong>的运算对象</p><div class="table-container"><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td>~</td><td>按位求反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr></tbody></table></div><blockquote><p>位运算符对符号位的处理依赖于机器，因此建议仅用于<strong>无符号类型</strong></p></blockquote>        <h3 id="移位操作"   >          <a href="#移位操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3>      <p>移位运算符满足<strong>左结合律</strong></p><p>优先级比算术运算符低，比关系，赋值，条件运算符高</p>        <h2 id="sizeof"   >          <a href="#sizeof" class="heading-link"><i class="fas fa-link"></i></a><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2>      <p>※<code>sizeof</code>的返回值是<strong>常量表达式</strong>，可以声明数组的维度</p><p>※<code>sizeof</code>中解引用一个无效指针是<strong>安全行为</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(*p); <span class="comment">//即使p指向无效地址也安全，因为sizeof不需要真的解引用指针</span></span><br></pre></td></tr></table></div></figure><p>※对数组名执行<code>sizeof</code>，得到整个数组元素所占空间大小</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算arr中的元素数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> count = <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(*arr);</span><br></pre></td></tr></table></div></figure><p>※对string或vector对象执行<code>sizeof</code>，返回的是<strong>固定部分的大小</strong>，</p><p>不会计算对象中的元素占用空间：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">string b = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">sizeof</span>(a) == <span class="built_in">sizeof</span>(b) == <span class="number">32</span></span><br></pre></td></tr></table></div></figure>        <h2 id="逗号运算符"   >          <a href="#逗号运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2>      <p>※优先级小于赋值符号</p><p>含有两个运算对象，按从左到右的顺序求值，返回的是<strong>右侧表达式的值</strong>：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = (<span class="number">1</span>,<span class="number">2</span>);<span class="comment">// a==2</span></span><br></pre></td></tr></table></div></figure><p>常用在for循环中，用于递增递减两个变量</p>        <h1 id="类型转换"   >          <a href="#类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1>      <blockquote><p>尽量避免强制类型转换</p></blockquote>        <h2 id="隐式转换"   >          <a href="#隐式转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2>      <ul><li>比int小的整型值和char首先提升为较大的整数类型</li><li>在条件表达式中非布尔值转换成布尔类型</li><li>初始化和赋值过程中，右侧对象转换为左侧对象的类型</li><li>用数组名初始化指针</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159L</span> + <span class="string">&#x27;a&#x27;</span><span class="comment">//&#x27;a&#x27;提升成int，然后转化为long double</span></span><br></pre></td></tr></table></div></figure>        <h2 id="显示转换"   >          <a href="#显示转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2>              <h3 id="static-cast"   >          <a href="#static-cast" class="heading-link"><i class="fas fa-link"></i></a><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3>      <p>不包含<code>low-level const</code>的任何具有明确定义的类型转换都可以使用<code>static_cast</code>，使用静态转换时相当于告诉编译器<strong>忽略潜在的精度损失</strong>。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用static_cast还原void*</span></span><br><span class="line"><span class="type">void</span>* p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char*转换为string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;string&gt;(cp);</span><br></pre></td></tr></table></div></figure>        <h3 id="const-cast"   >          <a href="#const-cast" class="heading-link"><i class="fas fa-link"></i></a><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3>      <p><code>const_cast</code>只能改变运算对象的<code>low-level const</code>性质</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></div></figure><p>常用于函数重载中：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将s1,s2转换成const后调用const版本的函数</span></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&gt;(s1),</span><br><span class="line">                           <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>        <h3 id="reinterpret-cast"   >          <a href="#reinterpret-cast" class="heading-link"><i class="fas fa-link"></i></a><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3>      <p>重新解释运算对象的底层位模式</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br><span class="line"><span class="comment">//将*ip的数据解释为char</span></span><br></pre></td></tr></table></div></figure>        <h1 id="异常处理"   >          <a href="#异常处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1>      <ul><li>throw表达式：用于抛出异常（异常检测）。</li><li>try语句块：以<code>try</code>开始，一个或多个<code>catch</code>语句结束。（异常处理）</li><li>一套异常类：用于在<code>throw</code>和<code>try-catch</code>之间传递信息。</li></ul>        <h2 id="throw表达式"   >          <a href="#throw表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>throw</code>表达式抛出异常后，将<strong>终止当前函数，把控制权转移给能处理异常的代码</strong></p>        <h2 id="try语句块"   >          <a href="#try语句块" class="heading-link"><i class="fas fa-link"></i></a><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//执行有可能异常的代码，并抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="built_in">catch</span>(runtime_error e)&#123;</span><br><span class="line">    <span class="comment">//如果抛出了runtime_error,则跳转到该语句块处理</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(异常声明)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>若程序在抛出异常时经过了<strong>多层try语句块</strong>，则会自底向上，不断向调用该函数的函数抛出异常，直到找到匹配的<code>catch</code>语句。</p><p>如果没要找到任何匹配的<code>catch</code>（或没有try语句块），则转到名为<code>terminate</code>的标准库函数，该函数的行为与系统相关，一般导致程序非正常退出（闪退）</p></blockquote>        <h2 id="标准异常类"   >          <a href="#标准异常类" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准异常类" class="headerlink" title="标准异常类"></a>标准异常类</h2>      <div class="table-container"><table><thead><tr><th>&lt;stdexcept&gt;异常类</th><th></th></tr></thead><tbody><tr><td>exception</td><td>最常见的问题</td></tr><tr><td>runtime_error</td><td>运行时才能检测出的问题</td></tr><tr><td>range_error</td><td>运算结果超出了有效值</td></tr><tr><td>overflow_error</td><td>计算上溢</td></tr><tr><td>underflow_error</td><td>计算下溢</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td></tr><tr><td>domain_error</td><td>参数对应的结果值不存在</td></tr><tr><td>invalid_argument</td><td>不合法的参数</td></tr><tr><td>length_error</td><td>试图创建超出最大长度的对象</td></tr><tr><td>out_of_range</td><td>使用一个超出有效范围的值</td></tr></tbody></table></div>        <h1 id="函数"   >          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数" class="headerlink" title="函数"></a>函数</h1>              <h3 id="局部静态对象"   >          <a href="#局部静态对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态变量知道程序终止才销毁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计函数调用次数</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="参数传递"   >          <a href="#参数传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2>              <h3 id="值传递"   >          <a href="#值传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3>      <p>初始化一个非引用类型的形参时，初始值被拷贝，<strong>在函数内的改动不会影响实参本身</strong>。</p>        <h3 id="引用传递"   >          <a href="#引用传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3>      <p>通过引用传递可以在函数内<strong>改变实参本身</strong>，也可以专门用一个参数返回额外信息</p>        <h3 id="引用形参与const"   >          <a href="#引用形参与const" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用形参与const" class="headerlink" title="引用形参与const"></a>引用形参与const</h3>      <p>※可以使用非常量初始化一个底层const对象，但不能用const对象，字面值传给普通的引用形参。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规范传入数组</span></span><br><span class="line"><span class="comment">//传入头尾指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* beg, <span class="type">const</span> <span class="type">int</span>* end)</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入数组和大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> arr[], <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="参数默认值"   >          <a href="#参数默认值" class="heading-link"><i class="fas fa-link"></i></a><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3>      <p>※一旦某个形参有默认值，<strong>后面的所有形参都必须有默认值</strong>。</p>        <h2 id="返回值"   >          <a href="#返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2>      <p>※不要返回局部对象的引用或指针</p>        <h3 id="列表初始化返回值"   >          <a href="#列表初始化返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3>      <p>c++11</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="尾置返回类型"   >          <a href="#尾置返回类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h3>      <p>用于函数<strong>声明</strong>，在形参列表后用箭头声明返回类型，前面用<code>auto</code>。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></div></figure><p>使用<code>decltype</code>也可以声明：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(arr)返回一个大小为3的整形数组，用*转换为指针</span></span><br><span class="line"><span class="keyword">decltype</span>(arr)* <span class="built_in">func</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>        <h2 id="main函数"   >          <a href="#main函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2>              <h3 id="传参"   >          <a href="#传参" class="heading-link"><i class="fas fa-link"></i></a><a href="#传参" class="headerlink" title="传参"></a>传参</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="返回值-1"   >          <a href="#返回值-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3>      <p>main函数如果没有写return语句，编译器将自动插入<code>return 0</code></p><p>main函数的返回值可以看作是状态指示器，返回0表示<strong>执行成功</strong>，返回其他值表示执行失败。</p><p><code>cstdlib</code>定义了两个预处理变量，可以表示执行成功与失败：<code>EXIT_FAILURE</code>，<code>EXIT_SUCCESS</code></p>        <h2 id="函数重载"   >          <a href="#函数重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2>      <p>同一作用域内，<strong>形参列表不同，函数名相同</strong>的函数称之为<strong>重载函数overloaded</strong>。</p><p>※不能只有<strong>返回类型不同</strong>。</p><p>局部函数会覆盖全局函数（一般不在局部作用域声明函数）:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//导致上面两个print均被隐藏</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>c++中先进行名字查找，再类型检查。</p></blockquote>        <h3 id="函数匹配"   >          <a href="#函数匹配" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3>              <h2 id="函数内联"   >          <a href="#函数内联" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h2>      <p>在函数声明的开头标注</p><p>在编译过程中展开函数，用函数体替换函数调用。（提升性能）</p>        <h2 id="常量表达式"   >          <a href="#常量表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2>      <ul><li>函数的返回类型和所有形参都是字面值类型</li><li>函数体有且只有一条return</li></ul><p>编译时，<code>constexpr</code>函数被隐式指定为内联函数，在执行初始化任务时替换为结果值。</p>        <h2 id="函数指针"   >          <a href="#函数指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2>              <h1 id="类"   >          <a href="#类" class="heading-link"><i class="fas fa-link"></i></a><a href="#类" class="headerlink" title="类"></a>类</h1>      <p>※类本身就是一个作用域，类的成员函数的定义嵌套在作用域内。</p><p>※class和struct的唯一区别是默认的访问权限不同。</p><p>※类内定义的函数默认<code>inline</code>。</p><p>类外显示定义类成员函数为<code>inline</code>：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">Screen&amp; <span class="title">Screen::move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回对象本身</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="构造函数"   >          <a href="#构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2>              <h3 id="默认构造函数的作用"   >          <a href="#默认构造函数的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3>      <p>对象被默认初始化或值初始化时，自动执行默认构造函数</p>        <h3 id="手动生成默认构造函数"   >          <a href="#手动生成默认构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#手动生成默认构造函数" class="headerlink" title="手动生成默认构造函数"></a>手动生成默认构造函数</h3>      <p>c++11</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了其他构造函数的情况下，还需要默认构造函数时</span></span><br><span class="line"><span class="built_in">Class</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></div></figure>        <h3 id="初始值列表"   >          <a href="#初始值列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3>      <p>※初始值列表的前后位置关系不会影响初始化顺序，成员的初始化顺序与<strong>类定义中出现的顺序一致</strong>。</p><blockquote><p><strong>必须使用初始值的情况：</strong></p><ul><li>const或引用成员</li><li>类类型，且无默认构造函数的成员</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Class</span>&#123;</span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line">   <span class="type">int</span> &amp;ri;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></div></figure></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Class</span>(): <span class="built_in">var1</span>(value1), <span class="built_in">var2</span>(value2) &#123;&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="委托构造函数"   >          <a href="#委托构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3>      <p>c++11</p><p>可以将构造函数的一部分职责交给其他构造函数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//先执行委托的构造函数的初始值列表和函数体</span></span><br><span class="line">    <span class="comment">//再执行自身构造函数的内容</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(): <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="友元"   >          <a href="#友元" class="heading-link"><i class="fas fa-link"></i></a><a href="#友元" class="headerlink" title="友元"></a>友元</h2>      <p>令其他类或函数成为**友元(friend)**，就可以允许其他类或函数访问<code>private</code>成员。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类外声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></div></figure>        <h2 id="可变成员"   >          <a href="#可变成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#可变成员" class="headerlink" title="可变成员"></a>可变成员</h2>      <p><code>mutable</code>关键字声明的成员属性，可以在<code>const</code>函数内被修改。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="type">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用mutable成员记录函数调用次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="类类型转换"   >          <a href="#类类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#类类型转换" class="headerlink" title="类类型转换"></a>类类型转换</h2>      <p>※隐式转换只会转换一步</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该构造函数会在需要Sales_data类型时，自动将istream类型转换</span></span><br><span class="line"><span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line"></span><br><span class="line">item.<span class="built_in">combine</span>(cin);<span class="comment">//函数接受Sales_data类型，但传入的是istream</span></span><br></pre></td></tr></table></div></figure>        <h3 id="抑制隐式转换"   >          <a href="#抑制隐式转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#抑制隐式转换" class="headerlink" title="抑制隐式转换"></a>抑制隐式转换</h3>      <p>※<code>explicit</code>只对一个实参的构造函数有效</p><p>※只能在类内声明时使用<code>explicit</code>，在类外定义时不使用</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止构造函数的隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br></pre></td></tr></table></div></figure><p>仍然可以显式地转换：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两者都调用构造函数，创建一个临时的Sales_data对象</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(cin));</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></div></figure>        <h2 id="聚合类"   >          <a href="#聚合类" class="heading-link"><i class="fas fa-link"></i></a><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h2>      <p>aggregate class</p><p>满足以下条件的类，称为聚合类：</p><ul><li>所有成员public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，virtual函数</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用初始值列表初始化：</span></span><br><span class="line">Data data = &#123;<span class="number">0</span>, <span class="string">&quot;Vavid&quot;</span>&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="字面值常量类"   >          <a href="#字面值常量类" class="heading-link"><i class="fas fa-link"></i></a><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3>      <p>数据成员都是字面值类型的聚合类<strong>或</strong>满足以下条件的类，称为字面值常量类：</p><ul><li>数据成员都是字面值类型</li><li>含有一个<code>constexpr</code>构造函数，且类成员也有自己的<code>constexpr</code>构造函数</li><li>使用默认析构函数</li></ul>        <h2 id="静态成员"   >          <a href="#静态成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2>      <p>该类的所有对象<strong>共用</strong>类的静态成员。</p>        <h2 id="虚函数"   >          <a href="#虚函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2>      <ul><li>用纯虚函数定义接口，强制子类实现。</li><li>用普通虚函数提供默认行为，子类按需覆盖。</li></ul>        <h1 id="IO库"   >          <a href="#IO库" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1>      <div class="table-container"><table><thead><tr><th>头文件</th><th>类型</th></tr></thead><tbody><tr><td>iostream</td><td>istream：输入流类型<br />ostream：输出流类型<br /></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h1 id="智能指针"   >          <a href="#智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1>              <h2 id="RAII"   >          <a href="#RAII" class="heading-link"><i class="fas fa-link"></i></a><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2>      <p>Resource Acquisition is Initialization ：在对象构造时分配资源，在对象析构时释放资源，使对象在生命周期内始终有效。</p>        <h1 id="调试"   >          <a href="#调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#调试" class="headerlink" title="调试"></a>调试</h1>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未定义NDEBUG时触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">cerr &lt;&lt; _ _func_ _ &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><ul><li><code>_ _func_ _</code>：输出当前调试的函数的名字</li><li><code>_ _FILE_ _</code>：存放文件名的字符串字面值</li><li><code>_ _LINE_ _</code>：存放当前行号的整形字面值</li><li><code>_ _TIME_ _</code>：存放文件编译时间的字符串字面值</li><li><code>_ _DATE_ _</code>：存放文件编译日期的字符串字面值</li></ul>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;Cmake&quot;   &gt;
          &lt;a href=&quot;#Cmake&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Cmake&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://lzmustb.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记</title>
    <link href="https://lzmustb.github.io/2024/12/18/my-OpenGL-notes/"/>
    <id>https://lzmustb.github.io/2024/12/18/my-OpenGL-notes/</id>
    <published>2024-12-18T05:01:42.000Z</published>
    <updated>2025-05-19T13:45:11.778Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link"   href="https://learnopengl-cn.github.io/" >LearnOpenGL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>学习笔记</p><span id="more"></span>        <h1 id="GLFW"   >          <a href="#GLFW" class="heading-link"><i class="fas fa-link"></i></a><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h1>      <p>针对OpenGL的C语言库，提供渲染物体所需的最低限度的接口</p><p>※不同操作系统生成窗口的代码不同</p><p>※不同操作系统鼠标，键盘的响应方式不同</p>        <h2 id="初始化"   >          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://www.glfw.org/docs/latest/window.html#window_hints" >glfwWindowHint配置选项</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//主版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//次版本号</span></span><br><span class="line"><span class="comment">//使用核心模式</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//macOS额外添加：</span></span><br><span class="line"><span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br></pre></td></tr></table></div></figure>        <h2 id="创建窗口"   >          <a href="#创建窗口" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将window作为openGL绘制所用的窗体</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></div></figure>        <h2 id="事件回调"   >          <a href="#事件回调" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件回调" class="headerlink" title="事件回调"></a>事件回调</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口大小改变</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"><span class="comment">//光标位置改变</span></span><br><span class="line"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line"><span class="comment">//鼠标滚动</span></span><br><span class="line"><span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br><span class="line"><span class="comment">//键盘</span></span><br><span class="line"><span class="built_in">glfwSetKeyCallback</span>(window,key_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">//action : GLFW_PRESS/GLFW_RELEASE </span></span><br><span class="line"><span class="comment">//mods   : GLFW_MOD_CONTROL/GLFW_MOD_SHIFT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> key, <span class="type">int</span> scancode, <span class="type">int</span> action, <span class="type">int</span> mods)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == GLFW_KEY_W)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="输入"   >          <a href="#输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入" class="headerlink" title="输入"></a>输入</h2>              <h3 id="键盘绑定"   >          <a href="#键盘绑定" class="heading-link"><i class="fas fa-link"></i></a><a href="#键盘绑定" class="headerlink" title="键盘绑定"></a>键盘绑定</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line"><span class="comment">//glfwGetKey()检查是否按下某个键，返回GLFW_PRESS或GLFW_RELEASE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">cameraPos += cameraSpeed * cameraFront;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="鼠标输入"   >          <a href="#鼠标输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐藏并捕捉光标</span></span><br><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></div></figure><p>计算鼠标输入：</p><ul><li><p>光标初始值设为屏幕中央</p></li><li><p>计算光标距离上一帧的偏移量</p></li><li><p>把偏移量加到摄像机的俯仰角和偏航角中</p></li><li><p>限制转角的最大最小值</p></li><li><p>计算方向向量</p></li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br><span class="line"><span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line"><span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">  pitch =  <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">  pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br></pre></td></tr></table></div></figure>        <h2 id="渲染循环"   >          <a href="#渲染循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算时间</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="type">float</span> currentFrame = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">glfwGetTime</span>());</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染指令</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换缓冲，接受并分发窗口消息</span></span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出程序，释放分配的资源</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></div></figure>        <h1 id="GLAD"   >          <a href="#GLAD" class="heading-link"><i class="fas fa-link"></i></a><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h1>      <p><strong>※<code>#include &lt;glad/glad.h&gt;</code>必须放在所有头文件之前</strong></p><p>根据不同OpenGL版本，获取驱动的函数指针</p>        <h2 id="OpenGL函数加载"   >          <a href="#OpenGL函数加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#OpenGL函数加载" class="headerlink" title="OpenGL函数加载"></a>OpenGL函数加载</h2>      <p>OpenGL是一个规范标准，而不是具体实现</p><p>实现靠各家显卡厂商编写的驱动程序</p><p>程序如果需要运行，就需要向显卡驱动查询函数的具体位置并加载进来</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用GLAD加载OpenGL函数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="gladLoadGLLoader"   >          <a href="#gladLoadGLLoader" class="heading-link"><i class="fas fa-link"></i></a><a href="#gladLoadGLLoader" class="headerlink" title="gladLoadGLLoader"></a>gladLoadGLLoader</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gladLoadGLLoader</span><span class="params">(GLADloadproc load)</span> </span>&#123;</span><br><span class="line">GLVersion.major = <span class="number">0</span>; GLVersion.minor = <span class="number">0</span>;</span><br><span class="line">glGetString = (PFNGLGETSTRINGPROC)<span class="built_in">load</span>(<span class="string">&quot;glGetString&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(glGetString == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">glGetString</span>(GL_VERSION) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">find_coreGL</span>(); <span class="comment">//标识需要支持的版本号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将需要支持的版本中的函数都加载进来</span></span><br><span class="line"><span class="built_in">load_GL_VERSION_1_0</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_1_1</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_1_2</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_1_3</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_1_4</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_1_5</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_2_0</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_2_1</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_3_0</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_3_1</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_3_2</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_3_3</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_0</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_1</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_2</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_3</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_4</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_5</span>(load);</span><br><span class="line"><span class="built_in">load_GL_VERSION_4_6</span>(load);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">find_extensionsGL</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> GLVersion.major != <span class="number">0</span> || GLVersion.minor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="OpenGL"   >          <a href="#OpenGL" class="heading-link"><i class="fas fa-link"></i></a><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1>              <h2 id="初始化-1"   >          <a href="#初始化-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置视口大小</span></span><br><span class="line"><span class="built_in">glViewport</span>(GLint x,GLint y, GLsizei width, GLsizei height);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置清理颜色</span></span><br><span class="line"><span class="built_in">glClearColor</span>(r,g,b,a);</span><br></pre></td></tr></table></div></figure>        <h2 id="错误检查与封装"   >          <a href="#错误检查与封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#错误检查与封装" class="headerlink" title="错误检查与封装"></a>错误检查与封装</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查之前的函数调用，并返回最新的一个错误码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkError</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GLenum errorCode = <span class="built_in">glGetError</span>();</span><br><span class="line"><span class="keyword">if</span>(errorCode != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>); <span class="comment">//中断程序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义宏,在调用GL函数后自动调用检错</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_CALL(func) func;checkError();</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_CALL(func) func;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmake预编译宏</span></span><br><span class="line"><span class="built_in">add_definitions</span>(-DDEBUG)</span><br></pre></td></tr></table></div></figure>        <h2 id="封装窗体类"   >          <a href="#封装窗体类" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装窗体类" class="headerlink" title="封装窗体类"></a>封装窗体类</h2>              <h3 id="单例模式"   >          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3>      <ul><li>静态成员实例指针</li><li>私有构造函数</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Application</span>();</span><br><span class="line">    <span class="function"><span class="type">static</span> Application* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Application* mInstance;</span><br><span class="line">    <span class="built_in">Application</span>();</span><br><span class="line">    <span class="type">uint32_t</span> mWidth&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> mHeight&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GLFWwindow* mWindow&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> app Application::getInstance();</span></span><br></pre></td></tr></table></div></figure>        <h3 id="对外接口"   >          <a href="#对外接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3>      <ul><li>init：设置初始信息，生成窗体，载入openGL函数</li><li>update：更新双缓存，接受并分发窗体消息</li><li>destroy：退出程序</li></ul>        <h3 id="回调函数"   >          <a href="#回调函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3>      <p>用函数指针成员存储回调函数</p><ul><li>声明一个函数指针</li><li>声明一个Callback成员变量</li><li>声明一个<code>static</code>的GLFW注册回调函数</li></ul>        <h2 id="坐标系统"   >          <a href="#坐标系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2>      <p>右手系</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems_right_handed.png" alt="coordinate_systems_right_handed"></p>        <h3 id="纹理"   >          <a href="#纹理" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3>      <p>左下角为 (0, 0)</p>        <h3 id="坐标空间"   >          <a href="#坐标空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h3>      <p>顶点着色器→</p><ul><li><p>物体空间&#x2F;局部空间 （object&#x2F;local space）</p></li><li><p>世界空间（world space）</p></li><li><p>观察空间（view space）</p></li><li><p>裁剪空间（clip space）</p><ul><li>-1~1，并舍弃视角外的物体</li></ul></li><li><p>屏幕空间（screen space）</p><ul><li>将-1~1的范围变换到<code>glViewport</code>定义的坐标范围内</li></ul></li></ul><p>→光栅化rasterizer</p><p>不同坐标空间变换的过程：</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p>        <h2 id="图元"   >          <a href="#图元" class="heading-link"><i class="fas fa-link"></i></a><a href="#图元" class="headerlink" title="图元"></a>图元</h2>      <div class="table-container"><table><thead><tr><th>类型</th><th></th></tr></thead><tbody><tr><td>GL_POINTS</td><td></td></tr><tr><td>GL_TRIANGLES</td><td></td></tr><tr><td>GL_LINE_STRIP</td><td></td></tr></tbody></table></div>        <h2 id="GPU显存对象"   >          <a href="#GPU显存对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPU显存对象" class="headerlink" title="GPU显存对象"></a>GPU显存对象</h2>              <h3 id="绑定"   >          <a href="#绑定" class="heading-link"><i class="fas fa-link"></i></a><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3>      <p>将某个资源与OpenGL状态机中某个状态<strong>插槽</strong>进行关联</p><p>每个插槽每个时刻只有一个资源被绑定</p><p><img src="/../images/image-20241227134149501.png" alt="image-20241227134149501"></p><p>插槽：</p><div class="table-container"><table><thead><tr><th>GLenum</th><th></th></tr></thead><tbody><tr><td>GL_ARRAY_BUFFER</td><td>当前VBO</td></tr><tr><td>GL_ELEMENT_ARRAY_BUFFER</td><td>EBO</td></tr><tr><td>GL_TEXTURE_2D</td><td></td></tr></tbody></table></div>        <h3 id="VBO"   >          <a href="#VBO" class="heading-link"><i class="fas fa-link"></i></a><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3>      <p>vertex buffer object：表示在GPU显存上的一段存储空间对象，在c++中，用<code>unsigned int</code>类型存储它的ID。</p><p><img src="/../images/image-20241227133016316.png" alt="image-20241227133016316"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建VBO,将GPU分配的编号存入vboID中(还没有真正分配显存)</span></span><br><span class="line">GLuint vboID = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vboID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建多个vbo</span></span><br><span class="line">GLuint vboArr[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">3</span>, vboArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;vboID);</span><br><span class="line"><span class="built_in">glDeleteBuffers</span>(<span class="number">3</span>, vboArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定插槽</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vboID);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//向插槽绑定的空间填充数据(分配显存)</span></span><br><span class="line"><span class="comment">//第四个参数：指定显卡管理数据的方式</span></span><br><span class="line"><span class="comment">//GL_STATIC_DRAW:数据几乎不变</span></span><br><span class="line"><span class="comment">//GL_DYNAMIC_DRAW:数据会被改变很多</span></span><br><span class="line"><span class="comment">//GL_STREAM_DRAW:数据每次绘制都改变</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></div></figure>        <h4 id="多属性存储"   >          <a href="#多属性存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#多属性存储" class="headerlink" title="多属性存储"></a>多属性存储</h4>      <p>singleBuffer 策略：每个属性存储为一个vbo</p><p>interleavedBuffer 策略：将所有属性存在一个vbo，数据交叉存储</p>        <h3 id="VAO"   >          <a href="#VAO" class="heading-link"><i class="fas fa-link"></i></a><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3>      <p>Vertex Array Object, VAO</p><p>存放一个Mesh网格的顶点描述信息，<code>core</code>模式要求使用VAO。</p><p>存储的内容：</p><ul><li><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 的调用</li><li><code>glVertexAttribPointer</code> 设置的顶点属性配置</li><li>通过 <code>glVertexAttribPointer</code> 调用顶点缓冲对象</li></ul><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" alt="img"></p>        <h4 id="Single-buffer"   >          <a href="#Single-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#Single-buffer" class="headerlink" title="Single buffer"></a>Single buffer</h4>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===创建</span></span><br><span class="line">GLuint VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===销毁</span></span><br><span class="line"><span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---绑定VBO，接下来VAO的操作从该VBO读取</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===激活VAO的0号位</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===设置顶点属性指针</span></span><br><span class="line"><span class="comment">//index：描述第几个属性</span></span><br><span class="line"><span class="comment">//size：属性包含几个变量</span></span><br><span class="line"><span class="comment">//type：每个变量的数据类型</span></span><br><span class="line"><span class="comment">//normalized：是否需要归一化</span></span><br><span class="line"><span class="comment">//stride：整个顶点数据的步长</span></span><br><span class="line"><span class="comment">//offset：这个属性在顶点数据中的偏移量</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---绑定下一个VBO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===激活VAO的1号位</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===设置第二个属性（由于在不同VBO，偏移量还是0）</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===解绑VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h4 id="interleaved-buffer"   >          <a href="#interleaved-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#interleaved-buffer" class="headerlink" title="interleaved buffer"></a>interleaved buffer</h4>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===创建</span></span><br><span class="line">GLuint VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===销毁</span></span><br><span class="line"><span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---绑定VBO，接下来VAO的操作从该VBO读取</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===激活VAO的0号位置（对应shader的location）</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===设置顶点属性指针</span></span><br><span class="line"><span class="comment">//index：描述第几个属性</span></span><br><span class="line"><span class="comment">//size：属性包含几个变量</span></span><br><span class="line"><span class="comment">//type：每个变量的数据类型</span></span><br><span class="line"><span class="comment">//normalized：是否需要归一化</span></span><br><span class="line"><span class="comment">//stride：整个顶点数据的步长</span></span><br><span class="line"><span class="comment">//offset：这个属性在顶点数据中的偏移量</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===激活VAO的1号位</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===设置第二个属性（在相同VBO内，要设置偏移量）</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//===解绑VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h3 id="EBO"   >          <a href="#EBO" class="heading-link"><i class="fas fa-link"></i></a><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h3>      <p>Element Buffer Object，EBO </p><p>又称索引缓冲对象(Index Buffer Object，IBO)</p><blockquote><p>绑定VAO后再绑定EBO或VBO，都会记录到当前VAO中</p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;mEbo);</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;mVao);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(mVao);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, mEbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, mVbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h4 id="绘制"   >          <a href="#绘制" class="heading-link"><i class="fas fa-link"></i></a><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mode: GL_TRIANGLES,GL_LINES</span></span><br><span class="line"><span class="comment">//count: 使用索引数组中几个索引</span></span><br><span class="line"><span class="comment">//type: 索引的数据类型</span></span><br><span class="line"><span class="comment">//indices: </span></span><br><span class="line"><span class="comment">//①使用了EBO：数组内偏移量（一般传入0）</span></span><br><span class="line"><span class="comment">//②没使用EBO：直接传入索引数组（效率较低）</span></span><br><span class="line"><span class="built_in">glDrawElements</span>()</span><br></pre></td></tr></table></div></figure>        <h2 id="摄像机"   >          <a href="#摄像机" class="heading-link"><i class="fas fa-link"></i></a><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2>      <p><strong>摄像机决定了MVP中的projection和view矩阵</strong></p><ul><li><p>位置</p></li><li><p>方向</p><p>通过 UP × 相机方向 得到右轴，</p><p>再通过 相机方向 × 右轴 得到正交的上轴。</p></li></ul><p><img src="https://learnopengl-cn.github.io/img/01/09/camera_axes.png" alt="img"></p><p>创建LookAt矩阵：（P为摄像机位置）（坐标轴变换+平移）</p><p><img src="/../images/image-20241222155156460.png" alt="image-20241222155156460"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLM:</span></span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, <span class="comment">//位置</span></span><br><span class="line">                  cameraPos + cameraFront, <span class="comment">//目标点</span></span><br><span class="line">                  cameraUp); <span class="comment">//上向量</span></span><br></pre></td></tr></table></div></figure><ul><li>角度</li></ul><p>欧拉角：</p><p><img src="https://learnopengl-cn.github.io/img/01/09/camera_pitch_yaw_roll.png" alt="img"></p><p>摄像机方向向量：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br></pre></td></tr></table></div></figure>        <h2 id="光照"   >          <a href="#光照" class="heading-link"><i class="fas fa-link"></i></a><a href="#光照" class="headerlink" title="光照"></a>光照</h2>      <p>phong 光照模型：</p><p><img src="/../images/3ca691007cece010fad8ddf4ba92572.png" alt="3ca691007cece010fad8ddf4ba92572"></p>        <h3 id="光照贴图"   >          <a href="#光照贴图" class="heading-link"><i class="fas fa-link"></i></a><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3>      <ul><li>漫反射贴图</li><li>镜面光贴图</li></ul>        <h2 id="测试"   >          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试" class="headerlink" title="测试"></a>测试</h2>              <h3 id="深度测试"   >          <a href="#深度测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在每一帧清除缓冲</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用写入（只测试）</span></span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度测试运算符</span></span><br><span class="line"><span class="built_in">glDepthFunc</span>(GL_LESS);</span><br></pre></td></tr></table></div></figure><p>深度测试运算符选项：</p><ul><li>GL_ALWAYS</li><li>GL_NEVER</li><li>GL_LESS：片段深度值<strong>小于</strong>缓冲深度值通过（默认）</li><li>GL_EQUAL</li><li>GL_LEQUAL</li><li>GL_GREATER</li><li>GL_NOTEQUAL</li><li>GL_GEQUAL</li></ul><p>在片元着色器中访问：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//内建向量gl_FragCoord.z</span></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="built_in">vec3</span>(gl_FragCoord.z), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="模板测试"   >          <a href="#模板测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除缓冲</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置掩码</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>);  <span class="comment">//全部位写入</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>);  <span class="comment">//全部位禁用 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="comment">//参数1：使用的运算符</span></span><br><span class="line"><span class="comment">//参数2：比较值</span></span><br><span class="line"><span class="comment">//参数3：掩码</span></span><br><span class="line"><span class="comment">//通过测试，则绘制该像素</span></span><br><span class="line"><span class="built_in">glStencilFunc</span>(GLenum func, GLint ref, GLuint mask)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//更新模板缓冲值</span></span><br><span class="line"><span class="comment">//参数1：模板测试失败时的行为</span></span><br><span class="line"><span class="comment">//参数2：模板测试通过，深度测试失败时的行为 </span></span><br><span class="line"><span class="comment">//参数3：模板，深度测试均通过的行为    </span></span><br><span class="line"><span class="built_in">glStencilOp</span>(GLenum sfail, GLenum dpfail, GLenum dppass)    </span><br></pre></td></tr></table></div></figure><p>模板缓冲更新选项：</p><ul><li>GL_KEEP：保持不变（默认）</li><li>GL_ZERO：置0</li><li>GL_REPLACE：替换为ref值</li><li>GL_INCR：加1</li><li>GL_INCR_WRAP：加1，且循环</li><li>GL_DECR：减1</li><li>GL_DECR_WRAP：减1，且循环</li><li>GL_INVERT：按位反转</li></ul>        <h2 id="面剔除"   >          <a href="#面剔除" class="heading-link"><i class="fas fa-link"></i></a><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2>      <p>通过分析三角形的<strong>环绕顺序</strong>，判断正面，背面</p><p><img src="https://learnopengl-cn.github.io/img/04/04/faceculling_frontback.png" alt="img"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//剔除的面 ： GL_BACK/GL_FRONT/GL_FRONT_AND_BACK</span></span><br><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义环绕方向 ：GL_CCW 逆时针，GL_CW 顺时针</span></span><br><span class="line"><span class="comment">//将逆时针的面定义为正向面↓</span></span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br></pre></td></tr></table></div></figure>        <h2 id="帧缓冲"   >          <a href="#帧缓冲" class="heading-link"><i class="fas fa-link"></i></a><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建帧缓冲对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="comment">//GL_FRAMEBUFFER: 读写操作</span></span><br><span class="line"><span class="comment">//GL_READ_FRAMEBUFFER: 只读</span></span><br><span class="line"><span class="comment">//GL_DRAW_FRAMEBUFFER: 只写</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fbo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断帧缓冲是否完整</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></div></figure><p>完整的帧缓冲要满足以下条件：</p><ul><li>附加至少一个缓冲（颜色，深度，或模板缓冲）</li><li>至少有一个颜色附件（Attachment）</li><li>所有的附件都必须是完整的（保留了内存）</li><li>每个缓冲都应该有相同的样本数（sample）</li></ul>        <h3 id="渲染纹理"   >          <a href="#渲染纹理" class="heading-link"><i class="fas fa-link"></i></a><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h3>      <p>把一个纹理附加到帧缓冲，可以让渲染的结果写入这个纹理。</p><p>※帧缓冲中需要显式绑定深度缓冲，才能让渲染纹理的深测试生效</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//data参数传入NULL</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//附加到帧缓冲上</span></span><br><span class="line"><span class="comment">//参数1：帧缓冲目标</span></span><br><span class="line"><span class="comment">//参数2：附加类型</span></span><br><span class="line"><span class="comment">//参数3：纹理类型</span></span><br><span class="line"><span class="comment">//参数4：纹理本身</span></span><br><span class="line"><span class="comment">//参数5：mipmap level</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h2 id="绘制流程"   >          <a href="#绘制流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2>              <h3 id="编译着色器"   >          <a href="#编译着色器" class="heading-link"><i class="fas fa-link"></i></a><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//着色器源码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建着色器函数glCreateShader(着色器类型)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定着色器源码glShaderSource(目标着色器, 源码字符串数量, 源码， )</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br></pre></td></tr></table></div></figure><ul><li>检测编译是否成功</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  success;</span><br><span class="line"><span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="链接"   >          <a href="#链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#链接" class="headerlink" title="链接"></a>链接</h3>      <p>将多个着色器链接乘着色器程序对象。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，会报错。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">//返回一个ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//附加着色器，链接成程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活程序对象</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接后删除着色器对象</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></div></figure><ul><li>链接顶点属性</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1：对应layout(location),顶点属性的位置值</span></span><br><span class="line"><span class="comment">//参数2：顶点属性的大小，vec3即为3</span></span><br><span class="line"><span class="comment">//参数3：指定数据类型 (vec*均为GL_FLOAT)</span></span><br><span class="line"><span class="comment">//参数4：是否归一化数据(开启后，映射到0~1之间/有符号-1~1)</span></span><br><span class="line"><span class="comment">//参数5：步长，即链接的顶点属性组之间的间隔</span></span><br><span class="line"><span class="comment">//参数6：位置数据在缓冲中起始位置的偏移量，类型转换为void*</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">//启用顶点属性</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h3 id="绘制-1"   >          <a href="#绘制-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#绘制-1" class="headerlink" title="绘制"></a>绘制</h3>      <ul><li>准备<strong>几何数据(vao,vbo)<strong>，</strong>材质数据(shader)</strong></li><li>设置接下来绘制所使用的shader和vao</li><li>发出<strong>DrawCall</strong></li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置所使用的Shader程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(ProgramID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置所使用的VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vaoID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发出渲染指令（绘制VAO）</span></span><br><span class="line"><span class="comment">//mode:GL_TRIANGLES,GL_LINES</span></span><br><span class="line"><span class="comment">//first:从当前第几个顶点开始绘制</span></span><br><span class="line"><span class="comment">//count:绘制几个顶点</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></div></figure>        <h4 id="绘制模式"   >          <a href="#绘制模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#绘制模式" class="headerlink" title="绘制模式"></a>绘制模式</h4>      <div class="table-container"><table><thead><tr><th>绘制模式</th><th></th></tr></thead><tbody><tr><td>GL_TRIANGLES</td><td>每三个顶点连成三角形，不足3个则忽略，每个点只用一次</td></tr><tr><td>GL_TRIANGLE_STRIP</td><td>复用连接过的点</td></tr><tr><td>GL_TRIANGLE_FAN</td><td>以0为起点，每两个点都与0号点连接</td></tr><tr><td>GL_LINES</td><td>每两个定点构成直线，每个点只用一次</td></tr><tr><td>GL_LINE_STRIP</td><td>所有点依次连接</td></tr></tbody></table></div><p>GL_TRIANGLE_STRIP：（保证每个三角形的连接方向都相同）</p><p><img src="/../images/image-20241228131532564.png" alt="image-20241228131532564"></p><p>GL_TRIANGLE_FAN：</p><p><img src="/../images/image-20241228131615993.png" alt="image-20241228131615993"></p>        <h2 id="着色器类的封装"   >          <a href="#着色器类的封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#着色器类的封装" class="headerlink" title="着色器类的封装"></a>着色器类的封装</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span>; <span class="comment">// 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    GLuint ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> <span class="type">char</span>* vertexPath, <span class="type">const</span> <span class="type">char</span>* fragmentPath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用/取消使用程序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// uniform工具函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">bool</span> value)</span> <span class="type">const</span></span>;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> value)</span> <span class="type">const</span></span>;   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">float</span> value)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>        <h3 id="构造函数"   >          <a href="#构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Shader</span>(<span class="type">const</span> <span class="type">char</span>* vertexPath, <span class="type">const</span> <span class="type">char</span>* fragmentPath)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    std::string vertexCode;</span><br><span class="line">    std::string fragmentCode;</span><br><span class="line">    std::ifstream vShaderFile;</span><br><span class="line">    std::ifstream fShaderFile;</span><br><span class="line">    <span class="comment">// 保证ifstream对象可以抛出异常：</span></span><br><span class="line">    vShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    fShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        vShaderFile.<span class="built_in">open</span>(vertexPath);</span><br><span class="line">        fShaderFile.<span class="built_in">open</span>(fragmentPath);</span><br><span class="line">        std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">        <span class="comment">// 读取文件的缓冲内容到数据流中</span></span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.<span class="built_in">rdbuf</span>();       </span><br><span class="line">        <span class="comment">// 关闭文件处理器</span></span><br><span class="line">        vShaderFile.<span class="built_in">close</span>();</span><br><span class="line">        fShaderFile.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 转换数据流到string</span></span><br><span class="line">        vertexCode   = vShaderStream.<span class="built_in">str</span>();</span><br><span class="line">        fragmentCode = fShaderStream.<span class="built_in">str</span>();     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::ifstream::failure e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br><span class="line">    [...]</span><br></pre></td></tr></table></div></figure>        <h2 id="纹理-1"   >          <a href="#纹理-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理-1" class="headerlink" title="纹理"></a>纹理</h2>              <h3 id="stbImage库"   >          <a href="#stbImage库" class="heading-link"><i class="fas fa-link"></i></a><a href="#stbImage库" class="headerlink" title="stbImage库"></a>stbImage库</h3>      <p>读取图片：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width, height, channels;</span><br><span class="line"><span class="comment">//stbi_load(相对文件路径，图片宽度，图片高度，读取的格式，输出的格式)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* data = <span class="built_in">stbi_load</span>(<span class="string">&quot;assets/textures/container.jpg&quot;</span>, &amp;width, &amp;height, &amp;channels, STBI_rgb_alpha);</span><br><span class="line"></span><br><span class="line"><span class="comment">//载入时翻转y轴</span></span><br><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></div></figure>        <h2 id="纹理单元"   >          <a href="#纹理单元" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h2>      <p>采样器和纹理对象的中间层</p><p>至少有0~15号</p><p><img src="/../images/image-20241229132512504.png" alt="image-20241229132512504"></p>        <h3 id="纹理采样"   >          <a href="#纹理采样" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h3>      <blockquote><p>激活纹理单元后绑定纹理对象，可以将对象与单元连接</p><p>(如果不先激活，默认激活0号单元)</p><p>※激活纹理单元无法关闭，只能激活其他纹理单元</p></blockquote><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建纹理对象（与VBO类似）</span></span><br><span class="line"><span class="comment">//个数，ID数组</span></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>，&amp;texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//激活纹理单元</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//绑定纹理对象到状态机插槽</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟显存，传输数据</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(</span><br><span class="line">GLenum target,<span class="comment">//目标插槽</span></span><br><span class="line">    GLint level,<span class="comment">//mipmap层级</span></span><br><span class="line">    GLint internalformat,<span class="comment">//目标在显存中的图片格式（GL_RGBA）</span></span><br><span class="line">    GLsizei width, GLsizei height,<span class="comment">//宽高</span></span><br><span class="line">    GLint border,<span class="comment">//填0</span></span><br><span class="line">    GLenum format,<span class="comment">//内存中的图片格式（GL_RGBA）</span></span><br><span class="line">    GLenum type,<span class="comment">//每个通道的数据格式（GL_UNSIGNED_BYTE）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *pixels<span class="comment">//原始数据指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>        <h3 id="纹理过滤"   >          <a href="#纹理过滤" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3>      <p>设置纹理过滤方式：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,<span class="comment">//目标插槽</span></span><br><span class="line">                GL_TEXTURE_MIN_FILTER <span class="comment">//放大还是缩小过滤</span></span><br><span class="line">                ↑<span class="keyword">or</span>↓</span><br><span class="line">                GL_TEXTURE_MAG_FILTER,</span><br><span class="line">                GL_LINEAR<span class="comment">//过滤方式</span></span><br><span class="line">               );</span><br></pre></td></tr></table></div></figure>        <h4 id="Nearest"   >          <a href="#Nearest" class="heading-link"><i class="fas fa-link"></i></a><a href="#Nearest" class="headerlink" title="Nearest"></a>Nearest</h4>      <p><code>GL_NEAREST</code></p><p>临近过滤（nearest neighbor filtering）：取最近像素值</p><p>复用像素，变成像素画的风格</p><p><strong>缩小过滤使用</strong></p>        <h4 id="Bilinear"   >          <a href="#Bilinear" class="heading-link"><i class="fas fa-link"></i></a><a href="#Bilinear" class="headerlink" title="Bilinear"></a>Bilinear</h4>      <p><code>GL_LINEAR</code></p><p>双线性插值过滤：用周围4个像素颜色计算加权平均</p><p><strong>放大过滤使用</strong></p>        <h4 id="Mipmap"   >          <a href="#Mipmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h4>      <p><code>GL_LINEAR</code>：在层级内用插值</p><p><code>MIPMAP_NEAREST</code>：在不同层级间选择邻近的层级</p><p><code>GL_NEAREST</code>：在层级内用邻近采样</p><p><code>MIPMAP_LINEAR</code>：在不同层级间取插值</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置后自动采样mipmap（不需要在shader中手动写）</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,</span><br><span class="line">                GL_TEXTURE_MIN_FILTER,</span><br><span class="line">                GL_NEAREST_MIPMAP_LINEAR</span><br><span class="line">               );</span><br></pre></td></tr></table></div></figure><p>※mipmap只能用于<strong>缩小过滤</strong></p><p><strong>①</strong> mipmap的生成：</p><ul><li>滤波（模糊处理）</li><li>采样</li></ul><p>离散高斯核心：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.09474</span>, <span class="number">0.11832</span>, <span class="number">0.09474</span>,</span><br><span class="line"> <span class="number">0.11831</span>, <span class="number">0.14776</span>, <span class="number">0.11831</span>,</span><br><span class="line"> <span class="number">0.09474</span>, <span class="number">0.11832</span>, <span class="number">0.09474</span>]</span><br></pre></td></tr></table></div></figure><p><strong>②</strong> 距离判定：</p><blockquote><p>在片元着色器中，并不是每个片元单独处理，而是打包成2*2的区块进行处理。</p><p>因此可以通过偏导函数得到某个属性的<strong>变化量</strong>：</p><p><code>dFdx()</code>，<code>dFdy()</code></p><p>当纹理需要缩小到<strong>1个像素对应n*n个纹素</strong>，需要采样log<del>2</del>(n)级mipmap。</p><p>如果长宽<strong>不等比</strong>缩放，采样较高级别的mipmap</p><p>或在两个方向上分别采样mipmap</p></blockquote><figure class="highlight glsl"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--手动在shader中实现mipmap采样--</span></span><br><span class="line"><span class="comment">//获取当前像素中心点对应纹理的坐标</span></span><br><span class="line"><span class="type">vec2</span> <span class="keyword">location</span> = uv*<span class="type">vec2</span>(textureWidth, textureHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取坐标在周边像素的变化量，即两个片元跨过的纹素</span></span><br><span class="line"><span class="type">vec2</span> dx = <span class="built_in">dFdx</span>(<span class="keyword">location</span>);</span><br><span class="line"><span class="type">vec2</span> dy = <span class="built_in">dFdy</span>(<span class="keyword">location</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求level,L&lt;0,图片被放大，不考虑mipmap</span></span><br><span class="line"><span class="type">float</span> maxDelta = <span class="built_in">sqrt</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(dx,dx),<span class="built_in">dot</span>(dy,dy)));</span><br><span class="line"><span class="type">float</span> L = <span class="built_in">log2</span>(maxDelta);</span><br><span class="line"><span class="type">int</span> level = <span class="built_in">max</span>(<span class="type">int</span>(L+<span class="number">0.5</span>),<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>③OpenGL载入：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动传入</span></span><br><span class="line"><span class="comment">//在level中传入0以上的数字，自动开启mipmap，需要添加到1x1的图像</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动生成</span></span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,</span><br><span class="line">                GL_TEXTURE_MIN_FILTER,</span><br><span class="line">                GL_NEAREST_MIPMAP_LINEAR</span><br><span class="line">               );</span><br></pre></td></tr></table></div></figure>        <h3 id="Wrapping"   >          <a href="#Wrapping" class="heading-link"><i class="fas fa-link"></i></a><a href="#Wrapping" class="headerlink" title="Wrapping"></a>Wrapping</h3>      <ul><li><code>GL_REPEAT</code>：重复</li><li><code>GL_MIRRORED_REPEAT</code>：镜像重复</li><li><code>GL_CLAMP_TO_EDGE</code>：复用边缘颜色</li><li><code>GL_CLAMP_TO_BORDER</code>：设置一个颜色</li></ul><p>设置Wrapping：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,<span class="comment">//目标插槽</span></span><br><span class="line">                GL_TEXTURE_WRAP_S <span class="comment">//横向pr纵向</span></span><br><span class="line">                ↑<span class="keyword">or</span>↓</span><br><span class="line">                GL_TEXTURE_WRAP_T,</span><br><span class="line">                GL_REPEAT<span class="comment">//wrap方式</span></span><br><span class="line">               );</span><br></pre></td></tr></table></div></figure>        <h3 id="采样器"   >          <a href="#采样器" class="heading-link"><i class="fas fa-link"></i></a><a href="#采样器" class="headerlink" title="采样器"></a>采样器</h3>      <p>shader中：</p><figure class="highlight glsl"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> mainTex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="comment">//采样</span></span><br><span class="line">    FragColor = <span class="built_in">texture</span>(mainTex, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>程序中：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向sampler的location传入纹理单元的编号</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(mainTexLocation,<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h2 id="CubeMap"   >          <a href="#CubeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#CubeMap" class="headerlink" title="CubeMap"></a>CubeMap</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动采样来自不同面的临近点</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br></pre></td></tr></table></div></figure>        <h3 id="环境渲染"   >          <a href="#环境渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境渲染" class="headerlink" title="环境渲染"></a>环境渲染</h3>      <p>①最先渲染环境，且不写入深度缓冲</p><p>缺点：被物体遮挡的环境依然会被渲染</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line"><span class="comment">// draw background</span></span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_TRUE);</span><br><span class="line"><span class="comment">// draw objects</span></span><br></pre></td></tr></table></div></figure><p>②屏幕空间渲染背景</p>        <h1 id="Assimp"   >          <a href="#Assimp" class="heading-link"><i class="fas fa-link"></i></a><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h1>      <p><strong>Open Asset Import Library</strong></p><p><img src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img"></p>        <h3 id="Mesh"   >          <a href="#Mesh" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  网格数据  */</span></span><br><span class="line">        vector&lt;Vertex&gt; vertices;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">        vector&lt;Texture&gt; textures;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="built_in">Mesh</span>(vector&lt;Vertex&gt; vertices, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices, vector&lt;Texture&gt; textures);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  渲染数据  */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> VAO, VBO, EBO;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setupMesh</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于struct在内存上连续分布，可以直接传入buffer</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, vertices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, indices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), </span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点位置</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 顶点法线</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Normal));</span><br><span class="line">    <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        string number;</span><br><span class="line">        string name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">&quot;texture_diffuse&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;texture_specular&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader.<span class="built_in">setInt</span>((<span class="string">&quot;material.&quot;</span> + name + number).<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, indices.<span class="built_in">size</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Model"   >          <a href="#Model" class="heading-link"><i class="fas fa-link"></i></a><a href="#Model" class="headerlink" title="Model"></a>Model</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        <span class="built_in">Model</span>(<span class="type">char</span> *path)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">loadModel</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;   </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  模型数据  */</span></span><br><span class="line">        vector&lt;Mesh&gt; meshes;</span><br><span class="line">        string directory;</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">loadModel</span><span class="params">(string path)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="type">const</span> aiScene *scene)</span></span>;</span><br><span class="line">        <span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh *mesh, <span class="type">const</span> aiScene *scene)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;Texture&gt; <span class="title">loadMaterialTextures</span><span class="params">(aiMaterial *mat, aiTextureType type, </span></span></span><br><span class="line"><span class="params"><span class="function">                                             string typeName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader &amp;shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; meshes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        meshes[i].<span class="built_in">Draw</span>(shader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadModel</span><span class="params">(string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assimp::Importer <span class="keyword">import</span>;</span><br><span class="line">    <span class="type">const</span> aiScene *scene = <span class="keyword">import</span>.<span class="built_in">ReadFile</span>(path, aiProcess_Triangulate | aiProcess_FlipUVs);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR::ASSIMP::&quot;</span> &lt;&lt; <span class="keyword">import</span>.<span class="built_in">GetErrorString</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    directory = path.<span class="built_in">substr</span>(<span class="number">0</span>, path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processNode</span>(scene-&gt;mRootNode, scene);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归处理网格可以定义网格间的父子关系，方便一并变换所有子网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="type">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理节点所有的网格（如果有的话）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; </span><br><span class="line">        meshes.<span class="built_in">push_back</span>(<span class="built_in">processMesh</span>(mesh, scene));         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来对它的子节点重复这一过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processNode</span>(node-&gt;mChildren[i], scene);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh *mesh, <span class="type">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">    vector&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex vertex;</span><br><span class="line">        <span class="comment">// 处理顶点位置、法线和纹理坐标</span></span><br><span class="line">        ...</span><br><span class="line">        vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理索引</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理材质</span></span><br><span class="line">    <span class="keyword">if</span>(mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mesh</span>(vertices, indices, textures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Assimp加载模型"   >          <a href="#Assimp加载模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Assimp加载模型" class="headerlink" title="Assimp加载模型"></a>Assimp加载模型</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assimp::Importer importer;</span><br><span class="line"><span class="type">const</span> aiScene *scene = importer.<span class="built_in">ReadFile</span>(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br></pre></td></tr></table></div></figure><p>常用选项：</p><ul><li>aiProcess_Triangulate：将所有图元转换为三角形</li><li>aiProcess_FlipUVs：反转y轴纹理坐标</li><li>aiProcess_GenNormals：如果模型不包含法向量，就创建法线</li><li>aiProcess_SplitLargeMeshes：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。</li><li>aiProcess_OptimizeMeshes：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</li></ul>        <h1 id="GLSL"   >          <a href="#GLSL" class="heading-link"><i class="fas fa-link"></i></a><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1>              <h2 id="基本结构"   >          <a href="#基本结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2>      <p><code>location=n</code>表示去VAO的第n个属性去取数据</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>)in type in_variable_name;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>)in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="内置变量"   >          <a href="#内置变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2>      <div class="table-container"><table><thead><tr><th>内置变量</th><th></th></tr></thead><tbody><tr><td>gl_Position</td><td>NDC坐标</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h2 id="编译Shader"   >          <a href="#编译Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#编译Shader" class="headerlink" title="编译Shader"></a>编译Shader</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Shader程序 GL_VERTEX_SHADER/GL_FRAGMENT_SHADER</span></span><br><span class="line">GLuint shaderID = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向Shader注入源代码</span></span><br><span class="line"><span class="comment">//参数1：shader程序的ID</span></span><br><span class="line"><span class="comment">//参数2：字符串数量</span></span><br><span class="line"><span class="comment">//参数3：字符串数组</span></span><br><span class="line"><span class="comment">//参数4：字符串数组中每个串的长度</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(shaderID, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译Shader</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(shaderID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查编译结果</span></span><br><span class="line"><span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(shaderID, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(shaderID, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; infoLog &lt;&lt;std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="链接-1"   >          <a href="#链接-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可执行程序</span></span><br><span class="line">GLuint programID = <span class="built_in">glCreateProgram</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将编译好的shader程序添加到program中</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(programID, vertexID);</span><br><span class="line"><span class="built_in">glAttachShader</span>(programID, fragmentID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(programID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查链接错误</span></span><br><span class="line"><span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">glGetProgramiv</span>(programID, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line"><span class="built_in">glGetProgramInfoLog</span>(program, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; infoLog &lt;&lt;std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除源代码</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexID);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentID);</span><br></pre></td></tr></table></div></figure>        <h2 id="顶点属性"   >          <a href="#顶点属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h2>      <p>在顶点着色器中，输入变量也叫<strong>顶点属性</strong></p><p>顶点属性的上限由硬件决定，OpenGL确保至少有16个包含4分量的顶点属性可用</p><p>通过<code>GL_MAX_VERTEX_ATTRIBS</code>可以查看上限</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nrAttributes;</span><br><span class="line"><span class="built_in">glGetIntegerv</span>(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></div></figure>        <h3 id="数据类型"   >          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3>      <p>基本类型：<code>int</code>，<code>float(32bit)</code>，<code>double(64bit)</code>，<code>uint</code>，<code>bool</code></p><p>容器类型：<code>Vector</code>，<code>Matrix</code></p>        <h4 id="向量"   >          <a href="#向量" class="heading-link"><i class="fas fa-link"></i></a><a href="#向量" class="headerlink" title="向量"></a>向量</h4>      <p>有<code>vec</code>,<code>bvec</code>,<code>ivec</code>,<code>uvec</code>,<code>dvec</code></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重组</span></span><br><span class="line">vec2 someVec;</span><br><span class="line">vec4 differentVec = someVec.xyxx;</span><br><span class="line">vec3 anotherVec = differentVec.zyw;</span><br><span class="line">vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入构造函数</span></span><br><span class="line">vec2 vect = <span class="built_in">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">vec4 result = <span class="built_in">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec4 otherResult = <span class="built_in">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></div></figure>        <h2 id="输入输出"   >          <a href="#输入输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2>      <blockquote><p>vertexShader的输出和fragmentShader的输入名字一致即可调用。</p></blockquote><p>顶点着色器的输入要标识location：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;   <span class="comment">// 位置变量的属性location值为 0 </span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 颜色变量的属性location值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序中的顶点数据</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 一个顶点的数据，包含位置和颜色</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   </span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载到缓冲</span></span><br><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>* <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不设置location，动态获取</span></span><br><span class="line">GLuint posLocation = <span class="built_in">glGetAttribLocation</span>(programID, <span class="string">&quot;aPos&quot;</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(posLocation, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(posLocation);</span><br></pre></td></tr></table></div></figure>        <h2 id="Uniform"   >          <a href="#Uniform" class="heading-link"><i class="fas fa-link"></i></a><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h2>      <ul><li><p>uniform是<strong>全局的</strong>，即每个uniform变量必须在所有着色器中独一无二</p></li><li><p>uniform可以被着色器程序的任意着色器在任意阶段访问</p></li><li><p>uniform会保存数据，直到它们被重置或刷新</p></li><li><p>可以用于在程序和着色器之间交互</p></li></ul>        <h3 id="声明"   >          <a href="#声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#声明" class="headerlink" title="声明"></a>声明</h3>      <p>在任意着色器中声明</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以自定义结构体作为uniform</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span> &#123;</span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="赋值"   >          <a href="#赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3>      <p>在OpenGL程序中赋值</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="comment">//返回-1表示没有找到该uniform</span></span><br><span class="line"><span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></div></figure><p>※查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你<strong>必须</strong>先使用程序（调用<code>glUseProgram</code>)，因为它是在当前激活的着色器程序中设置uniform的。</p>        <h2 id="内置函数"   >          <a href="#内置函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2>              <h3 id="mix"   >          <a href="#mix" class="heading-link"><i class="fas fa-link"></i></a><a href="#mix" class="headerlink" title="mix"></a>mix</h3>      <p>混合两个值</p><p><code>mix(a,b,value)</code> &#x3D; a * (1-value) + b * value</p>        <h2 id="Compute-Shader"   >          <a href="#Compute-Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Compute-Shader" class="headerlink" title="Compute Shader"></a>Compute Shader</h2>      <p>用于通用并行计算的shader</p><p>资源：</p><ul><li>Read Only：<code>Uniform变量</code>，<code>Buffers</code>，<code>Textures</code></li><li>Read&#x2F;Write：<code>Images</code>，<code>Shader Storage Buffer</code></li></ul>        <h3 id="核心概念"   >          <a href="#核心概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3>      <ul><li><p>工作组（WorkGroup）：</p><ul><li>每个工作组包含{local_size_x * local_size_y * local_size_z }个线程</li><li>工作组内的线程可以通过共享内存（<code>shared variable</code>）高效通信。</li><li>Workgroup.xyz&gt;&#x3D;64k</li><li>LocalSize.xy&gt;&#x3D;1k</li><li>LocalSize.z&gt;&#x3D;64</li></ul></li><li><p>GLSL的内部变量：</p><ul><li><code>uvec3 gl_LocalInvocationID</code>：工作组内的线程ID</li><li><code>uvec3 gl_GlobalInvocationID</code>：全局线程ID</li><li><code>uvec3 gl_WorkGroupID</code>：工作组ID</li><li><code>uvec3 gl_NumWorkGroups</code>：工作组大小</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取组内线程最大值</span></span><br><span class="line"><span class="built_in">glGetInteger_iv</span>(GL_MAX_COMPUTE_WORK_GROUP_COUNT,<span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>,&amp;x/&amp;y/&amp;z);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取工作组数最大值</span></span><br><span class="line"><span class="built_in">glGetInteger_iv</span>(GL_MAX_COMPUTE_WORK_GROUP_SIZE,<span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>,&amp;x/&amp;y/&amp;z);</span><br></pre></td></tr></table></div></figure><p>※工作组内可以访问共享的变量，但不同工作组访问同一个变量会导致死锁</p></li></ul>        <h3 id="Images"   >          <a href="#Images" class="heading-link"><i class="fas fa-link"></i></a><a href="#Images" class="headerlink" title="Images"></a>Images</h3>      <figure class="highlight glsl"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLSL </span></span><br><span class="line"><span class="comment">// IMAGE_COORD:整型像素坐标</span></span><br><span class="line">gvec4 <span class="built_in">imageLoad</span>(gimage img, IMAGE_COORD);</span><br><span class="line">gvec4 <span class="built_in">imageStore</span>(gimage img, IMAGE_COORD, gvec4 data);</span><br><span class="line"></span><br><span class="line">gint <span class="built_in">imageAtomicExchange</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicCompSwap</span>(gimage img, IMAGE_COORDS, gint compare,gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicAdd</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicAnd</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicOr</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicXor</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicMin</span>(gimage img, IMAGE_COORDS, gint data);</span><br><span class="line">gint <span class="built_in">imageAtomicMax</span>(gimage img, IMAGE_COORDS, gint data);</span><br></pre></td></tr></table></div></figure><ul><li><code>image2D</code>：float</li><li><code>iimage2D</code>：int</li><li><code>uimage2D</code>：uint</li></ul><div class="table-container"><table><thead><tr><th>GLSL</th><th>OpenGL</th></tr></thead><tbody><tr><td>gimage{<em>x</em>}D (x&#x3D;1~3)</td><td>GL_TEXTURE_{<em>x</em>}D</td></tr><tr><td>gimageCube</td><td>GL_TEXTURE_CUBE_MAP</td></tr><tr><td>gimage2Drect</td><td>GL_TEXTURE_RECTANGLE</td></tr><tr><td>gimage{<em>x</em>}DArray (x&#x3D;1~2)</td><td>GL_TEXTURE_{<em>x</em>}D_ARRAY</td></tr><tr><td>gimageCubeArray</td><td>GL_TEXTURE_CUBE_MAP_ARRAY</td></tr><tr><td>gimageBuffer</td><td>GL_TEXTURE_BUFFER</td></tr><tr><td>gimage2DMS</td><td>GL_TEXTURE_2D_MULTISAMPLE</td></tr><tr><td>gimage2DMSArray</td><td>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div>        <h3 id="SSBO"   >          <a href="#SSBO" class="heading-link"><i class="fas fa-link"></i></a><a href="#SSBO" class="headerlink" title="SSBO"></a>SSBO</h3>      <p><strong>GLSL中</strong></p><p>shader storage buffer object</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GLuint ssbo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ssbo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_SHADER_STORAGE_BUFFER, ssbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_SHADER_STORAGE_BUFFER, <span class="built_in">sizeof</span>(data), data, GL_STATIC_READ);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2:bufferID</span></span><br><span class="line"><span class="built_in">glBindBufferBase</span>(GL_SHADER_STORAGE_BUFFER, <span class="number">3</span>, ssbo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unbind</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_SHADER_STORAGE_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>        <h3 id="编译ComputeShader"   >          <a href="#编译ComputeShader" class="heading-link"><i class="fas fa-link"></i></a><a href="#编译ComputeShader" class="headerlink" title="编译ComputeShader"></a>编译ComputeShader</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLuint computeShader = <span class="built_in">glCreateShader</span>(GL_COMPUTE_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(cs, <span class="number">1</span>, &amp;source, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(cs);</span><br><span class="line"></span><br><span class="line">GLuint computeProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="built_in">glAttachShader</span>(prog, cs);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(prog);</span><br></pre></td></tr></table></div></figure>        <h3 id="启用"   >          <a href="#启用" class="heading-link"><i class="fas fa-link"></i></a><a href="#启用" class="headerlink" title="启用"></a>启用</h3>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(computeProgram);</span><br><span class="line"><span class="built_in">glDispathCompute</span>(size_x,size_y,size_z); <span class="comment">//workgroupSize</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glMemoryBarrier</span>(GL_ALL_BARRIER_BITS);</span><br></pre></td></tr></table></div></figure>        <h1 id="GLM"   >          <a href="#GLM" class="heading-link"><i class="fas fa-link"></i></a><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h1>              <h2 id="变量"   >          <a href="#变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量" class="headerlink" title="变量"></a>变量</h2>      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向量</span></span><br><span class="line"><span class="function">glm::vec2 <span class="title">v0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">v0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec4 <span class="title">v0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> mul = v0 * v0;</span><br><span class="line"><span class="keyword">auto</span> dot = glm::<span class="built_in">dot</span>(v0, v0);</span><br><span class="line"><span class="keyword">auto</span> cross = glm::<span class="built_in">cross</span>(v0, v0); <span class="comment">//只能使用3维向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵</span></span><br><span class="line"><span class="function">glm::mat2 <span class="title">m0</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::mat3 <span class="title">m0</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::mat4 <span class="title">m0</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::mat2x3 <span class="title">m0</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">glm::mat4 m1 = glm::<span class="built_in">identity</span>&lt;glm::mat4&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_ENABLE_EXPERIMENTAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtx/string_cast.hpp&gt;</span></span></span><br><span class="line">cout &lt;&lt; glm::<span class="built_in">to_string</span>(m1) &lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;https://learnopengl-cn.github.io/&quot; &gt;LearnOpenGL&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="图形学" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="游戏" scheme="https://lzmustb.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://lzmustb.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity学习笔记</title>
    <link href="https://lzmustb.github.io/2024/09/29/my-Unity-learning-note/"/>
    <id>https://lzmustb.github.io/2024/09/29/my-Unity-learning-note/</id>
    <published>2024-09-29T01:24:02.000Z</published>
    <updated>2024-12-16T05:02:56.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Always separate the logic from the visuals in your game objects.</p></blockquote><span id="more"></span>        <h1 id="常见问题"   >          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1>              <h2 id="VsCode作为默认编辑器"   >          <a href="#VsCode作为默认编辑器" class="heading-link"><i class="fas fa-link"></i></a><a href="#VsCode作为默认编辑器" class="headerlink" title="VsCode作为默认编辑器"></a>VsCode作为默认编辑器</h2>      <p><strong>STEP1：</strong>在Package Manager中安装<code>Visual Studio Code Editor</code></p><p><strong>STEP2：</strong>在<code>Edit -&gt; Preferences -&gt; ExternalTools</code>中修改External Script Editor为VsCode后，<strong>在Browse中选到VsCode的exe文件</strong>。</p>        <h2 id="Animator中使用Trigger的时机"   >          <a href="#Animator中使用Trigger的时机" class="heading-link"><i class="fas fa-link"></i></a><a href="#Animator中使用Trigger的时机" class="headerlink" title="Animator中使用Trigger的时机"></a>Animator中使用Trigger的时机</h2>      <p>从<code>Any State</code>转到<code>State1</code>时，为了防止<code>State1</code>转到<code>State1</code>，用单次触发的Trigger变量</p>        <h2 id="打开VsCode后开始下载-NET"   >          <a href="#打开VsCode后开始下载-NET" class="heading-link"><i class="fas fa-link"></i></a><a href="#打开VsCode后开始下载-NET" class="headerlink" title="打开VsCode后开始下载.NET"></a>打开VsCode后开始下载.NET</h2>      <p>在settings.json中加上以下内容</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dotnetAcquisitionExtension.existingDotnetPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;extensionId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-dotnettools.csharp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Program Files\\dotnet\\dotnet.exe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;extensionId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;visualstudiotoolsforunity.vstuc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Program Files\\dotnet\\dotnet.exe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></div></figure>        <h1 id="Inspector-标签"   >          <a href="#Inspector-标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#Inspector-标签" class="headerlink" title="Inspector 标签"></a>Inspector 标签</h1>      <p><code>HideInInspector</code>：使变量在检视器中不可见</p><p><code>ReadOnly</code>：使变量在检视器中不可编辑</p><p><code>DefaultExecutionOrder(NUMBER)</code>：修改脚本的优先级</p><p><code>RuntimeInitializeOnLoadMethod</code>：让脚本的静态方法成为入口方法，并在所有脚本的Awake()之前执行</p><p><code>Range(0,100)</code>：限制参数范围</p><p><code>Tooptip(&quot;提示&quot;)</code>：鼠标悬浮提示</p>        <h2 id="序列化"   >          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2>      <p><code>System.Serializable</code>：序列化一个类</p><p><code>System.NonSerialized</code>：表示属性不参与序列化</p><p><code>SerializeField</code>：让私有属性参与序列化</p><p><code>SerializeReference</code>：序列化一个引用</p><p><code>Serializable</code>：序列化自定义的<code>struct</code>等列表时使用</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a; <span class="comment">//序列化</span></span><br><span class="line">    [<span class="meta">System.NonSerialized</span>] </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b; <span class="comment">//不序列化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SO_KitchenObj_GameObj</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SO_KitchenObj kitchenObjSO;</span><br><span class="line">    <span class="keyword">public</span> GameObject gameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Data data; <span class="comment">//序列化</span></span><br></pre></td></tr></table></div></figure>        <h2 id="Header"   >          <a href="#Header" class="heading-link"><i class="fas fa-link"></i></a><a href="#Header" class="headerlink" title="Header"></a>Header</h2>      <p><code>[Header(&quot;name&quot;)]</code>：在面板中添加标记，方便查看。</p>        <h2 id="强绑定脚本"   >          <a href="#强绑定脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#强绑定脚本" class="headerlink" title="强绑定脚本"></a>强绑定脚本</h2>      <p><code>[RequireComponent(typeof(&quot;类名&quot;),typeof(&quot;...&quot;))]</code></p><p>自动导入关联的脚本，并且限制手动无法删除依赖的脚本</p>        <h1 id="脚本生命周期"   >          <a href="#脚本生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h1>              <h2 id="脚本的执行顺序"   >          <a href="#脚本的执行顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#脚本的执行顺序" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h2>      <p>在<code>ScriptExecution Order</code>中可以设置脚本的执行顺序，数值越小越先执行。</p><p>※Unity在执行生命周期方法时要通过遍历找到所有脚本，然后反射调用每个脚本的方法，因此<strong>脚本绑定越多，执行效率越低</strong>。</p><p>※不要在脚本内留下<strong>空的</strong>生命周期方法。</p>        <h2 id="初始化"   >          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>      <div class="table-container"><table><thead><tr><th>执行顺序</th><th>执行时机</th></tr></thead><tbody><tr><td>Awake()</td><td>脚本被首次初始化时</td></tr><tr><td>OnEnable()</td><td>每当脚本被启动(勾选)时</td></tr><tr><td>Reset()</td><td>只在编辑模式下执行</td></tr><tr><td>Start()</td><td>在所有Awake()执行完后的下一帧执行</td></tr></tbody></table></div><p>在<code>Awake()</code>中初始化<strong>脚本内</strong>数据，在<code>start()</code>中访问<strong>脚本外或其他脚本</strong>数据。</p><p><code>Awake()</code>和<code>OnEnable()</code>在第0帧执行，<code>start()</code>和<code>Update()等</code>在第一帧执行。</p>        <h2 id="循环"   >          <a href="#循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环" class="headerlink" title="循环"></a>循环</h2>              <h3 id="固定更新"   >          <a href="#固定更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#固定更新" class="headerlink" title="固定更新"></a>固定更新</h3>      <p>对帧率有稳定要求的地方使用，如动画系统，物理系统。<code>FixedUpdate()</code>依赖于每帧执行的<code>Update()</code>，如果帧率不稳定，<code>FixedUpdate()</code>可能在一帧里执行多次。</p><div class="table-container"><table><thead><tr><th>执行顺序</th><th></th></tr></thead><tbody><tr><td>FixedUpdate()</td><td>默认每0.02s调用一次，在<code>TimeManager -&gt; Fixed Timestep</code>中修改</td></tr><tr><td>内部动画更新</td><td></td></tr><tr><td>内部物理更新</td><td></td></tr><tr><td>OnTriggerXXX</td><td>碰撞的回调事件</td></tr><tr><td>OnCollisioinXXX</td><td></td></tr><tr><td>yield <code>WaitForFixedUpdate</code></td><td>协程回调，表示：<em>等待下一个FixedUpdate()执行完毕</em></td></tr></tbody></table></div>        <h3 id="逻辑更新"   >          <a href="#逻辑更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑更新" class="headerlink" title="逻辑更新"></a>逻辑更新</h3>      <div class="table-container"><table><thead><tr><th>执行顺序</th><th></th></tr></thead><tbody><tr><td>Update()</td><td></td></tr><tr><td>yield <code>null</code> <code>WaitForSeconds</code> <code>WWW</code> <code>StartCoroutine</code></td><td>部分协程回调</td></tr><tr><td>动画系统的每帧更新，内部逻辑</td><td></td></tr><tr><td>Late Update()</td><td></td></tr></tbody></table></div>        <h3 id="场景渲染"   >          <a href="#场景渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#场景渲染" class="headerlink" title="场景渲染"></a>场景渲染</h3>      <div class="table-container"><table><thead><tr><th>执行顺序</th><th></th></tr></thead><tbody><tr><td>OnPreCull</td><td>场景被摄像机裁剪之前</td></tr><tr><td>OnWillRenderObject</td><td>物体对当前摄像机可见时</td></tr><tr><td>OnBecameVisible</td><td>物体对任意摄像机可见时</td></tr><tr><td>OnBecameInvisible</td><td>物体对所有摄像机都不可见时</td></tr><tr><td>OnPreRender</td><td>摄像机开始渲染场景前</td></tr><tr><td>OnRenderObject</td><td>摄像机开始渲染场景后</td></tr><tr><td>OnPostRender</td><td>摄像机完成渲染场景后</td></tr><tr><td>OnRenderImage</td><td>全部渲染完毕后</td></tr></tbody></table></div>        <h3 id="编辑器UI更新"   >          <a href="#编辑器UI更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑器UI更新" class="headerlink" title="编辑器UI更新"></a>编辑器UI更新</h3>      <div class="table-container"><table><thead><tr><th>执行顺序</th><th></th></tr></thead><tbody><tr><td>OnDrawGizmos</td><td><code>OnDraw...</code>系列API调用</td></tr><tr><td>OnGUI</td><td>早期制作界面的接口</td></tr><tr><td>yield <code>WaitForEndOfFrame</code></td><td></td></tr><tr><td>OnApplicationPause</td><td></td></tr></tbody></table></div>        <h2 id="销毁"   >          <a href="#销毁" class="heading-link"><i class="fas fa-link"></i></a><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2>      <div class="table-container"><table><thead><tr><th align="left">执行顺序</th><th>执行时机</th></tr></thead><tbody><tr><td align="left">OnApplicationQuit()</td><td>程序退出时</td></tr><tr><td align="left">OnDisable()</td><td>脚本被关闭时</td></tr><tr><td align="left">OnDestroy()</td><td>脚本被销毁时</td></tr></tbody></table></div>        <h1 id="Events"   >          <a href="#Events" class="heading-link"><i class="fas fa-link"></i></a><a href="#Events" class="headerlink" title="Events"></a>Events</h1>      <p>事件分为<code>Publisher/广播者</code>和<code>Subscriber/监听者</code>，多个<code>Subscriber</code>可以监听同一个Event。</p><p>事件的<code>Publisher</code>不关心事件的<code>Subscriber</code>,在游戏中，可以由游戏逻辑发送事件，让游戏表现监听事件，从而实现逻辑和表现的分离。</p>        <h2 id="C-Events"   >          <a href="#C-Events" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-Events" class="headerlink" title="C# Events"></a>C# Events</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnSpacePressed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OnSpacePressedArgs&gt; OnSpacePressed;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnSpacePressedArgs</span> : <span class="title">EventArgs</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断有无监听者</span></span><br><span class="line">    <span class="keyword">if</span>(OnSpacePressed != <span class="literal">null</span>)&#123;</span><br><span class="line">    OnSpacePressed(<span class="keyword">this</span>,EventArgs.Empty);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或简写</span></span><br><span class="line">    OnSpacePressed?.Invoke(<span class="keyword">this</span>,EventArgs.Empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;组件实例&gt;.OnSpacePressed += HandleSpacePressed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消监听</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;组件实例&gt;.OnSpacePressed -= HandleSpacePressed;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="协程"   >          <a href="#协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程" class="headerlink" title="协程"></a>协程</h1>      <p>※协程不是多线程</p><p>语法：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协程方法：</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Func</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&#x27;※协程回调&#x27;</span>;</span><br><span class="line">   Debug.Log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func2</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//启动协程</span></span><br><span class="line">    StartCoroutine(Func());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭协程</span></span><br><span class="line">    StopCoroutine(Func());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭所有协程</span></span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动其他脚本的协程</span></span><br><span class="line">    GetComponent&lt;ComponentName&gt;().StartCoroutine(Func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>协程回调：</p><div class="table-container"><table><thead><tr><th>方法</th><th>时机</th></tr></thead><tbody><tr><td>null</td><td>等待一帧</td></tr><tr><td>new WaitForSeconds(1)</td><td>等待固定时间</td></tr><tr><td>new WaitForSecondRealtime(1)</td><td>等待固定时间，且忽略时间缩放</td></tr></tbody></table></div>        <h1 id="脚本"   >          <a href="#脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1>              <h2 id="脚本序列化"   >          <a href="#脚本序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#脚本序列化" class="headerlink" title="脚本序列化"></a>脚本序列化</h2>      <p>使用<code>public</code>声明的属性会被序列化。标注<code>[System.NonSerialized]</code>可以让属性不参与序列化，防止浪费内存。</p>        <h2 id="DontDestroyOnLoad"   >          <a href="#DontDestroyOnLoad" class="heading-link"><i class="fas fa-link"></i></a><a href="#DontDestroyOnLoad" class="headerlink" title="DontDestroyOnLoad"></a>DontDestroyOnLoad</h2>      <p>使用<code>DontDestroyOnLoad(GameObject)</code>标记的游戏对象在切换场景时不会销毁。（默认会卸载场景中的所有游戏对象和脚本）</p>        <h2 id="父类转子类（里氏转换）"   >          <a href="#父类转子类（里氏转换）" class="heading-link"><i class="fas fa-link"></i></a><a href="#父类转子类（里氏转换）" class="headerlink" title="父类转子类（里氏转换）"></a>父类转子类（里氏转换）</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="literal">null</span> &amp;&amp; parent.GetType() == <span class="keyword">typeof</span>(Son))</span><br><span class="line">&#123;</span><br><span class="line">Son son = parent <span class="keyword">as</span> Son;</span><br><span class="line">    son.func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Interface-接口"   >          <a href="#Interface-接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2>      <p>一个接口可以实现另一个接口</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOwner</span> &lt;: 另一个接口&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//只能使用property，不能使用field</span></span><br><span class="line">    <span class="keyword">public</span> KitchenObj KitchenObj &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearKitchenObject</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetKitchenObject</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h2 id="Singleton-单例模式"   >          <a href="#Singleton-单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataManager</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确保只有一个实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设为 类外只读权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Player Instance &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在多于一个实例时报错</span></span><br><span class="line">        <span class="keyword">if</span>(Instance!=<span class="literal">null</span>)&#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Player is not singleton&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="获取组件"   >          <a href="#获取组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取组件" class="headerlink" title="获取组件"></a>获取组件</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回布尔值</span></span><br><span class="line">transform.TryGetComponent(<span class="keyword">out</span> &lt;类名(组件名)&gt; 实例形参)</span><br></pre></td></tr></table></div></figure>        <h3 id="TryGet-实现"   >          <a href="#TryGet-实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#TryGet-实现" class="headerlink" title="TryGet 实现"></a>TryGet 实现</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryGetPlate</span>(<span class="params"><span class="keyword">out</span> PlateObj plateObj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> PlateObj)</span><br><span class="line">&#123;</span><br><span class="line">plateObj = <span class="keyword">this</span> <span class="keyword">as</span> PlateObj;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">plateObj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="EnumFlags"   >          <a href="#EnumFlags" class="heading-link"><i class="fas fa-link"></i></a><a href="#EnumFlags" class="headerlink" title="EnumFlags"></a>EnumFlags</h2>      <p>使用枚举类型的Flag可以用来判断菜单，配方等。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">[<span class="meta">Flags</span>] <span class="comment">//使变量在Inspector中可以多选</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> KitchenObjEnum</span><br><span class="line">&#123;</span><br><span class="line">    Plate = <span class="number">1</span>,</span><br><span class="line">    Bread = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    Cabbage = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    Cabbage_Slices = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    Cheese = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    Cheese_Slices = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">    Meat_Burned = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">    Meat_Cooked = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">    Meat_Uncooked = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">    Tomato = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br><span class="line">    Tomato_Slices = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="GameObject"   >          <a href="#GameObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h1>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//激活或销毁游戏对象</span></span><br><span class="line">&lt;游戏对象实例&gt;.SetActive(<span class="literal">true</span>/<span class="literal">false</span>);</span><br></pre></td></tr></table></div></figure>        <h1 id="Prefab"   >          <a href="#Prefab" class="heading-link"><i class="fas fa-link"></i></a><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h1>      <p>Prefab（预制体）</p>        <h2 id="Instantiate-创建实例"   >          <a href="#Instantiate-创建实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#Instantiate-创建实例" class="headerlink" title="Instantiate 创建实例"></a>Instantiate 创建实例</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> &lt;组件&gt; : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Transform prefab;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.T))&#123;</span><br><span class="line">            Transform prefabTransform = Instantiate(prefab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Tag"   >          <a href="#Tag" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1>              <h2 id="特殊tag：EditorOnly"   >          <a href="#特殊tag：EditorOnly" class="heading-link"><i class="fas fa-link"></i></a><a href="#特殊tag：EditorOnly" class="headerlink" title="特殊tag：EditorOnly"></a>特殊tag：EditorOnly</h2>      <p><code>EditorOnly</code>：标记后，打包游戏时会自动忽略该游戏对象</p>        <h2 id="相关方法"   >          <a href="#相关方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2>      <p><code>GameObject.FindGameObjectWithTag(&quot;tagName&quot;)</code>：通过tag找到游戏对象</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> GameObject.FindGameObjectsWithTag(<span class="string">&quot;tagName&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取所有tagName的对象并遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="InputSystem"   >          <a href="#InputSystem" class="heading-link"><i class="fas fa-link"></i></a><a href="#InputSystem" class="headerlink" title="InputSystem"></a>InputSystem</h1>              <h2 id="导入项目"   >          <a href="#导入项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2>      <p><code>Package Manager -&gt; input System -&gt; install</code> </p>        <h2 id="修改生效的输入方式"   >          <a href="#修改生效的输入方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改生效的输入方式" class="headerlink" title="修改生效的输入方式"></a>修改生效的输入方式</h2>      <p><code>Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings -&gt; Active Input Handling</code></p>        <h2 id="创建InputAction"   >          <a href="#创建InputAction" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建InputAction" class="headerlink" title="创建InputAction"></a>创建InputAction</h2>      <p><code>Project -&gt; [new]Input Action</code></p><p><img src="/../images/image-20241018165500463.png" alt="image-20241018165500463"></p>        <h2 id="生成Input-Action的C-类"   >          <a href="#生成Input-Action的C-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成Input-Action的C-类" class="headerlink" title="生成Input Action的C#类"></a>生成Input Action的C#类</h2>      <p><img src="/../images/image-20241018140338995.png" alt="image-20241018140338995"></p>        <h2 id="引入input-action"   >          <a href="#引入input-action" class="heading-link"><i class="fas fa-link"></i></a><a href="#引入input-action" class="headerlink" title="引入input action"></a>引入input action</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputSystem Singleton &#123;<span class="keyword">get</span>;<span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PlayerInputControls inputControls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//创建实例</span></span><br><span class="line">    inputControls = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span>&#123;</span><br><span class="line">    inputControls?.Enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">inputControl?.Disable();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//按帧读取输入值</span></span><br><span class="line">Vector2 inputDir = inputControl.&lt;MAP名&gt;.&lt;Action名&gt;.ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册事件</span></span><br><span class="line">inputControls.&lt;MAP名&gt;.&lt;Action名&gt;.started/canceled/performed += &lt;函数名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例（回调函数）</span></span><br><span class="line">inputControl.GamePlay.WalkButton.performed += ctx =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">    speed = walkSpeed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局事件（需引入UnityEngine.InputSystem）</span></span><br><span class="line"> <span class="comment">//输入设备发生变化时触发</span></span><br><span class="line">InputSystem.onActionChange += OnActionChange;</span><br></pre></td></tr></table></div></figure>        <h1 id="ScriptableObject"   >          <a href="#ScriptableObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#ScriptableObject" class="headerlink" title="ScriptableObject"></a>ScriptableObject</h1>      <p>scriptableObject是一种数据容器，在项目菜单中通过<code>AssetMenu</code>可以创建SO文件，以<code>.asset</code>的形式保存在项目中。</p>        <h2 id="定义SO脚本"   >          <a href="#定义SO脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义SO脚本" class="headerlink" title="定义SO脚本"></a>定义SO脚本</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;目录/选项名&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSO</span> : <span class="title">ScriptableObject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> myString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="作为gameObject基类"   >          <a href="#作为gameObject基类" class="heading-link"><i class="fas fa-link"></i></a><a href="#作为gameObject基类" class="headerlink" title="作为gameObject基类"></a>作为gameObject基类</h2>              <h2 id="作为事件传递"   >          <a href="#作为事件传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#作为事件传递" class="headerlink" title="作为事件传递"></a>作为事件传递</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Event/CharacterEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;Character&gt; OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Animator"   >          <a href="#Animator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h1>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Animator playerAnim;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置参数</span></span><br><span class="line">playerAnim.SetBool(<span class="string">&quot;Anim_isWalking&quot;</span>, isWalking);</span><br><span class="line">playerAnim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">playerAnim.SetFloat(<span class="string">&quot;velocityX&quot;</span>, Math.Abs(rb.velocity.x));</span><br></pre></td></tr></table></div></figure>        <h2 id="动画状态机脚本"   >          <a href="#动画状态机脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#动画状态机脚本" class="headerlink" title="动画状态机脚本"></a>动画状态机脚本</h2>      <p>状态机可以生成c#脚本，在状态机的各个生命周期进行操作</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">class</span> &lt;状态机名&gt; : StateMachineBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// OnStateEnter is called when a transition starts and the state machine starts to evaluate this state</span></span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStateEnter</span>(<span class="params">Animator animator, AnimatorStateInfo stateInfo, <span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.GetComponent&lt;PlayerController&gt;().isAttacking = <span class="literal">false</span>;</span><br><span class="line">        animator.GetComponent&lt;PlayerController&gt;().attackMotion = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks</span></span><br><span class="line">    <span class="comment">//override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OnStateExit is called when a transition ends and the state machine finishes evaluating this state</span></span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStateExit</span>(<span class="params">Animator animator, AnimatorStateInfo stateInfo, <span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.GetComponent&lt;PlayerController&gt;().attackMotion = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OnStateMove is called right after Animator.OnAnimatorMove()</span></span><br><span class="line">    <span class="comment">//override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    // Implement code that processes and affects root motion</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OnStateIK is called right after Animator.OnAnimatorIK()</span></span><br><span class="line">    <span class="comment">//override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    // Implement code that sets up animation IK (inverse kinematics)</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="多人游戏"   >          <a href="#多人游戏" class="heading-link"><i class="fas fa-link"></i></a><a href="#多人游戏" class="headerlink" title="多人游戏"></a>多人游戏</h1>              <h2 id="Netcode-for-GameObjects"   >          <a href="#Netcode-for-GameObjects" class="heading-link"><i class="fas fa-link"></i></a><a href="#Netcode-for-GameObjects" class="headerlink" title="Netcode for GameObjects"></a>Netcode for GameObjects</h2>              <h3 id="初始化-1"   >          <a href="#初始化-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3>      <ul><li>创建<code>NetWorkManager</code>对象，并绑定<code>NetWorkManager</code>脚本，设置为<code>UnityTransport</code>。</li></ul>        <h2 id="NetworkManager"   >          <a href="#NetworkManager" class="heading-link"><i class="fas fa-link"></i></a><a href="#NetworkManager" class="headerlink" title="NetworkManager"></a>NetworkManager</h2>              <h3 id="启动"   >          <a href="#启动" class="heading-link"><i class="fas fa-link"></i></a><a href="#启动" class="headerlink" title="启动"></a>启动</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动主机(服务器+客户端)</span></span><br><span class="line">NetworkManager.Singleton.StartHost();</span><br><span class="line"><span class="comment">//启动客户端</span></span><br><span class="line">NetworkManager.Singleton.StartClient();</span><br><span class="line"><span class="comment">//启动服务器</span></span><br><span class="line">NetworkManager.Singleton.StartServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前状态</span></span><br><span class="line">NetworkManager.Singleton.IsClient/IsServer/</span><br><span class="line">    </span><br><span class="line"><span class="comment">//加载场景</span></span><br><span class="line">NetworkManager.Singleton.SceneManager.LoadScene()</span><br></pre></td></tr></table></div></figure>        <h3 id="网络连接事件"   >          <a href="#网络连接事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络连接事件" class="headerlink" title="网络连接事件"></a>网络连接事件</h3>      <ul><li><code>OnClientConnectedCallback</code>：监听客户端连接成功</li><li><code>OnClientDisconnectCallback</code>：监听客户端断开连接</li><li><code>OnServerStarted</code>：监听服务器启动</li><li><code>OnTransportFailure</code>：监听不可恢复的断开事件</li><li><code>NetworkManager.Singleton.Shutdown()</code>：客户端断开网络方法</li><li><code>NetworkManager.Singleton.DisconnectClient(client)</code>：服务器断开指定客户端方法</li></ul>        <h2 id="NetworkObject"   >          <a href="#NetworkObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#NetworkObject" class="headerlink" title="NetworkObject"></a>NetworkObject</h2>      <p>需要服务端同步的对象要绑定<code>NetworkObject</code>脚本，并继承<code>NetworkBehaviour</code>。</p>        <h3 id="Player-Prefab"   >          <a href="#Player-Prefab" class="heading-link"><i class="fas fa-link"></i></a><a href="#Player-Prefab" class="headerlink" title="Player Prefab"></a>Player Prefab</h3>      <p><code>Player Prefab</code>是特殊的网络对象，每台客户端只能拥有一个。</p>        <h3 id="NetworkPrefabs-List"   >          <a href="#NetworkPrefabs-List" class="heading-link"><i class="fas fa-link"></i></a><a href="#NetworkPrefabs-List" class="headerlink" title="NetworkPrefabs List"></a>NetworkPrefabs List</h3>      <p>其他网络对象的列表，勾选<code>override</code>后可以对服务器和客户端设置不同的模型。</p><p>※<strong>加载和卸载，隐藏和显示</strong>网络对象必须发生在服务器。玩家退出或掉线，对象仍然在服务器中（除非设置为玩家拥有的对象）。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">[<span class="meta">ServerRpc</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerRpc</span>()</span>&#123;</span><br><span class="line">Transform Obj = Instantiate(prefab);</span><br><span class="line">Obj.GetComponent&lt;NetworkObject&gt;().Spawn()/Despawn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改所有者</span></span><br><span class="line">GetComponent&lt;NetworkObject&gt;().ChangeOwnership(clientId);</span><br><span class="line">GetComponent&lt;NetworkObject&gt;().RemoveOwnership();</span><br><span class="line"><span class="comment">//指定客户端的玩家对象</span></span><br><span class="line">NetworkManager.Singleton.ConnectedClients[OwnerClientId].PlayerObject;</span><br><span class="line"><span class="comment">//指定客户端的拥有对象</span></span><br><span class="line">NetworkManager.Singleton.ConnectedClients[OwnerClientId].OwnedObjects;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏与显示</span></span><br><span class="line">[<span class="meta">ServerRpc</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideServerRpc</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> NetworkManager.Singleton.ConnectedClients)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item.Key != OwnerClientId)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">this</span>.NetworkObject.NetworkHide(item.Key); <span class="comment">//只在拥有者的客户端显示</span></span><br><span class="line">            <span class="keyword">this</span>.NetworkObject.NetworkShow(item.Key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个客户端设置判断可见性的规则</span></span><br><span class="line">GetComponent&lt;NetworkObject&gt;().CheckObjectVisibility = ((clientId) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>        <h3 id="生命周期方法"   >          <a href="#生命周期方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3>      <p>※动态生成的网络对象和场景内置的网络对象调用<code>OnNetworkSpawn()</code>的顺序<strong>不一样</strong>。</p><ul><li>Dynamically Spawned：<code>Awake -&gt; OnNetworkSpawned -&gt; Start</code></li><li>In-Scene placed：<code>Awake -&gt; Start -&gt; OnNetworkSpawned</code></li></ul><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络对象和脚本被创建时调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnNetworkSpawn</span>()</span></span><br><span class="line"><span class="function"><span class="comment">//网络对象和脚本被删除时调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnNetworkDespawn</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGainOwnership</span>()</span></span><br></pre></td></tr></table></div></figure>        <h3 id="Network-Transform-脚本"   >          <a href="#Network-Transform-脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#Network-Transform-脚本" class="headerlink" title="Network Transform(脚本)"></a>Network Transform(脚本)</h3>      <p><strong>参数：</strong></p><ul><li>Syncing：需要同步的坐标，旋转和缩放轴</li><li>Thresholds：表示执行同步的阈值</li><li>Configurations：<ul><li>In Local Space：使用Local Position</li><li>Interpolate：同步时使用插值移动，而非直接同步最终位置</li></ul></li></ul><p>默认为<code>server authoritative mode</code>，不接受客户端改变状态。</p><p>改为<code>Owner authoritative mode</code>（ClientNetworkTransform）:</p><p><span class="exturl"><a class="exturl__link"   href="https://docs-multiplayer.unity3d.com/netcode/current/components/networktransform/#owner-authoritative-mode" >官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Netcode.Components;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Unity.Multiplayer.Samples.Utilities.ClientAuthority</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Used for syncing a transform with client side changes. This includes host. Pure server as owner isn&#x27;t supported by this. Please use NetworkTransform</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> for transforms that&#x27;ll always be owned by the server.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">DisallowMultipleComponent</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClientNetworkTransform</span> : <span class="title">NetworkTransform</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Used to determine who can write to this transform. Owner client only.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> This imposes state to the server. This is putting trust on your clients. Make sure no security-sensitive features use this transform.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">OnIsServerAuthoritative</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>缓冲帧：</p><p>客户端每帧从缓冲区取一帧的结果（或操作）同步。</p><p><img src="/../images/b326333c6a88b827e2db61d78100c72-1729852340628-4.png" alt="b326333c6a88b827e2db61d78100c72"></p>        <h3 id="Network-Rigidbody"   >          <a href="#Network-Rigidbody" class="heading-link"><i class="fas fa-link"></i></a><a href="#Network-Rigidbody" class="headerlink" title="Network Rigidbody"></a>Network Rigidbody</h3>              <h3 id="Network-Animator"   >          <a href="#Network-Animator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Network-Animator" class="headerlink" title="Network Animator"></a>Network Animator</h3>      <p>设为NetworkAnimator后，在<code>ServerRpc</code>中执行的参数会自动同步到客户端中。</p>        <h2 id="RPC"   >          <a href="#RPC" class="heading-link"><i class="fas fa-link"></i></a><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2>      <p>Remote Procedure Call Protocol，可以通过调用方法在服务器和客户端中实现交互，而无需关心底层数据传递。在游戏开发中也常采用前后端分离的开发方式，但使用Netcode时，前后端代码是一套的，因此要使用<code>[ServerRpc]</code>&#x2F;<code>[ClientRpc]</code>标记来区分服务端和客户端的方法。</p><ul><li><p>在<code>Network Behaviour</code>中可用</p></li><li><p>用<code>[ServerRpc]</code>或<code>[ClientRpc]</code>标记</p></li><li><p>方法名以<code>...ClientRpc()</code>或<code>...ServerRpc()</code>结尾</p></li><li><p>static function 不可设为RPC</p></li></ul>        <h3 id="ServerRpc"   >          <a href="#ServerRpc" class="heading-link"><i class="fas fa-link"></i></a><a href="#ServerRpc" class="headerlink" title="ServerRpc"></a>ServerRpc</h3>      <p>客户端只调用<code>ServerRpc()</code>方法但不执行。服务端收到请求（<strong>有延时</strong>）后对服务端版本的对象进行操作。</p><p><img src="/../images/bed19136f6485d0c249daf647f5370a.png" alt="bed19136f6485d0c249daf647f5370a"></p>        <h3 id="ClientRpc"   >          <a href="#ClientRpc" class="heading-link"><i class="fas fa-link"></i></a><a href="#ClientRpc" class="headerlink" title="ClientRpc"></a>ClientRpc</h3>      <p>由服务端调用后，在客户端（一个或多个）中执行。<strong>不同客户端之间会有延迟</strong>。</p><p><img src="/../images/88ad48bfa834395144cd6fd1dc0946e.png" alt="88ad48bfa834395144cd6fd1dc0946e"></p><p><strong>※无论是ServerRpc还是ClientRpc都不会在调用的瞬间完成，因此在代码上下文中需要考虑延迟。</strong></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//服务端执行以下代码，并让所有客户端执行ClientRPC部分的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!IsServer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (waitingRecipeList.Count == waitingRecipeMax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spawnRecipeTimer -= Time.deltaTime;</span><br><span class="line">    <span class="keyword">if</span> (spawnRecipeTimer &lt;= <span class="number">0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        spawnRecipeTimer = spawnRecipeTimerMax;</span><br><span class="line">        <span class="built_in">int</span> randamIndex = UnityEngine.Random.Range(<span class="number">0</span>, deliveryRecipeList.Count);</span><br><span class="line">        SpawnNewWaitingRecipeClientRPC(randamIndex); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端执行以下代码</span></span><br><span class="line">[<span class="meta">ClientRpc</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SpawnNewWaitingRecipeClientRPC</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SO_DeliveryRecipe recipe = deliveryRecipeList[index];</span><br><span class="line">    waitingRecipeList.Add(recipe);</span><br><span class="line">    OnRecipeSpawned?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="NetworkVariables"   >          <a href="#NetworkVariables" class="heading-link"><i class="fas fa-link"></i></a><a href="#NetworkVariables" class="headerlink" title="NetworkVariables"></a>NetworkVariables</h2>      <p>当RPC调用时，如果客户端处于断开状态就会<strong>丢失信息</strong>。因此，持续化的数据需要使用NetworkVariables来进行同步。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础类型</span></span><br><span class="line"><span class="keyword">public</span> NetworkVariable&lt;Vector3&gt; Position = <span class="keyword">new</span> NetworkVariable&lt;Vector3&gt;(初始值，读取权限,写入权限);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line">NetworkList&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line">NetworkDictionary&lt;T,U&gt;</span><br></pre></td></tr></table></div></figure><p>例：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">NetworkBehaviour</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMesh TextMesh;<span class="comment">//显示血量的文本</span></span><br><span class="line">    <span class="keyword">public</span> NetworkVariable&lt;<span class="built_in">int</span>&gt; HP = <span class="keyword">new</span> NetworkVariable&lt;<span class="built_in">int</span>&gt;(<span class="number">0</span>,NetworkVariableReadPermission.Everyone,NetworkVariableWritePermission.Server);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ServerRpc</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallServerRpc</span>(<span class="params">Vector3 position</span>)</span>&#123;</span><br><span class="line">        tranform.position += position;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ServerRpc</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallHPServerRpc</span>(<span class="params"><span class="built_in">int</span> hp</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在服务端设置网络变量值</span></span><br><span class="line">        HP.Value = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//通过IsOwner可以判断是否是本地客户端控制的Player</span></span><br><span class="line">        <span class="keyword">if</span>(IsOwner)&#123;</span><br><span class="line">            CallHPServerRpc(HP.<span class="keyword">value</span><span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有Player都要刷新血量，因此不判断IsOwner</span></span><br><span class="line">        TextMesh.text = HP.Value.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="前后端时间"   >          <a href="#前后端时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#前后端时间" class="headerlink" title="前后端时间"></a>前后端时间</h2>              <h1 id="2D游戏"   >          <a href="#2D游戏" class="heading-link"><i class="fas fa-link"></i></a><a href="#2D游戏" class="headerlink" title="2D游戏"></a>2D游戏</h1>              <h2 id="Sprite-Renderer"   >          <a href="#Sprite-Renderer" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a>Sprite Renderer</h2>              <h2 id="碰撞检测"   >          <a href="#碰撞检测" class="heading-link"><i class="fas fa-link"></i></a><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2>              <h3 id="Physics2D"   >          <a href="#Physics2D" class="heading-link"><i class="fas fa-link"></i></a><a href="#Physics2D" class="headerlink" title="Physics2D"></a>Physics2D</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包围圈，检测圈内有无碰撞。LayerMask可以指定检测的层级。</span></span><br><span class="line">Physics2D.OverlapCircle((Vector2)transform.position + bottomOffset, checkRadius, groundLayerMask);</span><br></pre></td></tr></table></div></figure>        <h3 id="Collider2D"   >          <a href="#Collider2D" class="heading-link"><i class="fas fa-link"></i></a><a href="#Collider2D" class="headerlink" title="Collider2D"></a>Collider2D</h3>      <p>Layer Overrides：</p><ul><li><p>Priority：规则矛盾时，采取规则的优先级，优先级相同，不会发生碰撞</p></li><li><p>Include Layers：发生碰撞的层级</p></li><li><p>Exclude Layers：不会产生碰撞的层级</p></li><li><p>Contact Capture Layers：</p></li><li><p>Callback Layers：触发回调函数的层级（OnCollisionXXX，OnTriggerXXX）</p></li></ul>        <h4 id="触发器"   >          <a href="#触发器" class="heading-link"><i class="fas fa-link"></i></a><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4>      <p>触发条件：</p><ul><li>双方都有<code>Collider</code>组件</li><li>其中一方必须是<code>Rigidbody</code></li><li>至少其中一方勾选<code>isTrigger</code></li></ul><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有物体进入触发器时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有物体离开触发器时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有物体触发时持续调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="3D游戏"   >          <a href="#3D游戏" class="heading-link"><i class="fas fa-link"></i></a><a href="#3D游戏" class="headerlink" title="3D游戏"></a>3D游戏</h1>              <h2 id="碰撞检测-1"   >          <a href="#碰撞检测-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#碰撞检测-1" class="headerlink" title="碰撞检测"></a>碰撞检测</h2>              <h3 id="Raycast"   >          <a href="#Raycast" class="heading-link"><i class="fas fa-link"></i></a><a href="#Raycast" class="headerlink" title="Raycast"></a>Raycast</h3>      <p>使用<code>Physics.CapsuleCast</code>可以判断前方是否有物体</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Physics.CapsuleCast(transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirection, moveDistance) </span><br></pre></td></tr></table></div></figure>        <h1 id="调试"   >          <a href="#调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#调试" class="headerlink" title="调试"></a>调试</h1>              <h2 id="Gizmos"   >          <a href="#Gizmos" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Object被选中时绘制</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//绘制圆框</span></span><br><span class="line">    Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h1 id="Shader"   >          <a href="#Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1>              <h2 id="MVP矩阵"   >          <a href="#MVP矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#MVP矩阵" class="headerlink" title="MVP矩阵"></a>MVP矩阵</h2>      <p>Model矩阵：从模型空间 → 世界空间</p><p>View矩阵：世界空间→视角空间（相对于摄像机）</p><p>Projection矩阵：视角空间→裁剪空间</p>        <h2 id="ShaderLab"   >          <a href="#ShaderLab" class="heading-link"><i class="fas fa-link"></i></a><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h2>      <div class="table-container"><table><thead><tr><th>Pass属性</th><th>作用</th></tr></thead><tbody><tr><td>NAME “xxx”</td><td>通过名字可以在其他shader中调用</td></tr><tr><td>Tags {“xx”&#x3D;”xx”}</td><td></td></tr><tr><td>CGPROGRAM &#x2F; ENDCG</td><td>用于标注shader语言的范围</td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h3 id="渲染队列"   >          <a href="#渲染队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h3>      <p>设置：<code>Tags &#123; &quot;Queue&quot; = &quot;XXX&quot; &#125;</code></p><div class="table-container"><table><thead><tr><th>名称</th><th>值</th><th></th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td></td></tr><tr><td>Geometry</td><td>2000</td><td>不透明物体，默认</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要进行AlphaTest的物体</td></tr><tr><td>Transparent</td><td>3000</td><td>半透明物体，从后往前渲染，一般不写入深度</td></tr><tr><td>Overlay</td><td>4000</td><td>覆盖效果，屏幕贴片，镜头光晕等</td></tr></tbody></table></div>        <h4 id="multi-pass-shader"   >          <a href="#multi-pass-shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#multi-pass-shader" class="headerlink" title="multi-pass shader"></a>multi-pass shader</h4>      <p>当一个shader中含有多个pass，unity会将该物体插在多个pass中<strong>值较小的渲染队列中</strong>，且按代码顺序执行pass。</p>        <h2 id="渲染路径-render-path"   >          <a href="#渲染路径-render-path" class="heading-link"><i class="fas fa-link"></i></a><a href="#渲染路径-render-path" class="headerlink" title="渲染路径 render path"></a>渲染路径 render path</h2>              <h3 id="前向渲染"   >          <a href="#前向渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h3>              <h3 id="延迟渲染"   >          <a href="#延迟渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h3>              <h2 id="屏幕空间坐标"   >          <a href="#屏幕空间坐标" class="heading-link"><i class="fas fa-link"></i></a><a href="#屏幕空间坐标" class="headerlink" title="屏幕空间坐标"></a>屏幕空间坐标</h2>      <p>计算片元在屏幕上的像素位置<code>ComputeScreenPos()</code></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：在vert中调用ComputeScreenPos()，保存到插值寄存器中</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">meshData v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//裁剪空间的齐次坐标，xy范围为[-w,w]</span></span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出为( (clip_x + clip_w)/2, (clip_y + clip_w)/2, clip_z, clip_w)</span></span><br><span class="line">    <span class="comment">//xy范围为[0,w]</span></span><br><span class="line">    o.scrPos = ComputeScreenPos(o.pos);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：用scrPos.xy 除以scrPos.w 得到[0,1]范围的屏幕空间坐标</span></span><br><span class="line"><span class="comment">//zw的范围为 透视投影([-Near, Far],[Near, Far])</span></span><br><span class="line"><span class="comment">//          正交投影([-1, 1],[1])</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>)</span>&#123;</span><br><span class="line">    float2 wcoord = (i.scrPos.xy/i.scrPos.w);</span><br><span class="line">    <span class="keyword">return</span> fixed4(wcoord,<span class="number">0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="曲面细分着色器"   >          <a href="#曲面细分着色器" class="heading-link"><i class="fas fa-link"></i></a><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h2>              <h3 id="LOD"   >          <a href="#LOD" class="heading-link"><i class="fas fa-link"></i></a><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h3>      <p>level of detail，近处的物体要求更高的精细度，但远处的物体不要求高精度。</p>        <h3 id="着色器执行顺序"   >          <a href="#着色器执行顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#着色器执行顺序" class="headerlink" title="着色器执行顺序"></a>着色器执行顺序</h3>      <p>通过曲面细分着色器，可以动态改变模型精度，从而减少CPU传入GPU的顶点信息。</p><p><img src="/../images/image-20241214121543927.png" alt="image-20241214121543927"></p>        <h3 id="TESS流程"   >          <a href="#TESS流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#TESS流程" class="headerlink" title="TESS流程"></a>TESS流程</h3>      <ul><li>输入：Patch，多个顶点及其属性的集合</li><li>Hull Shader：设定TESS factor，决定细分方式</li><li>Tessellation Primitive Generator：进行细分操作</li><li>Domain Shader：将细分后的点从重心空间转换到屏幕空间</li></ul>        <h3 id="Hull-Shader"   >          <a href="#Hull-Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hull-Shader" class="headerlink" title="Hull Shader"></a>Hull Shader</h3>      <p>OpenGL中称为Tessellation Control Shader</p><div class="table-container"><table><thead><tr><th>Tessellation Factor</th><th>决定将一条边细分的方式</th></tr></thead><tbody><tr><td>equal_spacing</td><td>等分</td></tr><tr><td>fractional_even_spacing</td><td>向上取最近的偶数，最小值为2</td></tr><tr><td>fractional_odd_spacing</td><td>最小值为1</td></tr></tbody></table></div>        <h3 id="Tessellation-Primitive-Generator"   >          <a href="#Tessellation-Primitive-Generator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tessellation-Primitive-Generator" class="headerlink" title="Tessellation Primitive Generator"></a>Tessellation Primitive Generator</h3>      <p>输入：Inner tessellation level，Outer tessellation level</p><p>输出：Triangles，Quads，Isolines</p>        <h3 id="Domain-Shader"   >          <a href="#Domain-Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Domain-Shader" class="headerlink" title="Domain Shader"></a>Domain Shader</h3>              <h2 id="几何着色器"   >          <a href="#几何着色器" class="heading-link"><i class="fas fa-link"></i></a><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2>      <p>一个图元（三角形）的所有顶点经过顶点着色器后，一并传入几何着色器。<strong>并行能力较顶点着色器更弱</strong>。</p><p><img src="/../images/image-20241214131841069.png" alt="image-20241214131841069"></p><ul><li>输入：经过顶点着色器后的一个图元的所有顶点信息</li><li>输出：独立于输入的顶点，线段，或三角形信息（三者之一）</li></ul>        <h3 id="输入"   >          <a href="#输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入" class="headerlink" title="输入"></a>输入</h3>      <div class="table-container"><table><thead><tr><th>输入类型</th><th>顶点数</th></tr></thead><tbody><tr><td>points</td><td>1</td></tr><tr><td>lines</td><td>2</td></tr><tr><td>triangles</td><td>3</td></tr><tr><td>lines_adjacency</td><td>4（线段和端点的相邻点）</td></tr><tr><td>triangles_adjacency</td><td>6（三角形和端点的相邻点）</td></tr></tbody></table></div>        <h3 id="输出"   >          <a href="#输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出" class="headerlink" title="输出"></a>输出</h3>      <div class="table-container"><table><thead><tr><th>输出类型</th><th></th></tr></thead><tbody><tr><td>line_strip</td><td>线段（不封口）</td></tr><tr><td>line_loop</td><td>线段（封口）</td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h2 id="测试"   >          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试" class="headerlink" title="测试"></a>测试</h2>              <h3 id="模板测试Stencil"   >          <a href="#模板测试Stencil" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板测试Stencil" class="headerlink" title="模板测试Stencil"></a>模板测试Stencil</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://docs.unity3d.com/Manual/SL-Stencil.html" >Unity官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h4 id="stencil-buffer"   >          <a href="#stencil-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#stencil-buffer" class="headerlink" title="stencil buffer"></a>stencil buffer</h4>      <p>对屏幕上的每个像素设置不同的stencil值（0~255），在每个Pass中可以决定只渲染特定stencil值的像素。</p><p>在目前的显卡架构中，stencil buffer和depth buffer连在一起，（如8位stencil，24位depth），因此模板测试中可以获取z-test的结果。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shaderlab中配置stencil test</span></span><br><span class="line">Stencil &#123;</span><br><span class="line"><span class="comment">//当前像素stencil值与ref值进行比较</span></span><br><span class="line">Ref <span class="number">0</span>           <span class="comment">//0-255</span></span><br><span class="line"><span class="comment">//测试条件：测试是否相等</span></span><br><span class="line">Comp Equal     <span class="comment">//default:always</span></span><br><span class="line"><span class="comment">//如果测试通过对此stencil值进行的写入操作：保持当前stencil值</span></span><br><span class="line">Pass keep       <span class="comment">//default:keep</span></span><br><span class="line"><span class="comment">//如果测试失败对此stencil值进行的写入操作：保持当前stencil值</span></span><br><span class="line"> Fail keep       <span class="comment">//default:keep</span></span><br><span class="line"> <span class="comment">//如果深度测试失败对此stencil值进行的写入操作：循环递增</span></span><br><span class="line">ZFail IncrWrap  <span class="comment">//default:keep</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="示例：物体描边"   >          <a href="#示例：物体描边" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：物体描边" class="headerlink" title="示例：物体描边"></a>示例：物体描边</h4>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/StentilOutline&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Stencil写在subshader中，对其中的所有pass执行</span></span><br><span class="line">        Stencil &#123;</span><br><span class="line">             Ref <span class="number">0</span>          <span class="comment">//0-255</span></span><br><span class="line">             Comp Equal     <span class="comment">//default:always</span></span><br><span class="line">             Pass IncrSat   <span class="comment">//default:keep</span></span><br><span class="line">             Fail keep      <span class="comment">//default:keep</span></span><br><span class="line">             ZFail keep     <span class="comment">//default:keep</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行第一个pass时，让其覆盖的所有像素stencil值变为1</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="comment">// make fog work</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> v2f</span><br><span class="line">&#123;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">float4 vertex : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// sample the texture</span></span><br><span class="line">fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line"><span class="comment">// apply fog</span></span><br><span class="line">UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">    <span class="comment">//return fixed4(1,1,0,1);</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行第二个pass时，在vert中让顶点向外偏移</span></span><br><span class="line">        <span class="comment">//原本有物体的像素，stencil值都变成了1，因此pass2只会在外围轮廓处渲染</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 normal: NORMAL;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex=v.vertex+normalize(v.normal)*<span class="number">0.01f</span>;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(o.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> fixed4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="深度测试"   >          <a href="#深度测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3>              <h4 id="z-buffer"   >          <a href="#z-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#z-buffer" class="headerlink" title="z-buffer"></a>z-buffer</h4>      <p>24位精度存储当前的深度缓冲</p><p>不写入深度缓冲的物体<strong>不会遮挡其他物体</strong></p><p><code>Always</code>通过深度缓冲的物体<strong>不会被其他物体遮挡</strong></p><p>通过<code>Z-test</code>才会写入深度</p><ul><li>半透明物体：只测试，不写入，开启混合</li></ul>        <h4 id="深度值"   >          <a href="#深度值" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度值" class="headerlink" title="深度值"></a>深度值</h4>      <p>深度缓冲中存储的是<strong>非线性值</strong>0~1</p><p>（越接近屏幕值越小）</p><p><img src="/../images/image-20241212161633485.png" alt="image-20241212161633485"></p>        <h4 id="early-Z"   >          <a href="#early-Z" class="heading-link"><i class="fas fa-link"></i></a><a href="#early-Z" class="headerlink" title="early-Z"></a>early-Z</h4>      <p>在片元着色器前进行深度测试和写入，提前舍弃片元  </p><p>early-Z失效的情况：</p><ul><li>开启AlphaTest 或 使用 clip&#x2F;discard手动丢弃片元的操作</li><li>开启Alpha Blend（不会深度写入）</li><li>关闭深度测试</li></ul>        <h4 id="Z-prepass"   >          <a href="#Z-prepass" class="heading-link"><i class="fas fa-link"></i></a><a href="#Z-prepass" class="headerlink" title="Z-prepass"></a>Z-prepass</h4>      <p>使用两个Pass，在第一个pass中只写入深度，第二个pass中用<code>equal</code>进行深度测试，并渲染</p><p>※多个pass的shader无法进行动态批处理</p>        <h2 id="混合模式"   >          <a href="#混合模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2>      <p>$$<br>Result &#x3D; SrcFactor *Src.rgb <Operation> DstFactor *Dst.rgb<br>$$</p><p>ShaderLab中<code>Blend SrcFactor DstFactor</code></p><p>常用混合模式：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透明度混合</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line"><span class="comment">//叠加</span></span><br><span class="line">Blend One One</span><br><span class="line"><span class="comment">//柔和相加</span></span><br><span class="line">Blend One OneMinusDstColor</span><br><span class="line"><span class="comment">//相乘(正片叠底)</span></span><br><span class="line">Blend DstColor Zero</span><br><span class="line"><span class="comment">//2倍相乘</span></span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"><span class="comment">//预乘透明度</span></span><br><span class="line">Blend One OneMinusSrcAlpha</span><br></pre></td></tr></table></div></figure>        <h3 id="使用Unity自带的枚举"   >          <a href="#使用Unity自带的枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Unity自带的枚举" class="headerlink" title="使用Unity自带的枚举"></a>使用Unity自带的枚举</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    [<span class="meta">Enum(UnityEngine.Rendering.BlendMode)</span>] _SrcBlend (<span class="string">&quot;SrcBlend&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    [<span class="meta">Enum(UnityEngine.Rendering.BlendMode)</span>] _DstBlend (<span class="string">&quot;DstBlend&quot;</span>, Float) = <span class="number">1</span>        </span><br><span class="line">    [<span class="meta">Enum(UnityEngine.Rendering.BlendOp)</span>] _BlendOp (<span class="string">&quot;BlendOp&quot;</span>, Float) = <span class="number">0</span>    </span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line">    Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">    BlendOp [_BlendOp]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="剔除"   >          <a href="#剔除" class="heading-link"><i class="fas fa-link"></i></a><a href="#剔除" class="headerlink" title="剔除"></a>剔除</h2>              <h3 id="法线剔除"   >          <a href="#法线剔除" class="heading-link"><i class="fas fa-link"></i></a><a href="#法线剔除" class="headerlink" title="法线剔除"></a>法线剔除</h3>      <p>根据法线朝向判断背向，正向摄像机的面，用于控制是否<strong>双面渲染</strong></p><p><code>Cull Off / Front / Back</code></p>        <h3 id="面裁切"   >          <a href="#面裁切" class="heading-link"><i class="fas fa-link"></i></a><a href="#面裁切" class="headerlink" title="面裁切"></a>面裁切</h3>      <p>在片元着色器中判断，将<code>value&lt;0</code>的像素丢弃，常用于做溶解等效果。使用Clip的pass最好在<code>AlphaTest</code>队列</p><p><code>Clip(value)</code></p>        <h2 id="纹理"   >          <a href="#纹理" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2>              <h3 id="Unity纹理坐标"   >          <a href="#Unity纹理坐标" class="heading-link"><i class="fas fa-link"></i></a><a href="#Unity纹理坐标" class="headerlink" title="Unity纹理坐标"></a>Unity纹理坐标</h3>      <p>竖直方向<strong>从下到上</strong>（0~1）</p>        <h3 id="法线贴图"   >          <a href="#法线贴图" class="heading-link"><i class="fas fa-link"></i></a><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3>      <p>bump mapping</p><p>normal mapping</p><p>displacement mapping</p><p>-&gt;per pixel displacement mapping</p><p>parallax mapping</p><p>steep parallax mapping</p><p>parallax occlusion mapping</p><p><img src="/../images/image-20241215154625129.png" alt="image-20241215154625129"></p>        <h3 id="Cubemap"   >          <a href="#Cubemap" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cubemap" class="headerlink" title="Cubemap"></a>Cubemap</h3>      <p>用于<strong>天空盒，环境映射</strong>。</p>        <h4 id="SkyBox"   >          <a href="#SkyBox" class="heading-link"><i class="fas fa-link"></i></a><a href="#SkyBox" class="headerlink" title="SkyBox"></a>SkyBox</h4>      <p>创建Skybox材质，Shader选择<code>Skybox/6 Sided</code>。</p>        <h4 id="环境映射"   >          <a href="#环境映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h4>      <p>手动创建，或在脚本中调用<code>Camera.RenderToCubemap</code>。</p><ul><li><strong>反射效果</strong></li></ul><p>​</p><ul><li><strong>折射效果</strong></li></ul>        <h3 id="Render-Texture"   >          <a href="#Render-Texture" class="heading-link"><i class="fas fa-link"></i></a><a href="#Render-Texture" class="headerlink" title="Render Texture"></a>Render Texture</h3>      <p>将摄像机的画面渲染到Target Texture中，实现镜子效果</p><ul><li>需要创建额外相机</li><li>效率更高，可以手动控制分辨率，摄像机的开启&#x2F;隐藏，调整摄像机的渲染层级</li></ul>        <h3 id="GrabPass"   >          <a href="#GrabPass" class="heading-link"><i class="fas fa-link"></i></a><a href="#GrabPass" class="headerlink" title="GrabPass"></a>GrabPass</h3>      <p>设置为透明队列（”Queue”&#x3D;”Transparent”）</p><ul><li>不需要创建相机</li><li>获取的图像分辨率和显示屏幕一致</li><li>使用command buffers可以得到类似效果</li></ul>        <h3 id="Procedural-Texture"   >          <a href="#Procedural-Texture" class="heading-link"><i class="fas fa-link"></i></a><a href="#Procedural-Texture" class="headerlink" title="Procedural Texture"></a>Procedural Texture</h3>      <p>由脚本生成，可以使用各种参数调整外观</p><ul><li>Substance Designer</li></ul>        <h3 id="FlowMap"   >          <a href="#FlowMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#FlowMap" class="headerlink" title="FlowMap"></a>FlowMap</h3>      <p>用RG通道表示二维向量场，模拟气体，液体的流动</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在片元着色器中：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采样flowmap，并映射到[-1,1]</span></span><br><span class="line">fixed4 flowDir = tex2D(_FlowMap, i.uv) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强度修正</span></span><br><span class="line">flowDir *= _FlowSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正负修正</span></span><br><span class="line"><span class="meta">#ifdef _REVERSE_FLOW_ON</span></span><br><span class="line">flowDir *= <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//周期变化</span></span><br><span class="line"><span class="built_in">float</span> phase0 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed);</span><br><span class="line"><span class="built_in">float</span> phase1 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">float2 tiling_uv = i.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line">half3 tex0 = tex2D(_MainTex, tiling_uv + flowDir.xy * phase0);</span><br><span class="line">half3 tex1 = tex2D(_MainTex, tiling_uv + flowDir.xy * phase1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> flowLerp = abs((<span class="number">0.5</span> - phase0) / <span class="number">0.5</span>);</span><br><span class="line">half3 finalColor = lerp(tex0, tex1, flowLerp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> float4(finalColor, <span class="number">1.0</span>) * _Color;</span><br></pre></td></tr></table></div></figure>        <h2 id="阴影"   >          <a href="#阴影" class="heading-link"><i class="fas fa-link"></i></a><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2>              <h3 id="投射或接收阴影"   >          <a href="#投射或接收阴影" class="heading-link"><i class="fas fa-link"></i></a><a href="#投射或接收阴影" class="headerlink" title="投射或接收阴影"></a>投射或接收阴影</h3>      <p>在<code>Mesh Renderer</code>组件中：</p><ul><li><code>Cast Shadows</code> ：开启后将该物体加入到光源的阴影映射纹理计算中（需要ShadownCaseter Pass）</li><li><code>Receive Shadows</code>：调用Unity内置宏和变量时，如果判断没有开启接受阴影，就不会计算。</li></ul>        <h3 id="ShadowMap技术"   >          <a href="#ShadowMap技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#ShadowMap技术" class="headerlink" title="ShadowMap技术"></a>ShadowMap技术</h3>      <p>Unity使用专门的Pass更新光源的阴影映射纹理，其<code>LightMode</code>为<code>ShadowCaster</code>。调用该Pass时，Unity会把摄像机放置到光源的位置上。</p><p>当开启了光源的阴影效果后，底层渲染引擎会在当前物体的Shader中寻找ShadowCaster Pass，若没有就去Fallback中找，如果还没有找到，<strong>该物体就无法向其他物体投射阴影（但可以接受其他物体的阴影）</strong>。</p>        <h4 id="ScreenSpace-ShadowMap"   >          <a href="#ScreenSpace-ShadowMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#ScreenSpace-ShadowMap" class="headerlink" title="ScreenSpace ShadowMap"></a>ScreenSpace ShadowMap</h4>      <p>※需要显卡支持MRT</p>        <h2 id="动画"   >          <a href="#动画" class="heading-link"><i class="fas fa-link"></i></a><a href="#动画" class="headerlink" title="动画"></a>动画</h2>      <p>相关内置变量</p><div class="table-container"><table><thead><tr><th>float4</th><th>描述</th></tr></thead><tbody><tr><td>_Time</td><td>场景开始加载所经过的时间：(t&#x2F;20, t, 2t, 3t)</td></tr><tr><td>_SinTime</td><td>时间的正弦值（t&#x2F;8, t&#x2F;4, t&#x2F;2, t）</td></tr><tr><td>_CosTime</td><td>时间是余弦值，分量同上</td></tr><tr><td>unity_DeltaTime</td><td>dt是时间增量，（dt, 1&#x2F;dt, smoothDt, 1&#x2F;smoothDt）</td></tr></tbody></table></div>        <h3 id="序列帧"   >          <a href="#序列帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列帧" class="headerlink" title="序列帧"></a>序列帧</h3>      <p>在每个时刻计算该时刻播放的关键帧的位置</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fragment shader</span></span><br><span class="line"><span class="comment">//把time作为行列索引</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">    <span class="built_in">float</span> time = floor(_Time.y * _Speed);</span><br><span class="line">    <span class="built_in">float</span> row = floor(time / _HorizontalAmount);</span><br><span class="line">    <span class="built_in">float</span> column = time - row * _VerticalAmount;</span><br><span class="line">    half2 uv = i.uv + half2(column, -row);</span><br><span class="line">    uv.x /= _HorizontalAmount;</span><br><span class="line">    uv.y /= _VerticalAmount;</span><br><span class="line">    <span class="keyword">return</span> fixed4(tex2D(_MainTex, uv), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="滚动"   >          <a href="#滚动" class="heading-link"><i class="fas fa-link"></i></a><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">meshData v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//让贴图采样的uv坐标随时间偏移</span></span><br><span class="line">    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0</span>) * _Time.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="顶点动画"   >          <a href="#顶点动画" class="heading-link"><i class="fas fa-link"></i></a><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3>      <p>※包含模型空间的顶点动画的shader要标注<code>DisableBatching</code>，</p><p>批处理会合并相关模型，导致各自的模型空间消失</p><p>※需自行实现ShadowCasterPass，否则会按照顶点偏移前的模型建立阴影</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    Tags &#123;</span><br><span class="line">        <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">        <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">        <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">        <span class="string">&quot;DisableBatching&quot;</span> = <span class="string">&quot;True&quot;</span>  <span class="comment">//禁止批处理</span></span><br><span class="line">         &#125;</span><br><span class="line">    Pass &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">v2f <span class="title">vert</span>(<span class="params">meshData v</span>)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            <span class="comment">//在转换到裁剪空间前进行顶点偏移</span></span><br><span class="line">            offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength) * _Magnitude;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex + offset);</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Billboarding"   >          <a href="#Billboarding" class="heading-link"><i class="fas fa-link"></i></a><a href="#Billboarding" class="headerlink" title="Billboarding"></a>Billboarding</h3>      <p>广告牌技术，根据视角方向来旋转一个被纹理着色的模型，使模型看起来<strong>总是面对摄像机</strong>。多用于渲染烟雾，云朵，闪光效果等。</p><p>旋转矩阵：</p><ul><li>基向量<ul><li>表面法线（N）</li><li>向上的方向（UP）</li><li>向右的方向（RIGHT）</li></ul></li><li>锚点：旋转过程中固定不变</li></ul><p>计算过程：表面法线和向上的方向，其中之一是固定的。</p><p>例如当模拟草丛时，向上的方向为(0,1,0)。</p><p>而当模拟粒子效果时，希望粒子正对视角方向，即表面法线&#x3D;视角方向。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器中</span></span><br><span class="line"><span class="comment">//选择模型空间的原点作为广告牌的锚点</span></span><br><span class="line"><span class="comment">//获取模型空间下的视角位置</span></span><br><span class="line">float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算旋转后的表面法线方向</span></span><br><span class="line">float3 normalDir = viewer - center;</span><br><span class="line"><span class="comment">//通过_VerticalBillboarding变量控制以UP方向为基准还是以法线方向为基准</span></span><br><span class="line"><span class="comment">//1：法线方向固定，0：UP方向固定</span></span><br><span class="line"></span><br><span class="line">normalDir.y =normalDir.y * _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"><span class="comment">//为了防止法线方向和UP方向平行，因此在法线方向为向上或向下时，改变UP方向</span></span><br><span class="line">float3 upDir = abs(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据法线方向和临时的UP计算出RIGHT，再叉积得到正交的UP方向</span></span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用基向量和锚点旋转模型</span></span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">              </span><br><span class="line">o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></div></figure>        <h2 id="噪声"   >          <a href="#噪声" class="heading-link"><i class="fas fa-link"></i></a><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2>              <h3 id="消融效果"   >          <a href="#消融效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#消融效果" class="headerlink" title="消融效果"></a>消融效果</h3>      <p>噪声纹理+透明度测试</p><p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line"><span class="keyword">fixed</span> _BurnAmount;  <span class="comment">//消融程度：1：完全消融</span></span><br><span class="line"><span class="keyword">fixed</span> _LineWidth;<span class="comment">//控制烧焦边缘的宽度</span></span><br><span class="line">fixed4 _BurnFirstColor;<span class="comment">//烧焦边缘颜色</span></span><br><span class="line">fixed4 _BurnSecondColor;<span class="comment">//烧焦边缘颜色</span></span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">sampler2D _BurnMap;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line">float4 _BurnMap_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭剔除，渲染背面</span></span><br><span class="line">Cull Off</span><br><span class="line">    </span><br><span class="line"><span class="comment">//片元着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">    <span class="comment">//对噪声纹理采样，剔除burn&lt;BurnAmount的部分</span></span><br><span class="line">    fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">    clip(burn.r - _BurnAmount);</span><br><span class="line">    </span><br><span class="line">    float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">    fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">    </span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">    </span><br><span class="line">    fixed3 ambient = UNITY_LILGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">    </span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(tangentNormal, tangentLightDir));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//混合系数t，t值为1，表明该像素即将消融</span></span><br><span class="line">    <span class="keyword">fixed</span> t = <span class="number">1</span> - smoothstep(<span class="number">0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">    <span class="comment">//越接近FirstColor，越后消融</span></span><br><span class="line">    fixeded3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line">    <span class="comment">//使颜色变暗，更接近烧焦的颜色</span></span><br><span class="line">    burnColor = pow(burnColor, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">    fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t* step(<span class="number">0.0001</span>, _BurnAmount));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义ShadowCaster</span></span><br><span class="line">Pass&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    CGPROGRAM</span><br><span class="line">        </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster //指明所需编译指令</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">fixed</span> _BurnAmount;</span><br><span class="line">sampler2D _BurnMap;</span><br><span class="line">float4 _BurnMap_ST; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> v2f &#123;</span><br><span class="line">V2F_SHADOW_CASTER;</span><br><span class="line">float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">appdata_base v</span>)</span> &#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line">clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line">SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">&#125;</span><br><span class="line">ENDCG    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="水波效果"   >          <a href="#水波效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#水波效果" class="headerlink" title="水波效果"></a>水波效果</h3>      <p>用噪声纹理修改水面的法线方向</p><p>把噪声纹理设为<code>Normal map</code>，并选择<code>Create from grayscale</code></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">## Post-processing Effect</span></span><br><span class="line"></span><br><span class="line">屏幕后处理效果，通常指的是渲染完整个场景后，再对图像进行一系列操作，实现各种屏幕特效。使用这种技术可以为游戏画面添加景深（Depth of Field），运动模糊（Mothion Blur）等艺术效果。</span><br><span class="line"></span><br><span class="line">屏幕后处理实际上是在场景中绘制了**屏幕大小的四边形，共四个顶点**。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 深度纹理</span></span><br><span class="line"></span><br><span class="line">深度和纹理在一张渲染纹理中存储了高精度的深度值，范围为[<span class="number">0</span>,<span class="number">1</span>]，通常是非线性分布。</span><br><span class="line"></span><br><span class="line">透视投影中，投影矩阵（非线性）对顶点缩放，经过齐次除法后得到NDC（归一化设备坐标normalized device coordinates）：</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20241120131052351</span>](../images/image<span class="number">-20241120131052351.</span>png)</span><br><span class="line"></span><br><span class="line">NDC中z分量范围在[<span class="number">-1</span>,<span class="number">1</span>]，因此要映射到[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">在Unity中，使用延迟渲染路径可以直接从G-buffer获得深度纹理。当无法直接获得深度缓存时，Unity会使用**着色器替换**，选择`RenderType = Opaque`的物体，判断它们的渲染队列是否`&lt;=<span class="number">2500</span>`。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 获取深度纹理</span></span><br><span class="line"></span><br><span class="line">```c<span class="meta">#</span></span><br><span class="line"><span class="comment">//脚本中设置摄像机模式</span></span><br><span class="line"><span class="comment">//获取深度纹理，在Shader中通过声明_CameraDepthTexture变量访问</span></span><br><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br><span class="line"><span class="comment">//获取深度+法线纹理，在Shader中通过声明_CameraDepthNormalsTexture变量访问</span></span><br><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></div></figure>        <h3 id="屏幕后处理脚本系统"   >          <a href="#屏幕后处理脚本系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#屏幕后处理脚本系统" class="headerlink" title="屏幕后处理脚本系统"></a>屏幕后处理脚本系统</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景渲染完成的生命周期函数，默认在所有不透明和透明的pass执行完毕后调用</span></span><br><span class="line"><span class="comment">//添加[ImageEffectOpaque]属性可以让该函数在执行透明物体pass前调用</span></span><br><span class="line"><span class="comment">//传入当前渲染图像src，最终在屏幕输出dest</span></span><br><span class="line">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在OnRenderImage中，通常利用Graphics.Blit函数进行处理</span></span><br><span class="line"><span class="comment">//src：传入的纹理</span></span><br><span class="line"><span class="comment">//dest：目标渲染纹理，不填则直接将结果显示在屏幕上</span></span><br><span class="line"><span class="comment">//mat：进行屏幕后处理操作的shader材质</span></span><br><span class="line"><span class="comment">//pass：-1为调用所有pass，否则调用指定pass</span></span><br><span class="line">Blit(Texture src, RenderTexture dest);</span><br><span class="line">Blit(Texture src, RenderTexture dest, Material mat, <span class="built_in">int</span> pass = <span class="number">-1</span>);</span><br><span class="line">Blit(Texture src, Material mat, <span class="built_in">int</span> pass = <span class="number">-1</span>);</span><br></pre></td></tr></table></div></figure><p><strong>后处理基类：</strong></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>] <span class="comment">//后处理效果必须挂载在摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//检测shader支持，并创建材质</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">&#123; <span class="keyword">return</span> material; &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//防止材质被保存，用于动态生成的材质</span></span><br><span class="line">                hideFlags = HideFlags.DontSave</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="keyword">if</span> (material) <span class="keyword">return</span> material;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>调整亮度，饱和度，对比度的后处理脚本：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line"><span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line"><span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="comment">//每当获取的时候都会检查材质是否可用</span></span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line">briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line"><span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置材质的输入变量</span></span><br><span class="line">material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"><span class="comment">//将material传递给shader中的_MainTex</span></span><br><span class="line">Graphics.Blit(src, dest, material);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Graphics.Blit(src, dest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast&quot;</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line"><span class="comment">//可以省略，不需要显示在面板中</span></span><br><span class="line">_MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_Brightness (<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">_Saturation(<span class="string">&quot;Saturation&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">_Contrast(<span class="string">&quot;Contrast&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass &#123;  </span><br><span class="line"><span class="comment">//屏幕后处理实际上是在场景中绘制了屏幕大小的四边形</span></span><br><span class="line"><span class="comment">//为了防止它对其他物体产生影响，关闭深度写入</span></span><br><span class="line">ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">CGPROGRAM  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">  </span><br><span class="line">sampler2D _MainTex;  </span><br><span class="line">half _Brightness;</span><br><span class="line">half _Saturation;</span><br><span class="line">half _Contrast;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> v2f &#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">half2 uv: TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//appdata_img 内置结构体，用于屏幕后处理</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">appdata_img v</span>)</span> &#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.uv = v.texcoord; </span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ENDCG</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="亮度，饱和度，对比度"   >          <a href="#亮度，饱和度，对比度" class="heading-link"><i class="fas fa-link"></i></a><a href="#亮度，饱和度，对比度" class="headerlink" title="亮度，饱和度，对比度"></a>亮度，饱和度，对比度</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Apply brightness</span></span><br><span class="line">fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply saturation</span></span><br><span class="line"><span class="keyword">fixed</span> luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply contrast</span></span><br><span class="line">fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></div></figure>        <h3 id="边缘检测"   >          <a href="#边缘检测" class="heading-link"><i class="fas fa-link"></i></a><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3>      <p>通过<strong>卷积（convolution）</strong>操作实现</p><p><img src="/../images/image-20241119173343678.png" alt="image-20241119173343678"></p><p>边缘检测使用两个卷积核，分别检测水平方向和竖直方向的边缘信息，再计算整体的梯度。<strong>梯度越大，越可能是边缘点。</strong><br>$$<br>G&#x3D;\sqrt{G_x^2+G_y^2} \ G&#x3D;|G_x|+|G_y|<br>$$<br>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line">sampler2D _MainTex;<span class="comment">//传入的渲染纹理</span></span><br><span class="line">half4 _MainTex_TexelSize; <span class="comment">//通过纹素计算相邻区域的纹理坐标</span></span><br><span class="line"><span class="keyword">fixed</span> _EdgeOnly;<span class="comment">//是否只显示边缘</span></span><br><span class="line">fixed4 _EdgeColor;<span class="comment">//边缘颜色</span></span><br><span class="line">fixed4 _BackgroundColor;<span class="comment">//只显示边缘时的背景颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">appdata_img v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算卷积所需9个相邻纹理坐标</span></span><br><span class="line">    <span class="comment">//在顶点着色器中计算可以提高性能</span></span><br><span class="line">    o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//目标点</span></span><br><span class="line">    o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">half <span class="title">Sobel</span>(<span class="params">v2f i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> half Gx[<span class="number">9</span>]=&#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                     <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> half Gy[<span class="number">9</span>]=&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">                     <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">                     <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    half texColor;</span><br><span class="line">    half edgeX = <span class="number">0</span>;</span><br><span class="line">    half edgeY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++)&#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">    &#125;</span><br><span class="line">    half edge = <span class="number">1</span> - abs(edgeX) - abs(edgeY);</span><br><span class="line">    <span class="keyword">return</span> edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i </span>) : SV_Target</span> &#123;</span><br><span class="line">    half edge = Sobel(i);</span><br><span class="line">    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>])， edge);</span><br><span class="line">    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">    <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>        <h4 id="使用深度-法线纹理"   >          <a href="#使用深度-法线纹理" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用深度-法线纹理" class="headerlink" title="使用深度+法线纹理"></a>使用深度+法线纹理</h4>      <p>利用深度差和法线差判断模型边界，不适合贴的紧的物体，例如桌子上的纸张。</p><p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line">sampler2D _MainTex;<span class="comment">//传入的渲染纹理</span></span><br><span class="line">half4 _MainTex_TexelSize; <span class="comment">//通过纹素计算相邻区域的纹理坐标</span></span><br><span class="line"><span class="keyword">fixed</span> _EdgeOnly;<span class="comment">//是否只显示边缘</span></span><br><span class="line">fixed4 _EdgeColor;<span class="comment">//边缘颜色</span></span><br><span class="line">fixed4 _BackgroundColor;<span class="comment">//只显示边缘时的背景颜色</span></span><br><span class="line"><span class="comment">//NEW:</span></span><br><span class="line"><span class="built_in">float</span> _SampleDistance;<span class="comment">//采样距离，值越大，描边越宽</span></span><br><span class="line">half4 _Sensitivity;<span class="comment">//xy为sensitivityNormals,sensitivityDepth</span></span><br><span class="line"><span class="comment">//zw为0,0</span></span><br><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">appdata_img v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用2x2卷积核</span></span><br><span class="line">    o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">    o.uv[<span class="number">1</span>] = uv+_MainTex_TexelSize.xy*half2(<span class="number">1</span>,<span class="number">1</span>)*_SampleDistance;</span><br><span class="line">    o.uv[<span class="number">2</span>] = uv+_MainTex_TexelSize.xy*half2(<span class="number">-1</span>,<span class="number">-1</span>)*_SampleDistance;</span><br><span class="line">    o.uv[<span class="number">3</span>] = uv+_MainTex_TexelSize.xy*half2(<span class="number">-1</span>,<span class="number">1</span>)*_SampleDistance;</span><br><span class="line">    o.uv[<span class="number">4</span>] = uv+_MainTex_TexelSize.xy*half2(<span class="number">1</span>,<span class="number">-1</span>)*_SampleDistance; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">fragRobertsCrossDepthAndNormal</span>(<span class="params">v2f i</span>):SV_Tartget</span>&#123;</span><br><span class="line">    half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">    half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">    half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">    half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">    </span><br><span class="line">    half edge = <span class="number">1.0</span>;</span><br><span class="line">    edge *= CheckSame(sample1,sample2);</span><br><span class="line">    edge *= CheckSame(sample3,sample4);</span><br><span class="line">    </span><br><span class="line">    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>])， edge);</span><br><span class="line">    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">    <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CheckSame：计算对角线上纹理值得差值，返回0/1，返回0时表明两点之间存在边界</span></span><br><span class="line"><span class="function">half <span class="title">CheckSame</span>(<span class="params">half4 center, half4 sample</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//没有解码法线，因为只需比较差异度</span></span><br><span class="line">    half2 centerNormal = center.xy;</span><br><span class="line">    <span class="built_in">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">    half2 sampleNormal = sample.xy;</span><br><span class="line">    <span class="built_in">float</span> sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line">    </span><br><span class="line">    half2 diffNormal = abs(centerNormal-sampleNormal)*_Sensitivity.x;</span><br><span class="line">    <span class="built_in">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> diffDepth = abs(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">    <span class="built_in">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//深度或法线有一个差异较大，就视为边界</span></span><br><span class="line">    <span class="keyword">return</span> isSameNormal*isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="高斯模糊"   >          <a href="#高斯模糊" class="heading-link"><i class="fas fa-link"></i></a><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3>      <p>卷积核：σ是标准方差，一般取值为1，因为最重要归一化，因此e前面的系数可以忽略。<br>$$<br>G(x,y)&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}<br>$$<br>优化①：通过把N·N高斯滤波分解成两个一维的高斯核，可以将采样次数从 N·N·W·H 降到 2·N·W·H。</p><p><img src="/../images/image-20241119183357367.png" alt="image-20241119183357367"></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(material != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【优化】对图像降采样，减少处理的像素个数</span></span><br><span class="line">        <span class="built_in">int</span> rtW = src.width/dowmSample;</span><br><span class="line">        <span class="built_in">int</span> rtH = src.height/dowmSample;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用降采样的缓冲区保存中间结果</span></span><br><span class="line">        RenderTexture buffer0 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">        buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过迭代加强效果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【优化】使用两次一维卷积</span></span><br><span class="line">        <span class="comment">//指定竖直方向pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定水平方向pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">&#125;</span><br><span class="line">        Graphics.Blit(buffer0, dest);</span><br><span class="line">        RenderTexture.RelieaseTemporary(buffer);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>shader:</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line"><span class="built_in">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="keyword">struct</span> v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    half2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//竖直方向pass,水平方向类似</span></span><br><span class="line"><span class="comment">//BlurSize控制采样距离，越大模糊程度越高，同时不改变采样数</span></span><br><span class="line"><span class="function">v2f <span class="title">vertBlurVertical</span>(<span class="params">appdata_img v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line">    o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">    o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>)* _BlurSize;</span><br><span class="line">    o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>)* _BlurSize;</span><br><span class="line">    o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>)* _BlurSize;</span><br><span class="line">    o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>)* _BlurSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pass共用的片元着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">fragBlur</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">    <span class="built_in">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">    fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> it = <span class="number">1</span>; it &lt;<span class="number">3</span>; it++)&#123;</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[it]).rgb * weight[<span class="number">1</span>];</span><br><span class="line">        sum += tex2D(_MainTex, i.uv[<span class="number">2</span>+it]).rgb * weight[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Bloom"   >          <a href="#Bloom" class="heading-link"><i class="fas fa-link"></i></a><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h3>      <ul><li>根据一个阈值，提取原图高亮区域</li></ul><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line">Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><ul><li><p>对高亮区域迭代高斯模糊</p></li><li><p>混合原图和高亮区域</p></li></ul><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">material.SetTexture(<span class="string">&quot;_Bloom&quot;</span>,buffer0);<span class="comment">//将处理后的高光传入纹理</span></span><br><span class="line">Graphics.Blit(src, dest, material, <span class="number">3</span>);</span><br></pre></td></tr></table></div></figure><p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">sampler2D _Bloom;</span><br><span class="line"><span class="built_in">float</span> _LuminanceThreshold;</span><br><span class="line"><span class="built_in">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PASS0：提取较量区域</span></span><br><span class="line"><span class="function">fixed4 <span class="title">fragExtractBright</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">    fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//根据阈值获取图像的亮度分布信息</span></span><br><span class="line">    <span class="keyword">fixed</span> val = clamp(luminance(c) - _LuminanceThreshold, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c*val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PASS1,2：高斯模糊的两个PASS</span></span><br><span class="line">UsePass <span class="string">&quot;../../GAUSSIAN_BLUR_VERTICAL&quot;</span></span><br><span class="line">UsePass <span class="string">&quot;../../GAUSSIAN_BLUR_HORIZONTAL&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//PASS3：混合图像</span></span><br><span class="line"><span class="function">v2f <span class="title">vertBloom</span>(<span class="params">appdata_img v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv.xy = v.texcoord;</span><br><span class="line">    o.uv.zw = v.texcoord;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//平台差异化处理 5.6.1节</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">    <span class="keyword">if</span>(_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">        o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">fragBloom</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="运动模糊"   >          <a href="#运动模糊" class="heading-link"><i class="fas fa-link"></i></a><a href="#运动模糊" class="headerlink" title="运动模糊"></a>运动模糊</h3>      <p>实现：</p><p>累积缓存(accumulation buffer)：混合一段时间内的多张图像</p><p>速度缓存(velocity buffer)：存储各个像素的运动速度，计算模糊方向和大小（通过深度纹理计算像素速度）</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (material != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//创建累积纹理</span></span><br><span class="line">        <span class="keyword">if</span>( accumulationTexture == <span class="literal">null</span> </span><br><span class="line">          || accumulationTexture.width != src.width</span><br><span class="line">          || accumulationTexture.height != src.height )&#123;</span><br><span class="line">            DestroyImmediate(accumulationTexture);</span><br><span class="line">            accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width,src.height<span class="number">.0</span>);</span><br><span class="line">            accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">            Graphics.Blit(src, accumulationTexture);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line">        Graphics.Blit(src, accumulationTexture, material);</span><br><span class="line">        Graphics.Blit(accumulationTexture, dest);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Graphics.Blit(src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="全局雾效"   >          <a href="#全局雾效" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局雾效" class="headerlink" title="全局雾效"></a>全局雾效</h3>      <p>根据深度纹理重建每个像素在世界空间下的位置：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界空间坐标 = 世界空间下摄像机坐标 + 线性深度值 × 插值后的射线</span></span><br><span class="line">worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay; </span><br></pre></td></tr></table></div></figure>        <h4 id="计算interpolatedRay"   >          <a href="#计算interpolatedRay" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算interpolatedRay" class="headerlink" title="计算interpolatedRay"></a>计算interpolatedRay</h4>      <p><img src="/../images/image-20241120175941773.png" alt="image-20241120175941773"></p><p>首先计算<code>toTop</code>，<code>toRight</code>：</p><p><code>halfHeight</code>：Near × tan(FOV&#x2F;2)</p><p><code>toTop</code>：camera.up × halfHeight</p><p><code>toRight</code>：camera.right × (halfHeight·aspect)</p><p>接着计算四个角相对于摄像机原点的向量：</p><p><code>TL</code>：camera.forward·Near + toTop - toRight</p><p>由于深度值是<strong>z方向的距离</strong>，要转换为实际距离</p><p>depth&#x2F;Near &#x3D; dist&#x2F;|TL| （仅对于TL射线上的点而言）</p>        <h4 id="计算雾效系数"   >          <a href="#计算雾效系数" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算雾效系数" class="headerlink" title="计算雾效系数"></a>计算雾效系数</h4>      <p>在简单的雾效实现中，需要一个雾效系数f用于混合图像和雾的颜色：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 afterFog = f * fogColor + (1-f) * origColor;</span><br></pre></td></tr></table></div></figure><p>在Unity内置的雾效实现中，有三种计算方式：</p><p>给定距离Z</p><p>线性中的d_min，d_max 为最小距离和最大距离</p><p>指数中的d为雾的浓度参数<br>$$<br>线性:f&#x3D;\frac{d_{max}-|z|}{d_{max}-d_{min}} \<br>指数:f&#x3D;e^{-d*|z|} \<br>指数平方:f&#x3D;e^{-(d-|z|)^2}<br>$$</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(material != <span class="literal">null</span>)&#123;</span><br><span class="line">        Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">        <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">        <span class="built_in">float</span> far = camera.farClipPlane;</span><br><span class="line">        <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Deg2Rad:角度转弧度</span></span><br><span class="line">        <span class="built_in">float</span> halfHeight= near * Mathf.Tan(fov*<span class="number">0.5f</span>*Mathf.Deg2Rad);</span><br><span class="line">        Vector3 toRight= camera.transform.right * halfHeight * aspect;</span><br><span class="line">        Vector3 toTop= camera.transform.up * halfHeight;</span><br><span class="line">        </span><br><span class="line">        Vector3 topLeft= camera.transform.forward*near+toTop-toRight;</span><br><span class="line">        <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">        </span><br><span class="line">        topLeft.Normalize();</span><br><span class="line">        topLeft *= scale;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...对topRight,bottomLeft,bottomRight进行相同操作</span></span><br><span class="line">        </span><br><span class="line">        frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">        frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">        frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">        frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">        </span><br><span class="line">        material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line">        material.SetMatrix(<span class="string">&quot;_ViewProjectionInverseMatrix&quot;</span>, </span><br><span class="line">       (camera.projectionMatrix*camera.worldToCameraMatrix).inverse);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所需变量</span></span><br><span class="line">float4x4 _FrustumCornersRay;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">sampler2D _CameraDepthTexture; <span class="comment">//Unity内置的深度纹理访问变量</span></span><br><span class="line">half _FogDensity;</span><br><span class="line">fixed4 _FogColor;</span><br><span class="line"><span class="built_in">float</span> _FogStart;</span><br><span class="line"><span class="built_in">float</span> _FogEnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">appdata_img v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vetex);</span><br><span class="line">    o.uv = v.texcoord;</span><br><span class="line">    o.uv_depth = v.texcoord;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...根据v.vertexcoord判断顶点是哪个角，确定index</span></span><br><span class="line">    o.interpolatedRay = _FrustumCornersRay[index];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器</span></span><br><span class="line"><span class="function"><span class="keyword">fixed</span> <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">    <span class="comment">//根据内置的函数采样深度纹理，并转换为线性深度值</span></span><br><span class="line">    <span class="built_in">float</span> linearDepth = LinearEyeDepth(</span><br><span class="line">        SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算世界空间坐标</span></span><br><span class="line">    float3 worldPos = _WorldSpaceCameraPos </span><br><span class="line">        + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用世界空间的高度计算线性雾效系数</span></span><br><span class="line">    <span class="built_in">float</span> fogDensity = (_FogEnd - worldPos.y)/(_FogEnd - _FogStart);</span><br><span class="line">    fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line">    </span><br><span class="line">    fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">    finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="风格化渲染"   >          <a href="#风格化渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#风格化渲染" class="headerlink" title="风格化渲染"></a>风格化渲染</h2>      <ul><li>基于色调的着色技术（Tone-based shading）</li><li>轮廓线渲染</li></ul>        <h3 id="轮廓线渲染"   >          <a href="#轮廓线渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#轮廓线渲染" class="headerlink" title="轮廓线渲染"></a>轮廓线渲染</h3>      <p>检测轮廓边：n_0和n_1为相邻三角面的法向，v是从视角到该边上任意顶点的方向。<br>$$<br>n_0·v&gt;0 \ne n_1·v&gt;0<br>$$</p>        <h3 id="过程式几何轮廓线渲染"   >          <a href="#过程式几何轮廓线渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#过程式几何轮廓线渲染" class="headerlink" title="过程式几何轮廓线渲染"></a>过程式几何轮廓线渲染</h3>      <p>对物体背面进行顶点偏移后，单色渲染为轮廓</p><p>对物体正面使用tone shading渲染光照</p><p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pass1:对背面进行轮廓描边</span></span><br><span class="line">Cull Front<span class="comment">//剔除正面</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> _Outline;<span class="comment">//描边粗细</span></span><br><span class="line">fixed4 _OutlineColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">meshData v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Model-View矩阵转换为视角空间</span></span><br><span class="line">float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Model-View的逆转置矩阵转换法线向量</span></span><br><span class="line">    <span class="comment">//因为向量无关平移，只需要3x3矩阵</span></span><br><span class="line">float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使法线z方向统一，扩展后的背面更加扁平，降低遮挡正面的可能性</span></span><br><span class="line">normal.z = <span class="number">-0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//沿法线方向偏移</span></span><br><span class="line">pos = pos + float4(normalize(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//变换到裁剪空间</span></span><br><span class="line">o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器直接输出轮廓颜色</span></span><br><span class="line"><span class="function">float4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123; </span><br><span class="line"><span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="风格化光照"   >          <a href="#风格化光照" class="heading-link"><i class="fas fa-link"></i></a><a href="#风格化光照" class="headerlink" title="风格化光照"></a>风格化光照</h3>      <p>Shader：</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f&#123;</span><br><span class="line">    float4 pos: POSITION;</span><br><span class="line">    float2 uv: TEXCOORD0;</span><br><span class="line">    float3 worldNormal: TEXCOORD1;</span><br><span class="line">    float3 worldPos: TEXCOORD2;</span><br><span class="line">    SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">meshData v</span>)</span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">    </span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);</span><br><span class="line">    </span><br><span class="line">    fixed4 c= tex2D(_MainTex, i.uv);</span><br><span class="line">    fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">    </span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">    </span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fixed</span> diff = dot(worldNormal, worldLightDir);</span><br><span class="line">    diff = (diff*<span class="number">0.5</span>+<span class="number">0.5</span>) * atten;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用HalfLambert对渐变纹理采样</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fixed</span> spec = dot(worldNormal, worldHalfDir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//邻域像素之间的近似导数值</span></span><br><span class="line">    <span class="keyword">fixed</span> w = fwidth(spec) * <span class="number">2.0</span>;</span><br><span class="line">    fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, smoothstep(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * step(<span class="number">0.0001</span>, _SpecularScale);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(ambient + diffuse + specular ,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Command-Buffers"   >          <a href="#Command-Buffers" class="heading-link"><i class="fas fa-link"></i></a><a href="#Command-Buffers" class="headerlink" title="Command Buffers"></a>Command Buffers</h2>      <p>存储渲染命令的缓冲区（如<code>set render target</code>，<code>draw mesh</code>等），通过在特定时机执行这些指令，扩展渲染管线。</p><p>绿色点：可以插入指令的时机</p><p><img src="/../images/image-20241216130242486.png" alt="image-20241216130242486"></p>        <h2 id="纹理压缩"   >          <a href="#纹理压缩" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h2>      <p>黄字为常见压缩格式</p><p><img src="/../images/image-20241216105605829.png" alt="image-20241216105605829"></p><div class="table-container"><table><thead><tr><th>非压缩格式</th><th></th></tr></thead><tbody><tr><td>RGBA32（8888）</td><td></td></tr><tr><td>RGBA16（4444）</td><td></td></tr><tr><td>RGB24（888）</td><td></td></tr><tr><td>RGB16（565）</td><td>人眼对绿光比较敏感，分配较高精度</td></tr></tbody></table></div>        <h3 id="DXTC"   >          <a href="#DXTC" class="heading-link"><i class="fas fa-link"></i></a><a href="#DXTC" class="headerlink" title="DXTC"></a>DXTC</h3>      <p>把4x4的像素块压缩为一个64或128位的数据块</p><p>DXT1：</p><p>color_0和color_1为4x4像素中的极端颜色值</p><p>再通过插值得到共4个颜色</p><p>每个像素存储2bit的索引值，对应4个颜色</p><p><img src="/../images/image-20241216110102348.png" alt="image-20241216110102348"></p><p><img src="/../images/image-20241216122540780.png" alt="image-20241216122540780"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Always separate the logic from the visuals in your game objects.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>tinyrenderer开源项目学习</title>
    <link href="https://lzmustb.github.io/2024/06/24/my-study-tinyrenderer/"/>
    <id>https://lzmustb.github.io/2024/06/24/my-study-tinyrenderer/</id>
    <published>2024-06-24T03:26:20.000Z</published>
    <updated>2024-06-24T05:18:27.169Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="tinyrenderer"   >          <a href="#tinyrenderer" class="heading-link"><i class="fas fa-link"></i></a><a href="#tinyrenderer" class="headerlink" title="tinyrenderer"></a>tinyrenderer</h1>      <p>source：<span class="exturl"><a class="exturl__link"   href="https://github.com/ssloy/tinyrenderer" >https://github.com/ssloy/tinyrenderer</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="线段绘制"   >          <a href="#线段绘制" class="heading-link"><i class="fas fa-link"></i></a><a href="#线段绘制" class="headerlink" title="线段绘制"></a>线段绘制</h2>              <h2 id="obj-格式"   >          <a href="#obj-格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#obj-格式" class="headerlink" title=".obj 格式"></a>.obj 格式</h2>      <div class="table-container"><table><thead><tr><th>顶点数据</th><th></th></tr></thead><tbody><tr><td>v</td><td>几何体顶点</td></tr><tr><td>vt</td><td>贴图坐标点</td></tr><tr><td>vn</td><td>顶点法线</td></tr><tr><td>vp</td><td>参数空格顶点</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>自由形态曲线&#x2F;表面属性</th><th></th></tr></thead><tbody><tr><td>deg</td><td>度</td></tr><tr><td>bmat</td><td>基础矩阵（basis matrix）</td></tr><tr><td>step</td><td>步尺寸</td></tr><tr><td>cstype</td><td>曲线或表面类型</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>元素</th><th></th></tr></thead><tbody><tr><td>p</td><td>点</td></tr><tr><td>l</td><td>线</td></tr><tr><td>f</td><td>面</td></tr><tr><td>curv</td><td>曲线</td></tr><tr><td>curv2</td><td>2D曲线</td></tr><tr><td>surf</td><td>表面</td></tr></tbody></table></div><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f 5/15/7 4/14/6 </span><br><span class="line"></span><br><span class="line">f：表示一个面，由三个v/vt/vn的索引形式组成。比如obj文件中f 5/15/7 4/14/6 6/16/8 ，表示由第5、第4、第6这三个顶点组成了一个三角平面,平面的纹理由第15、第14、第16这三个纹理坐标形成，这个平面的朝向是第7、第6、第8这三个顶点的法向量求平均值。</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;tinyrenderer&quot;   &gt;
          &lt;a href=&quot;#tinyrenderer&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#tinyrende</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>svg动画制作心得</title>
    <link href="https://lzmustb.github.io/2024/05/18/my-first-svg-animation/"/>
    <id>https://lzmustb.github.io/2024/05/18/my-first-svg-animation/</id>
    <published>2024-05-17T23:17:45.000Z</published>
    <updated>2024-05-18T00:24:14.689Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="制作过程"   >          <a href="#制作过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2>      <p>首先用illustrator创建svg文件。</p><p>将预计使用不同动画的元素分图层</p><p><img src="/../images/image-20240518082245734.png" alt="image-20240518082245734"></p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;制作过程&quot;   &gt;
          &lt;a href=&quot;#制作过程&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#制作过程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="个人作品" scheme="https://lzmustb.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81/"/>
    
    <category term="平面设计" scheme="https://lzmustb.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81/%E5%B9%B3%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="设计" scheme="https://lzmustb.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学笔记</title>
    <link href="https://lzmustb.github.io/2024/04/28/my-CG-notes/"/>
    <id>https://lzmustb.github.io/2024/04/28/my-CG-notes/</id>
    <published>2024-04-28T00:16:30.000Z</published>
    <updated>2025-08-22T02:30:00.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习图形学相关笔记</p><span id="more"></span>        <h2 id="Linear-Algebra"   >          <a href="#Linear-Algebra" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2>              <h3 id="Dot-Product-点积"   >          <a href="#Dot-Product-点积" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dot-Product-点积" class="headerlink" title="Dot Product 点积"></a>Dot Product 点积</h3>      <ul><li>投影</li><li>判断两向量方向接近程度</li></ul>        <h3 id="Cross-Product-叉积"   >          <a href="#Cross-Product-叉积" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cross-Product-叉积" class="headerlink" title="Cross Product 叉积"></a>Cross Product 叉积</h3>      <ul><li>法向</li></ul>        <h2 id="Transforms"   >          <a href="#Transforms" class="heading-link"><i class="fas fa-link"></i></a><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2>      <ul><li>Affine map(仿射变换)<ul><li>线性变换<ul><li>scale，reflection，shear，rotate</li></ul></li><li>平移translation</li></ul></li></ul>        <h3 id="homogenous-coordinates-齐次坐标"   >          <a href="#homogenous-coordinates-齐次坐标" class="heading-link"><i class="fas fa-link"></i></a><a href="#homogenous-coordinates-齐次坐标" class="headerlink" title="homogenous coordinates 齐次坐标"></a>homogenous coordinates 齐次坐标</h3>      <p><img src="/../images/image-20240428131949285.png" alt="image-20240428131949285"></p><p>point+point&#x3D;中点</p><p>三维坐标：(x, y, z, 1)^T^</p><p>三维向量：(x, y, z, 0)^T^</p><p>三维仿射变换：<br>$$<br>\begin{pmatrix}<br>x’\<br>y’\<br>z’\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>a&amp;b&amp;c&amp;t_{x}\<br>d&amp;e&amp;f&amp;t_{y}\<br>g&amp;h&amp;i&amp;t_{z}\<br>0&amp;0&amp;0&amp;1\<br>\end{pmatrix}<br>·<br>\begin{pmatrix}<br>x\<br>y\<br>z\<br>1<br>\end{pmatrix}<br>$$<br><img src="/../images/image-20240503155110384.png" alt="image-20240503155110384"></p><p>四元数 ：解决旋转插值计算</p>        <h3 id="Projection-transformation-投影变换"   >          <a href="#Projection-transformation-投影变换" class="heading-link"><i class="fas fa-link"></i></a><a href="#Projection-transformation-投影变换" class="headerlink" title="Projection transformation 投影变换"></a>Projection transformation 投影变换</h3>              <h4 id="Orthographic-正交投影"   >          <a href="#Orthographic-正交投影" class="heading-link"><i class="fas fa-link"></i></a><a href="#Orthographic-正交投影" class="headerlink" title="Orthographic 正交投影"></a>Orthographic 正交投影</h4>              <h2 id="光栅化-Rasterization"   >          <a href="#光栅化-Rasterization" class="heading-link"><i class="fas fa-link"></i></a><a href="#光栅化-Rasterization" class="headerlink" title="光栅化(Rasterization)"></a>光栅化(Rasterization)</h2>      <p>采样问题：锯齿，摩尔纹，车轮效应</p><p>本质：信号变化太快，采样速度太慢</p>        <h3 id="滤波"   >          <a href="#滤波" class="heading-link"><i class="fas fa-link"></i></a><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3>      <p>模糊操作→采样</p><p><img src="/../images/image-20240621100744327.png" alt="image-20240621100744327"></p><p>走样：</p><p><img src="/../images/image-20240621103544506.png" alt="image-20240621103544506"></p><p>卷积操作：</p><p><img src="/../images/image-20240621113523346.png" alt="image-20240621113523346"></p><p>MSAA（multy sample anti aliasing）：</p><p>在一个像素点上取多个采样点</p><p><img src="/../images/image-20240621134940537.png" alt="image-20240621134940537"></p><p>FXAA（fast approximate AA）：</p><p>将有锯齿的图像的边界修改</p><p>TAA（Temporal AA）：</p><p>与上一帧比较，复用上一帧的结果（MSAA的样本分布到时间上）</p>        <h3 id="Super-resolution（超分辨率）"   >          <a href="#Super-resolution（超分辨率）" class="heading-link"><i class="fas fa-link"></i></a><a href="#Super-resolution（超分辨率）" class="headerlink" title="Super resolution（超分辨率）"></a>Super resolution（超分辨率）</h3>      <p>从低分辨率拉伸到高分辨率</p><p>DLSS（deep learning super sampling）</p>        <h2 id="三角函数"   >          <a href="#三角函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2>              <h3 id="和差公式"   >          <a href="#和差公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#和差公式" class="headerlink" title="和差公式"></a>和差公式</h3>      <p>$$<br>sin(α±β)&#x3D;sinαcosβ±cosαsinβ \<br>\cos(\alpha \pm \beta) &#x3D; \cos \alpha \cos \beta \mp \sin \alpha \sin \beta \\tan(\alpha \pm \beta) &#x3D; \frac{\tan \alpha \pm \tan \beta}{1 \mp \tan \alpha \tan \beta}<br>$$</p>        <h3 id="倍角公式"   >          <a href="#倍角公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#倍角公式" class="headerlink" title="倍角公式"></a>倍角公式</h3>      <p>$$<br>sin2α&#x3D;2sinαcosα \<br>\cos 2\alpha &#x3D; \cos^2 \alpha - \sin^2 \alpha &#x3D; 2\cos^2 \alpha - 1 &#x3D; 1 - 2\sin^2 \alpha \<br>\tan 2\alpha &#x3D; \frac{2\tan \alpha}{1 - \tan^2 \alpha}<br>$$</p>        <h3 id="积化和差"   >          <a href="#积化和差" class="heading-link"><i class="fas fa-link"></i></a><a href="#积化和差" class="headerlink" title="积化和差"></a>积化和差</h3>      <p>$$<br>sinαsinβ&#x3D;21[cos(α−β)−cos(α+β)] \<br>\cos \alpha \cos \beta &#x3D; \frac{1}{2}[\cos(\alpha - \beta) + \cos(\alpha + \beta)]\<br>\sin \alpha \cos \beta &#x3D; \frac{1}{2}[\sin(\alpha + \beta) + \sin(\alpha - \beta)]<br>$$</p><p>利用和差公式相加、相减</p>        <h3 id="和差化积"   >          <a href="#和差化积" class="heading-link"><i class="fas fa-link"></i></a><a href="#和差化积" class="headerlink" title="和差化积"></a>和差化积</h3>      <p>$$<br>\sin \alpha + \sin \beta &#x3D; 2 \sin \frac{\alpha + \beta}{2} \cos \frac{\alpha - \beta}{2} \<br>\sin \alpha - \sin \beta &#x3D; 2 \cos \frac{\alpha + \beta}{2} \sin \frac{\alpha - \beta}{2}\<br>\cos \alpha + \cos \beta &#x3D; 2 \cos \frac{\alpha + \beta}{2} \cos \frac{\alpha - \beta}{2}\<br>\cos \alpha - \cos \beta &#x3D; -2 \sin \frac{\alpha + \beta}{2} \sin \frac{\alpha - \beta}{2}<br>$$</p><p>利用<code>α=u+v</code>，<code>β=u-v</code>，代入和差公式</p>        <h2 id="深度缓冲-Z-buffering"   >          <a href="#深度缓冲-Z-buffering" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度缓冲-Z-buffering" class="headerlink" title="深度缓冲 Z-buffering"></a>深度缓冲 Z-buffering</h2>      <p>画家算法：新画的覆盖旧画的东西</p><ul><li>给所有三角形排深度</li></ul><p>问题：</p><p><img src="/../images/image-20240621140940522.png" alt="image-20240621140940522"></p>        <h3 id="深度缓冲"   >          <a href="#深度缓冲" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h3>      <p>在每个<strong>像素点</strong>记录最小的<code>z</code>值</p><p>同时生成：</p><pre><code>* frame buffer：包含颜色信息的帧缓冲* depth buffer：存储每个像素点最小深度的缓冲（越小，离相机越近）</code></pre><p><img src="/../images/image-20240621141259865.png" alt="image-20240621141259865"></p><p>与渲染的顺序无关</p>        <h2 id="Shading-着色"   >          <a href="#Shading-着色" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shading-着色" class="headerlink" title="Shading 着色"></a>Shading 着色</h2>      <p>基本着色模型(Blinn-Phong Reflectance Model)</p><p><img src="/../images/image-20240621150901942.png" alt="image-20240621150901942"></p><ul><li>高光</li><li>漫反射</li><li>环境光</li></ul><p>计算每个着色点的光照：</p><p><img src="/../images/image-20240621151529357.png" alt="image-20240621151529357"></p><p>着色具有局部性：不考虑别的物体遮挡形成的影子</p>        <h3 id="漫反射"   >          <a href="#漫反射" class="heading-link"><i class="fas fa-link"></i></a><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3>      <p>某一点的漫反射光照能量与cosθ正相关</p><p><img src="/../images/image-20240621152152115.png" alt="image-20240621152152115"></p><p>光强随光源距离的减小情况：</p><p><img src="/../images/image-20240621152516916.png" alt="image-20240621152516916"></p><p><img src="/../images/image-20240621152748305.png" alt="image-20240621152748305"></p><p>※漫反射光照与观测方向没有关系</p>        <h3 id="高光"   >          <a href="#高光" class="heading-link"><i class="fas fa-link"></i></a><a href="#高光" class="headerlink" title="高光"></a>高光</h3>      <p>※观察方向和镜面反射方向接近时，可观察到高光</p><p>（换句话说，<strong>法线</strong>和<strong>半程向量</strong>接近）</p><p><img src="/../images/image-20240621160834949.png" alt="image-20240621160834949"></p><p>指数p可以调整阈值（通常在100~200，越大，高光越集中）</p><p><img src="/../images/image-20240621161210166.png" alt="image-20240621161210166"></p>        <h3 id="环境光"   >          <a href="#环境光" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3>      <p>简化为常数（实际考虑全局光照）</p><p><img src="/../images/image-20240621161415991.png" alt="image-20240621161415991"></p>        <h3 id="着色频率"   >          <a href="#着色频率" class="heading-link"><i class="fas fa-link"></i></a><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3>              <h4 id="平面着色"   >          <a href="#平面着色" class="heading-link"><i class="fas fa-link"></i></a><a href="#平面着色" class="headerlink" title="平面着色"></a>平面着色</h4>      <p><img src="/../images/image-20240621162234380.png" alt="image-20240621162234380"></p>        <h4 id="顶点着色"   >          <a href="#顶点着色" class="heading-link"><i class="fas fa-link"></i></a><a href="#顶点着色" class="headerlink" title="顶点着色"></a>顶点着色</h4>      <p><img src="/../images/image-20240621162320559.png" alt="image-20240621162320559"></p>        <h3 id="Phong着色"   >          <a href="#Phong着色" class="heading-link"><i class="fas fa-link"></i></a><a href="#Phong着色" class="headerlink" title="Phong着色"></a>Phong着色</h3>      <p><img src="/../images/image-20240621162434145.png" alt="image-20240621162434145"></p>        <h4 id="三角形内部点平滑过渡"   >          <a href="#三角形内部点平滑过渡" class="heading-link"><i class="fas fa-link"></i></a><a href="#三角形内部点平滑过渡" class="headerlink" title="三角形内部点平滑过渡"></a>三角形内部点平滑过渡</h4>      <p>在给每个像素着色时，需根据三角形顶点的属性（颜色，法向量等），给内部的属性做线性插值。</p><p><strong>重心坐标</strong>：三角形所在平面的点都可用三个顶点乘一定系数表示，</p><p>※α，β，γ非负时，点在三角形内部</p><p><img src="/../images/image-20240622091051864.png" alt="image-20240622091051864"></p><p>α，β，γ也可用面积比求出：</p><p><img src="/../images/image-20240622091455227.png" alt="image-20240622091455227"></p><p>※先做插值，再进行透视投影</p><p><img src="/../images/image-20240622091921538.png" alt="image-20240622091921538"></p>        <h3 id="比较"   >          <a href="#比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较" class="headerlink" title="比较"></a>比较</h3>      <p>横向采用相同模型。</p><p>当模型面数足够高时，三者效果相差不大</p><p><img src="/../images/image-20240621162539852.png" alt="image-20240621162539852"></p>        <h3 id="顶点法线"   >          <a href="#顶点法线" class="heading-link"><i class="fas fa-link"></i></a><a href="#顶点法线" class="headerlink" title="顶点法线"></a>顶点法线</h3>      <p>相邻面的法线求平均（加权）</p><p><img src="/../images/image-20240621162748412.png" alt="image-20240621162748412"></p>        <h3 id="阴影"   >          <a href="#阴影" class="heading-link"><i class="fas fa-link"></i></a><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3>              <h4 id="shadow-mapping"   >          <a href="#shadow-mapping" class="heading-link"><i class="fas fa-link"></i></a><a href="#shadow-mapping" class="headerlink" title="shadow mapping"></a>shadow mapping</h4>      <p>不在阴影里的点满足：</p><ol><li>被（点）光源照射</li><li>被相机观测</li></ol><p>记录点光源观测的图像深度，相机观测的深度与点光源观测的深度比较。</p>        <h2 id="图形渲染管线"   >          <a href="#图形渲染管线" class="heading-link"><i class="fas fa-link"></i></a><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2>      <p>图形输入到显示的一系列过程</p><p><img src="/../images/image-20240621175230389.png" alt="image-20240621175230389"></p>        <h2 id="纹理映射"   >          <a href="#纹理映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2>      <p><img src="/../images/image-20240621183616504.png" alt="image-20240621183616504"></p><p><img src="/../images/image-20240621183828955.png" alt="image-20240621183828955"></p><p><strong>texel</strong>：纹理上的一个像素 </p>        <h3 id="贴图过小"   >          <a href="#贴图过小" class="heading-link"><i class="fas fa-link"></i></a><a href="#贴图过小" class="headerlink" title="贴图过小"></a>贴图过小</h3>              <h4 id="双线性插值-Bilinear"   >          <a href="#双线性插值-Bilinear" class="heading-link"><i class="fas fa-link"></i></a><a href="#双线性插值-Bilinear" class="headerlink" title="双线性插值 Bilinear"></a>双线性插值 Bilinear</h4>      <p>映射在纹理上的非整数点，采用周围四个点的线性插值，以平滑放大纹理贴图</p><p><img src="/../images/image-20240622092937231.png" alt="image-20240622092937231"></p>        <h4 id="Bicubic"   >          <a href="#Bicubic" class="heading-link"><i class="fas fa-link"></i></a><a href="#Bicubic" class="headerlink" title="Bicubic"></a>Bicubic</h4>      <p>取16个点，三次线性插值</p>        <h3 id="贴图过大"   >          <a href="#贴图过大" class="heading-link"><i class="fas fa-link"></i></a><a href="#贴图过大" class="headerlink" title="贴图过大"></a>贴图过大</h3>      <p>Mipmap：范围查询（快速，近似，方形范围） </p><p>额外存储：源图像的1&#x2F;3（1&#x2F;4+1&#x2F;16+1&#x2F;64···）</p><p><img src="/../images/image-20240622095059440.png" alt="image-20240622095059440"></p><p><img src="/../images/image-20240622100025588.png" alt="image-20240622100025588"></p><p><img src="/../images/image-20240622100438789.png" alt="image-20240622100438789"></p>        <h4 id="问题"   >          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题" class="headerlink" title="问题"></a>问题</h4>      <p>屏幕空间的矩形区域在纹理空间中对应不规则的区域</p><p><img src="/../images/image-20240622101037850.png" alt="image-20240622101037850"></p>        <h3 id="各向异性过滤"   >          <a href="#各向异性过滤" class="heading-link"><i class="fas fa-link"></i></a><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h3>      <p><img src="/../images/image-20240622101114581.png" alt="image-20240622101114581"></p>        <h3 id="纹理应用"   >          <a href="#纹理应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h3>      <p>环境光纹理</p><p><img src="/../images/image-20240622115350899.png" alt="image-20240622115350899"></p><p><img src="/../images/image-20240622115721817.png" alt="image-20240622115721817"></p><p>凹凸贴图：改变任意位置的法线高度</p><p><img src="/../images/image-20240622120054431.png" alt="image-20240622120054431"></p><p>位移贴图：在凹凸贴图的基础上移动顶点（右图）</p><p><img src="/../images/image-20240622121120322.png" alt="image-20240622121120322"></p><p><strong>环境光遮蔽</strong>的计算结果包含在纹理中：</p><p><img src="/../images/image-20240622121603329.png" alt="image-20240622121603329"></p>        <h2 id="几何"   >          <a href="#几何" class="heading-link"><i class="fas fa-link"></i></a><a href="#几何" class="headerlink" title="几何"></a>几何</h2>      <ul><li><p>implicit （隐式）：</p><p>​定义一个几何体的<strong>点所满足的关系</strong></p><p>​f(x,y,z)&#x3D;0</p></li><li><p>explicit（显示）：</p><p>​直接给出所有点的坐标，或通过参数映射：</p><p><img src="/../images/image-20240622122844246.png" alt="image-20240622122844246"></p></li></ul>        <h3 id="隐式表示"   >          <a href="#隐式表示" class="heading-link"><i class="fas fa-link"></i></a><a href="#隐式表示" class="headerlink" title="隐式表示"></a>隐式表示</h3>              <h4 id="CSG"   >          <a href="#CSG" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSG" class="headerlink" title="CSG"></a>CSG</h4>      <p>Constructive Solid Geometry（implicit）</p><p>通过基本几何图形的布尔运算定义新图形</p><p><img src="/../images/image-20240622130458537.png" alt="image-20240622130458537"></p>        <h4 id="距离函数"   >          <a href="#距离函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#距离函数" class="headerlink" title="距离函数"></a>距离函数</h4>      <img src="../images/image-20240622132528640.png" alt="image-20240622132528640"  />        <h4 id="水平集"   >          <a href="#水平集" class="heading-link"><i class="fas fa-link"></i></a><a href="#水平集" class="headerlink" title="水平集"></a>水平集</h4>      <p><img src="/../images/image-20240622132721425.png" alt="image-20240622132721425"></p>        <h4 id="分形Fractals"   >          <a href="#分形Fractals" class="heading-link"><i class="fas fa-link"></i></a><a href="#分形Fractals" class="headerlink" title="分形Fractals"></a>分形Fractals</h4>      <p><img src="/../images/image-20240622132957335.png" alt="image-20240622132957335"></p>        <h3 id="显式表示"   >          <a href="#显式表示" class="heading-link"><i class="fas fa-link"></i></a><a href="#显式表示" class="headerlink" title="显式表示"></a>显式表示</h3>              <h4 id="点云"   >          <a href="#点云" class="heading-link"><i class="fas fa-link"></i></a><a href="#点云" class="headerlink" title="点云"></a>点云</h4>      <p>简单表示所有点的坐标</p>        <h4 id="多边形面Polygon-Mesh"   >          <a href="#多边形面Polygon-Mesh" class="heading-link"><i class="fas fa-link"></i></a><a href="#多边形面Polygon-Mesh" class="headerlink" title="多边形面Polygon Mesh"></a>多边形面Polygon Mesh</h4>              <h4 id="贝塞尔曲线"   >          <a href="#贝塞尔曲线" class="heading-link"><i class="fas fa-link"></i></a><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4>      <p>用一系列控制点定义曲线</p><p><img src="/../images/image-20240622135219977.png" alt="image-20240622135219977"></p><p><img src="/../images/image-20240622135706042.png" alt="image-20240622135706042"></p><p><img src="/../images/image-20240622135757216.png" alt="image-20240622135757216"></p><p>任意时刻t，贝塞尔曲线上的点都由控制点决定</p><p><img src="/../images/image-20240622140108914.png" alt="image-20240622140108914"></p><p><img src="/../images/image-20240622140348232.png" alt="image-20240622140348232"></p><p>性质：</p><ul><li><p><strong>对控制点进行仿射变换</strong>，等价于对贝塞尔曲线进行仿射变换。</p></li><li><p>曲线在控制点形成的凸包（Convex Hull）内</p></li></ul>        <h4 id="多段贝塞尔曲线"   >          <a href="#多段贝塞尔曲线" class="heading-link"><i class="fas fa-link"></i></a><a href="#多段贝塞尔曲线" class="headerlink" title="多段贝塞尔曲线"></a>多段贝塞尔曲线</h4>      <p>C^0^ 连续：第一段的终点和第二段的起点重合</p><p>C^1^ 连续：重合点与前后两点的距离相等（一阶导数相等）</p><p><img src="/../images/image-20240622141841377.png" alt="image-20240622141841377"></p><p>贝塞尔曲面：</p><p>将多个纵向贝塞尔曲线在<strong>t的值</strong>作为横向贝塞尔曲线的控制点</p><p><img src="/../images/image-20240622143056496.png" alt="image-20240622143056496"></p>        <h4 id="Spline-样条"   >          <a href="#Spline-样条" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spline-样条" class="headerlink" title="Spline 样条"></a>Spline 样条</h4>      <p>可控曲线</p><ul><li>Basic-splines 基函数样条</li></ul>        <h3 id="网格Mesh"   >          <a href="#网格Mesh" class="heading-link"><i class="fas fa-link"></i></a><a href="#网格Mesh" class="headerlink" title="网格Mesh"></a>网格Mesh</h3>      <ul><li>mesh subdivision</li><li>mesh simplification</li><li>mesh regulation</li></ul>        <h4 id="表面细分"   >          <a href="#表面细分" class="heading-link"><i class="fas fa-link"></i></a><a href="#表面细分" class="headerlink" title="表面细分"></a>表面细分</h4>              <h5 id="Loop-subdivision"   >          <a href="#Loop-subdivision" class="heading-link"><i class="fas fa-link"></i></a><a href="#Loop-subdivision" class="headerlink" title="Loop subdivision"></a>Loop subdivision</h5>      <p>​将三角形每条边一分为二（拆成四个三角形），用加权平均调整顶点位置</p>        <h5 id="Catmull-Clark-subdividion"   >          <a href="#Catmull-Clark-subdividion" class="heading-link"><i class="fas fa-link"></i></a><a href="#Catmull-Clark-subdividion" class="headerlink" title="Catmull-Clark subdividion"></a>Catmull-Clark subdividion</h5>      <img src="../images/image-20240622152635801.png" alt="image-20240622152635801" style="zoom:33%;" /><p>经过一次细分后，非四边形面消失，增加了相同数量的奇异点。</p><p>第二次及以后，奇异点数量不再变</p><p>​<img src="../images/image-20240622152853980.png" alt="image-20240622152853980" style="zoom:33%;" /></p><p>※可以适用于四边形网格</p>        <h4 id="网格简化"   >          <a href="#网格简化" class="heading-link"><i class="fas fa-link"></i></a><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h4>      <p>边坍缩Edge collapse：</p><p><img src="/../images/image-20240622153756363.png" alt="image-20240622153756363"></p><p><img src="/../images/image-20240622153818078.png" alt="image-20240622153818078"></p><p>从二次误差度量小的边开始坍缩</p>        <h2 id="光线追踪"   >          <a href="#光线追踪" class="heading-link"><i class="fas fa-link"></i></a><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2>      <p>光栅化的局限性：难以表现影响全局的效果（软阴影，磨砂镜面反射，多次反射的间接光照）</p><p>光线的定义：</p><ul><li>光沿直线传播</li><li>两束光线互不影响，不会发生碰撞</li><li>光从光源传到眼睛（观测）</li></ul>        <h3 id="递归光线追踪"   >          <a href="#递归光线追踪" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归光线追踪" class="headerlink" title="递归光线追踪"></a>递归光线追踪</h3>      <ul><li>找出经过反射后到达的所有点</li><li>shadow rays 判断点是否被遮挡</li><li>在原像素点按比例叠加所有点的颜色</li></ul><p><img src="/../images/image-20240623115207843.png" alt="image-20240623115207843"></p>        <h4 id="光线"   >          <a href="#光线" class="heading-link"><i class="fas fa-link"></i></a><a href="#光线" class="headerlink" title="光线"></a>光线</h4>      <p>定义：</p><img src="../images/image-20240623115446379.png" alt="image-20240623115446379" style="zoom: 33%;" /><p>求光线与平面（隐式表示）的交点：</p><img src="../images/image-20240623115917410.png" alt="image-20240623115917410" style="zoom:33%;" /><p>求光线与三角形网格（显示表示）的交点：</p><ul><li>求三角形所在平面与光线的交点</li><li>判断交点是否在三角形内</li></ul><p><img src="/../images/image-20240623123040874.png" alt="image-20240623123040874"></p><p>用重心坐标求：</p><p><img src="/../images/image-20240623123226865.png" alt="image-20240623123226865"></p>        <h3 id="优化"   >          <a href="#优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化" class="headerlink" title="优化"></a>优化</h3>              <h4 id="包围盒（AABB）"   >          <a href="#包围盒（AABB）" class="heading-link"><i class="fas fa-link"></i></a><a href="#包围盒（AABB）" class="headerlink" title="包围盒（AABB）"></a>包围盒（AABB）</h4>      <p>※光线碰不到包围盒，一定碰不到物体</p><p>※轴向包围盒可以用向量分量计算</p><p><img src="/../images/image-20240623123758121.png" alt="image-20240623123758121"></p><p>光线离开任何一组对面，离开包围盒</p><p>光线进入所有对面，进入包围盒</p><p><img src="/../images/image-20240623131028598.png" alt="image-20240623131028598"></p><p>t<del>exit</del>&lt;0:包围盒在光线背面</p><p>t<del>exit</del>&gt;&#x3D;0 &amp;&amp; t<del>enter</del>&lt;0:光线在包围盒内部，一定相交</p>        <h4 id="预处理"   >          <a href="#预处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4>              <h5 id="加速网格"   >          <a href="#加速网格" class="heading-link"><i class="fas fa-link"></i></a><a href="#加速网格" class="headerlink" title="加速网格"></a>加速网格</h5>      <p><img src="/../images/image-20240623133949406.png" alt="image-20240623133949406"></p>        <h5 id="空间划分-Spatial-Partitions"   >          <a href="#空间划分-Spatial-Partitions" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间划分-Spatial-Partitions" class="headerlink" title="空间划分 Spatial Partitions"></a>空间划分 Spatial Partitions</h5>      <p><img src="/../images/image-20240623134751776.png" alt="image-20240623134751776"></p><p><img src="/../images/image-20240623135320457.png" alt="image-20240623135320457"></p><p>光线和父节点相交，则继续判断是否和子节点相交。</p><p>问题：一个物体可能存在于多个盒子里；三角形和盒子边界求交集很麻烦</p>        <h5 id="物体划分-Object-partition"   >          <a href="#物体划分-Object-partition" class="heading-link"><i class="fas fa-link"></i></a><a href="#物体划分-Object-partition" class="headerlink" title="物体划分 Object  partition"></a>物体划分 Object  partition</h5>      <p>BVH（bounding volume hierarchy）</p><p><img src="/../images/image-20240623140825659.png" alt="image-20240623140825659"></p>        <h3 id="Basic-radiometry-辐射度量学"   >          <a href="#Basic-radiometry-辐射度量学" class="heading-link"><i class="fas fa-link"></i></a><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry 辐射度量学"></a>Basic radiometry 辐射度量学</h3>      <ul><li>radiant flux</li><li>intensity</li><li>irradiance</li><li>radiance</li></ul><p><img src="/../images/image-20240623151550414.png" alt="image-20240623151550414"></p><p><img src="/../images/image-20240623151822948.png" alt="image-20240623151822948"></p><p>立体角</p><p><img src="/../images/image-20240623152103942.png" alt="image-20240623152103942"></p><p><img src="/../images/image-20240623152349656.png" alt="image-20240623152349656"></p><img src="../images/image-20240623152616657.png" alt="image-20240623152616657" style="zoom:33%;" /><p><img src="/../images/image-20240623160256581.png" alt="image-20240623160256581"></p><p>intensity不变化，irradiance会随距离衰减</p><p><img src="/../images/image-20240626121234798.png" alt="image-20240626121234798"></p><p>radiance：</p><ul><li>irradiance per solid angle：单位立体角的irradiance</li><li>intensity per projected unit area：单位投影面积的光强</li></ul>        <h2 id="BRDF"   >          <a href="#BRDF" class="heading-link"><i class="fas fa-link"></i></a><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2>      <p>bidirectional reflectance distribution function：表示各个方向反射的能量分布</p><p><img src="/../images/image-20240626122927103.png" alt="image-20240626122927103"></p><p><img src="/../images/image-20240626125912466.png" alt="image-20240626125912466"></p>        <h3 id="渲染方程"   >          <a href="#渲染方程" class="heading-link"><i class="fas fa-link"></i></a><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3>      <p><img src="/../images/image-20240626130406788.png" alt="image-20240626130406788"></p><p>L&#x3D;E+KL(光源本身+辐射出来的能量，递归定义)</p><p>解L：光源本身+光源经过1次，2次…反射后的能量<img src="/../images/image-20240626131347498.png" alt="image-20240626131347498"></p><p>全局光照：光线经过无数次反射的光照集合</p>        <h2 id="概率论"   >          <a href="#概率论" class="heading-link"><i class="fas fa-link"></i></a><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2>              <h3 id="蒙特卡洛积分"   >          <a href="#蒙特卡洛积分" class="heading-link"><i class="fas fa-link"></i></a><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3>      <p>在积分域[a,b]间随机采样x<del>i</del> ,以f(x<del>i</del>)*(b-a)为一个采样面积，多次采样求平均。</p><p><img src="/../images/image-20240626140643735.png" alt="image-20240626140643735"></p><p>用概率密度计算：</p><p><img src="/../images/image-20240626141050572.png" alt="image-20240626141050572"></p>        <h2 id="路径追踪Path-tracing"   >          <a href="#路径追踪Path-tracing" class="heading-link"><i class="fas fa-link"></i></a><a href="#路径追踪Path-tracing" class="headerlink" title="路径追踪Path tracing"></a>路径追踪Path tracing</h2>      <p>利用蒙特卡洛积分计算渲染方程</p><p><img src="/../images/image-20240626142925238.png" alt="image-20240626142925238"></p><p>改进：物体反射的光照</p><p><img src="/../images/image-20240626143219835.png" alt="image-20240626143219835"></p><p>改进：一次路径追踪只追踪一根光照（N&#x3D;1），多次追踪求平均</p><p><img src="/../images/image-20240626143548214.png" alt="image-20240626143548214"></p><p>问题：递归没有中止</p>        <h3 id="俄罗斯轮盘法-RR"   >          <a href="#俄罗斯轮盘法-RR" class="heading-link"><i class="fas fa-link"></i></a><a href="#俄罗斯轮盘法-RR" class="headerlink" title="俄罗斯轮盘法 RR"></a>俄罗斯轮盘法 RR</h3>      <p>以规定的概率决定是否辐射光线</p><p><img src="/../images/image-20240626144344445.png" alt="image-20240626144344445"></p><p>问题：从着色点均匀采样，会有很多样本浪费</p><p><img src="/../images/image-20240626144716970.png" alt="image-20240626144716970"></p>        <h3 id="采样光源"   >          <a href="#采样光源" class="heading-link"><i class="fas fa-link"></i></a><a href="#采样光源" class="headerlink" title="采样光源"></a>采样光源</h3>      <p>渲染方程需对光源积分：找出dω和dA的关系</p><p><img src="/../images/image-20240626145150937.png" alt="image-20240626145150937"></p><p><img src="/../images/image-20240626145432887.png" alt="image-20240626145432887"></p><p>pdf：1&#x2F;A</p><p><img src="/../images/image-20240626145903294.png" alt="image-20240626145903294"></p>        <h2 id="材质"   >          <a href="#材质" class="heading-link"><i class="fas fa-link"></i></a><a href="#材质" class="headerlink" title="材质"></a>材质</h2>      <p><strong>BSDF（BRDF+BTDF）</strong>决定了物体的材质。</p>        <h1 id="Shader"   >          <a href="#Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1>              <h2 id="基本操作"   >          <a href="#基本操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2>      <p>iResolution：shadertoy提供的内置变量，</p><p>iResolution.xy &#x3D;&#x3D;(iResolution.x,iResolution.y)</p><pre><code>* iResolution.x：画布宽度* iResolution.y：画布高度* iResolution.z：画布深度</code></pre><p>fragCoord：画布上的每个像素点</p><p>fracColor：对应点的颜色</p><figure class="highlight glsl"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    <span class="comment">//坐标缩放为[-1,-1]~[1,1]</span></span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="法线变换"   >          <a href="#法线变换" class="heading-link"><i class="fas fa-link"></i></a><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h3>      <p>使用原变换矩阵的<strong>逆转置矩阵</strong></p>        <h3 id="坐标轴变换"   >          <a href="#坐标轴变换" class="heading-link"><i class="fas fa-link"></i></a><a href="#坐标轴变换" class="headerlink" title="坐标轴变换"></a>坐标轴变换</h3>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆点移到中心 uv=[-1,1]</span></span><br><span class="line">uv = uv*<span class="number">2.</span><span class="number">-1.</span>;</span><br><span class="line"><span class="comment">//放大，缩小 (uv变小，画面变大)</span></span><br><span class="line">uv *= <span class="number">0.01</span>;</span><br></pre></td></tr></table></div></figure>        <h3 id="旋转"   >          <a href="#旋转" class="heading-link"><i class="fas fa-link"></i></a><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mat2 <span class="title function_">rot2D</span><span class="params">(<span class="type">float</span> angle)</span>&#123;</span><br><span class="line">    <span class="type">float</span> s=<span class="built_in">sin</span>(angle);</span><br><span class="line">    <span class="type">float</span> c=<span class="built_in">cos</span>(angle);</span><br><span class="line">    <span class="keyword">return</span> mat2(c,-s,s,c); <span class="comment">//2x2的旋转矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.xz *= rot2D(<span class="number">0.3</span>) <span class="comment">//绕y轴旋转</span></span><br></pre></td></tr></table></div></figure>        <h2 id="texture-mapping"   >          <a href="#texture-mapping" class="heading-link"><i class="fas fa-link"></i></a><a href="#texture-mapping" class="headerlink" title="texture mapping"></a>texture mapping</h2>      <p>在贴图映射时，可以使用本地坐标，也可以使用世界坐标。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Textured&quot;</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;Texture&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//&quot;white&quot;为默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;</span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>, <span class="comment">//预处理相关</span></span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span> <span class="comment">//渲染顺序相关</span></span><br><span class="line">        &#125; </span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">struct</span> MeshData&#123;</span><br><span class="line">            float4 vertex:POSITION; <span class="comment">//网格的本地坐标</span></span><br><span class="line">            float2 uv:TEXCOORD0; <span class="comment">//uv</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">struct</span> Interpolators&#123;</span><br><span class="line">                float4 vertex: SV_POSITION;</span><br><span class="line">                float2 uv: TEXCOORD0;</span><br><span class="line">                float3 worldPos: TEXCOORD1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="function">Interpolators <span class="title">vert</span>(<span class="params">MeshData v</span>)</span>&#123;</span><br><span class="line">                Interpolators o;</span><br><span class="line">                o.worldPos = mul(UNITY_MATRIX_M,v.vertex);<span class="comment">//顶点坐标转换到世界坐标</span></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex); <span class="comment">//顶点坐标转换到屏幕空间</span></span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                o.uv.x += _Time.y * <span class="number">0.1</span>; <span class="comment">//随事件偏移uv</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">float4 <span class="title">frag</span>(<span class="params">Interpolators i</span>):SV_Target</span>&#123;</span><br><span class="line">                float2 topDownProjection = i.worldPos.xz;</span><br><span class="line">                float4 moss=tex2D(_MainTex,topDownProjection);<span class="comment">//根据世界坐标从贴图采样</span></span><br><span class="line">                <span class="keyword">return</span> moss;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Environment-Mapping"   >          <a href="#Environment-Mapping" class="heading-link"><i class="fas fa-link"></i></a><a href="#Environment-Mapping" class="headerlink" title="Environment Mapping"></a>Environment Mapping</h2>              <h2 id="multyPasses-Forward-rendering"   >          <a href="#multyPasses-Forward-rendering" class="heading-link"><i class="fas fa-link"></i></a><a href="#multyPasses-Forward-rendering" class="headerlink" title="multyPasses(Forward rendering)"></a>multyPasses(Forward rendering)</h2>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader<span class="string">&quot;...&quot;</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;</span><br><span class="line">            <span class="string">&#x27;...&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags &#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;FGLighting.cginc&quot;</span></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags &#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span>&#125;</span><br><span class="line">            Blend One One <span class="comment">//混合模式，叠加</span></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwadd</span></span><br><span class="line">            <span class="meta">#include &quot;FGLighting.cginc&quot;</span></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="噪声"   >          <a href="#噪声" class="heading-link"><i class="fas fa-link"></i></a><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2>              <h3 id="Value-Noise"   >          <a href="#Value-Noise" class="heading-link"><i class="fas fa-link"></i></a><a href="#Value-Noise" class="headerlink" title="Value Noise"></a>Value Noise</h3>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先通过合适的函数，返回分布比较散的[0,1]的值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">hash</span><span class="params">(vec2 seed)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fract(<span class="built_in">sin</span>(seed.x*<span class="number">123.</span> + seed.y*<span class="number">231.</span>)*<span class="number">1241.</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将随机值的分布连续化</span></span><br><span class="line"><span class="comment">//方法一：ValueNoise</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getNoise</span><span class="params">(vec2 uv,<span class="type">float</span> gridSize)</span>&#123;</span><br><span class="line">    <span class="comment">//将坐标分布在[(0,0),(gridSize,gridSize)]的网格中</span></span><br><span class="line">    vec2 currentGrid=vec2(<span class="built_in">floor</span>(uv.x*gridSize),<span class="built_in">floor</span>(uv.y*gridSize));</span><br><span class="line">    <span class="comment">//获取网格四个顶点的随机值</span></span><br><span class="line">    <span class="type">float</span> value00=hash(currentGrid);</span><br><span class="line">    <span class="type">float</span> value01=hash(vec2(currentGrid.x,currentGrid.y+<span class="number">1.</span>));</span><br><span class="line">    <span class="type">float</span> value10=hash(vec2(currentGrid.x+<span class="number">1.</span>,currentGrid.y));</span><br><span class="line">    <span class="type">float</span> value11=hash(vec2(currentGrid.x+<span class="number">1.</span>,currentGrid.y+<span class="number">1.</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行线性插值</span></span><br><span class="line">    <span class="type">float</span> value0=mix(value00,value01,fract(uv.y*gridSize));</span><br><span class="line">    <span class="type">float</span> value1=mix(value10,value11,fract(uv.y*gridSize));</span><br><span class="line">    <span class="type">float</span> value=mix(value0,value1,fract(uv.x*gridSize));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或使用smoothstep让分布更加平滑</span></span><br><span class="line">    <span class="type">float</span> value0=mix(value00,value01,smoothstep(<span class="number">0.</span>,<span class="number">1.</span>,fract(uv.y*gridSize)));</span><br><span class="line">    <span class="type">float</span> value1=mix(value10,value11,smoothstep(<span class="number">0.</span>,<span class="number">1.</span>,fract(uv.y*gridSize)));</span><br><span class="line">    <span class="type">float</span> value=mix(value0,value1,smoothstep(<span class="number">0.</span>,<span class="number">1.</span>,fract(uv.x*gridSize)));    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//可以叠加不同频率，得到更平滑的值(FBM)</span></span><br><span class="line">    value+=valueNoise(uv,gridSize*<span class="number">2.</span>)*<span class="number">0.5</span>;</span><br><span class="line">    value+=valueNoise(uv,gridSize*<span class="number">4.</span>)*<span class="number">0.25</span>;</span><br><span class="line">    value+=valueNoise(uv,gridSize*<span class="number">8.</span>)*<span class="number">0.125</span>;</span><br><span class="line">    value+=valueNoise(uv,gridSize*<span class="number">16.</span>)*<span class="number">0.0625</span>;</span><br><span class="line">    value/=<span class="number">1.9375</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img src="/../images/image-20241105144243678.png" alt="image-20241105144243678"></p>        <h3 id="Gradient-Noise"   >          <a href="#Gradient-Noise" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gradient-Noise" class="headerlink" title="Gradient Noise"></a>Gradient Noise</h3>              <h3 id="voronoi"   >          <a href="#voronoi" class="heading-link"><i class="fas fa-link"></i></a><a href="#voronoi" class="headerlink" title="voronoi"></a>voronoi</h3>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vec2 <span class="title function_">hashPoint</span><span class="params">(vec2 seed)</span>&#123;</span><br><span class="line">    vec3 a=fract(seed.xyx*vec3(<span class="number">123.34</span>,<span class="number">234.34</span>,<span class="number">345.65</span>));</span><br><span class="line">    a+=dot(a,a+<span class="number">34.45</span>);</span><br><span class="line">    <span class="keyword">return</span> fract(vec2(a.x*a.y,a.y*a.z)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">voronoi</span><span class="params">(vec2 uv,<span class="type">float</span> gridSize)</span>&#123;</span><br><span class="line">    <span class="type">float</span> t=iTime*<span class="number">.2</span>+<span class="number">200.</span>;</span><br><span class="line">    <span class="type">float</span> minDist=<span class="number">100.</span>; <span class="comment">//到随机点最短的距离</span></span><br><span class="line">    vec2 cellIndex=vec2(<span class="number">0.</span>); <span class="comment">//最短距离所指向的点</span></span><br><span class="line"></span><br><span class="line">    uv*=gridSize;</span><br><span class="line">    vec2 gv=fract(uv)<span class="number">-.5</span>;</span><br><span class="line">    vec2 id=<span class="built_in">floor</span>(uv);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y=<span class="number">-1.</span>;y&lt;=<span class="number">1.</span>;y++)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> x=<span class="number">-1.</span>;x&lt;=<span class="number">1.</span>;x++)&#123;</span><br><span class="line">        </span><br><span class="line">            vec2 offset=vec2(x,y);</span><br><span class="line">            vec2 n=hashPoint(id+offset);</span><br><span class="line">            vec2 p=offset+<span class="built_in">sin</span>(n*t)*<span class="number">.5</span>; <span class="comment">//-1~1的随机向量</span></span><br><span class="line">            <span class="type">float</span> d=length(gv-p);</span><br><span class="line">            <span class="keyword">if</span>(d&lt;minDist)&#123;</span><br><span class="line">                minDist=d;</span><br><span class="line">                cellIndex=id+offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用cellIndex可以对特定网格进行操作</span></span><br><span class="line">    <span class="keyword">return</span> minDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="排列"   >          <a href="#排列" class="heading-link"><i class="fas fa-link"></i></a><a href="#排列" class="headerlink" title="排列"></a>排列</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons" >wiki</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="Truchet-Tiling"   >          <a href="#Truchet-Tiling" class="heading-link"><i class="fas fa-link"></i></a><a href="#Truchet-Tiling" class="headerlink" title="Truchet Tiling"></a>Truchet Tiling</h3>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入2，输出1的hash函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Hash21</span><span class="params">(vec2 p)</span>&#123;</span><br><span class="line">  p=fract(p*vec2(<span class="number">234.34</span>,<span class="number">435.345</span>));</span><br><span class="line">    p +=dot(p,p+<span class="number">34.23</span>);</span><br><span class="line">    <span class="keyword">return</span> fract(p.x*p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">TruchetTiling</span><span class="params">(vec2 uv,<span class="type">float</span> gridSize)</span>&#123;</span><br><span class="line">   uv *= gridSize;</span><br><span class="line">    vec2 gv = fract(uv)<span class="number">-.5</span>; <span class="comment">//获取在网格内的相对坐标[-0.5,0.5]</span></span><br><span class="line">    vec2 id = <span class="built_in">floor</span>(uv);    <span class="comment">//获取所在网格的序号</span></span><br><span class="line">    <span class="type">float</span> n = Hash21(id);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> width =<span class="number">.1</span>; <span class="comment">//线宽</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">.5</span>) gv.x *= <span class="number">-1</span>; <span class="comment">//随即翻转</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">abs</span>(<span class="built_in">abs</span>(gv.x+gv.y)<span class="number">-.5</span>); <span class="comment">//将连线的顶点平移到网格边的中心</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> mask = smoothstep(<span class="number">.01</span>,<span class="number">-.01</span>,d-width);</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="RayMarching"   >          <a href="#RayMarching" class="heading-link"><i class="fas fa-link"></i></a><a href="#RayMarching" class="headerlink" title="RayMarching"></a>RayMarching</h2>      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STEPS 100 <span class="comment">//迭代的最大步数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DIST 100. <span class="comment">//超出该距离视为射线不再碰撞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SURF_DIST .01 <span class="comment">//小于该距离视为射线已经碰撞</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetDist</span><span class="params">(vec3 p)</span>&#123;</span><br><span class="line">    SDF1 = ... <span class="comment">//到不同的物体有需要不同的距离函数</span></span><br><span class="line">    <span class="keyword">return</span> min(SDF1,SDF2...,); <span class="comment">//选择所有距离中最小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetLight</span><span class="params">(vec3 p)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetShadow</span><span class="params">(vec3 p)</span>&#123;</span><br><span class="line">    <span class="comment">//从p点进行rayMarch，如果dist&lt;p到lightPos的距离，则为阴影</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">RayMarch</span><span class="params">(vec3 ro,vec3 rd)</span>&#123; <span class="comment">//ro:rayOrigin rd:rayDistance</span></span><br><span class="line"><span class="type">float</span> d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_STEPS; i++)&#123;</span><br><span class="line">        vec3 p = ro+d*rd;</span><br><span class="line">        <span class="type">float</span> dS = GetDist(p);</span><br><span class="line">        d += dS;</span><br><span class="line">        <span class="keyword">if</span>(dS&lt;SURFACE_DIST || d&gt;MAX_DIST) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="法线方向"   >          <a href="#法线方向" class="heading-link"><i class="fas fa-link"></i></a><a href="#法线方向" class="headerlink" title="法线方向"></a>法线方向</h3>      <p>对于任意SDF f(p)，f(p)&#x3D;0的点p将构成一个表面。因此p点的法线向量可以表示为：<br>$$<br>n&#x3D;normalize(∇f(p))<br>$$<br>法线计算：<br>$$<br>\frac{df(p)}{d(x)}≈\frac{f(p+(h,0,0))-f(p-(h,0,0))}{2h}<br>$$<br><img src="/../images/image-20241109122811807.png" alt="image-20241109122811807"></p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vec3 <span class="title function_">calcNormal</span><span class="params">(in vec3 p)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> eps = <span class="number">0.0001</span>; <span class="comment">// replace by an appropriate value</span></span><br><span class="line">    <span class="type">const</span> vec2 h = vec2(eps,<span class="number">0.</span>);</span><br><span class="line">    <span class="comment">//高精度</span></span><br><span class="line">    <span class="keyword">return</span> normalize(vec3(f(p+h.xyy) - f(p-h.xyy),</span><br><span class="line">                          f(p+h.yxy) - f(p-h.yxy),</span><br><span class="line">                          f(p+h.yyx) - f(p-h.yyx)));</span><br><span class="line">    <span class="comment">//简化计算，f(p)=0忽略</span></span><br><span class="line">    <span class="keyword">return</span> normalize(vec3(f(p+h.xyy),</span><br><span class="line">                          f(p+h.yxy),</span><br><span class="line">                          f(p+h.yyx)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进版本</span></span><br><span class="line">vec3 <span class="title function_">calcNormal</span><span class="params">( in vec3 &amp; p )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> h = <span class="number">0.0001</span>; <span class="comment">// replace by an appropriate value</span></span><br><span class="line">    <span class="type">const</span> vec2 k = vec2(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> normalize( k.xyy*f( p + k.xyy*h ) + </span><br><span class="line">                      k.yyx*f( p + k.yyx*h ) + </span><br><span class="line">                      k.yxy*f( p + k.yxy*h ) + </span><br><span class="line">                      k.xxx*f( p + k.xxx*h ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="FlowMap"   >          <a href="#FlowMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#FlowMap" class="headerlink" title="FlowMap"></a>FlowMap</h3>      <p>valve 2010 GDC</p><p>使用RG通道记录2D向量，模拟流动效果</p>        <h2 id="测试"   >          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试" class="headerlink" title="测试"></a>测试</h2>              <h3 id="模板测试"   >          <a href="#模板测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3>              <h2 id="光照"   >          <a href="#光照" class="heading-link"><i class="fas fa-link"></i></a><a href="#光照" class="headerlink" title="光照"></a>光照</h2>              <h3 id="Fresnel-Effect"   >          <a href="#Fresnel-Effect" class="heading-link"><i class="fas fa-link"></i></a><a href="#Fresnel-Effect" class="headerlink" title="Fresnel Effect"></a>Fresnel Effect</h3>      <p>视角方向和表面法线的夹角越大，反射效果越好</p><p>Schlick菲涅尔近似等式（v：视角方向，n：表面法线）：<br>$$<br>F_{schlick}(v,n) &#x3D; F_0 + (1-F_0)(1-v \cdot n)^5<br>$$</p>        <h2 id="PBS-基于物理的渲染技术"   >          <a href="#PBS-基于物理的渲染技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#PBS-基于物理的渲染技术" class="headerlink" title="PBS-基于物理的渲染技术"></a>PBS-基于物理的渲染技术</h2>              <h3 id="光"   >          <a href="#光" class="heading-link"><i class="fas fa-link"></i></a><a href="#光" class="headerlink" title="光"></a>光</h3>      <p>光是一种电磁波，由光源发射，在物体表面<strong>吸收</strong>或<strong>散射</strong>，最终被眼睛吸收成像。</p><p>吸收：光被转化成了其他能量</p><p>散射：光的传播方向被改变</p><p>光在不同介质的边界会被分割乘两个方向：反射和折射。<strong>菲涅尔等式</strong>决定了有多少比例的光被反射。</p><p>在<strong>理想模型</strong>中，边界是光滑且无限延伸的：</p><p><img src="/../images/image-20241206124454600.png" alt="image-20241206124454600"></p><p>在现实中，物体表面不可能是完全光滑的，且被折射的光又有一部分被散射到外部，称为<strong>次表面散射</strong>（蓝色箭头）。</p><p><img src="/../images/image-20241206125601367.png" alt="image-20241206125601367"></p><p>在次表面散射（subsurface-scattered light）中，如果入射点之间的距离小于像素大小，则可以忽略，视为从同一点发出。</p><p><img src="/../images/image-20241206130040870.png" alt="image-20241206130040870"></p>        <h3 id="BRDF-1"   >          <a href="#BRDF-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#BRDF-1" class="headerlink" title="BRDF"></a>BRDF</h3>      <p>用辐射率radiance表示<strong>单位面积，单位方向上光源的辐射量</strong>。</p><p>在渲染中，我们通常会基于表面的入射光辐射率，计算出射光辐射率。这个过程就需要BRDF（双向反射分布函数）分析。</p>        <h2 id="色彩存储与显示"   >          <a href="#色彩存储与显示" class="heading-link"><i class="fas fa-link"></i></a><a href="#色彩存储与显示" class="headerlink" title="色彩存储与显示"></a>色彩存储与显示</h2>              <h3 id="LDR，HDR"   >          <a href="#LDR，HDR" class="heading-link"><i class="fas fa-link"></i></a><a href="#LDR，HDR" class="headerlink" title="LDR，HDR"></a>LDR，HDR</h3>      <div class="table-container"><table><thead><tr><th>LDR：Low Dynamic Range</th><th>HDR：High Dynamic Range</th></tr></thead><tbody><tr><td>电视，电脑上看到的范围，0~1</td><td>现实中的动态范围，约15~10万</td></tr><tr><td>8位精度</td><td>远高于8位精度</td></tr><tr><td>jpg，png</td><td>hdr，tif，exr，raw..</td></tr><tr><td>值在0~1之间</td><td>可超过1</td></tr><tr><td></td><td>渲染速度较慢，需要更多显存，不支持硬件抗锯齿</td></tr></tbody></table></div><p>Dynamic Range（动态范围）：最高亮度&#x2F;最低亮度</p><p>从HDR映射到LDR的过程叫<strong>ToneMapping</strong></p>        <h3 id="ACES"   >          <a href="#ACES" class="heading-link"><i class="fas fa-link"></i></a><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h3>      <p>Acamedy Color Encording System，最被广泛使用的ToneMapping曲线</p><p><img src="/../images/image-20241210135047137.png" alt="image-20241210135047137"></p>        <h3 id="HSL-amp-HSV"   >          <a href="#HSL-amp-HSV" class="heading-link"><i class="fas fa-link"></i></a><a href="#HSL-amp-HSV" class="headerlink" title="HSL&amp;HSV"></a>HSL&amp;HSV</h3>      <p><img src="/../images/1280px-Hsl-hsv_models.svg.png" alt="undefined"></p>        <h4 id="HSL转RGB"   >          <a href="#HSL转RGB" class="heading-link"><i class="fas fa-link"></i></a><a href="#HSL转RGB" class="headerlink" title="HSL转RGB"></a>HSL转RGB</h4>      <figure class="highlight glsl"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c = hue/saturation/lightness</span></span><br><span class="line"><span class="type">vec3</span> hsv2rgb(<span class="type">vec3</span> c)&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1.0</span>/<span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">  <span class="type">vec3</span> p = <span class="built_in">abs</span>(<span class="built_in">fract</span>(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">  <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(K.xxx, <span class="built_in">clamp</span>(p - K.xxx, <span class="number">0.0</span>, <span class="number">1.0</span>), c.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习图形学相关笔记&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="图形学" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="游戏" scheme="https://lzmustb.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="C++" scheme="https://lzmustb.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>UI设计作品汇总</title>
    <link href="https://lzmustb.github.io/2024/04/24/my-design-works/"/>
    <id>https://lzmustb.github.io/2024/04/24/my-design-works/</id>
    <published>2024-04-24T11:12:05.000Z</published>
    <updated>2024-04-24T12:28:54.113Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="贝壳指北-移动端APP项目"   >          <a href="#贝壳指北-移动端APP项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#贝壳指北-移动端APP项目" class="headerlink" title="贝壳指北 移动端APP项目"></a><strong>贝壳指北 移动端APP项目</strong></h2>      <blockquote><p>“贝壳指北”是一款运用了image caption技术的智能APP，它可以通过拍照识别出楼宇，并且输出对应的介绍和吐槽，就像一个真人导游一样。不仅如此，它还可以让你了解楼宇内的机器使用方式，实验室介绍等，让你更深入地掌握校园的信息。此外，我们的APP还有地图位置显示，搜索搜楼，地图点击等功能，让你随时随地找到你想去的地方，并且看到实景图。</p></blockquote><p>为配合“贝壳”这一形象，整体采用淡蓝色调，以母校“北科”的谐音“贝壳”作为原型，在中心加上了象征APP功能的指南针。</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6UI.jpg" alt="软件UI"></p><span id="more"></span>        <h2 id="Flikwise-影评网站项目"   >          <a href="#Flikwise-影评网站项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#Flikwise-影评网站项目" class="headerlink" title="Flikwise 影评网站项目"></a><strong>Flikwise 影评网站项目</strong></h2>      <blockquote><p>“Flikwise” 是一个影评网站，旨在提供一个类似于IMDB的平台，供用户分享、浏览和评价电影，成为电影爱好者之间交流和获取电影信息的热门社交平台。</p></blockquote><p><img src="/../images/image-20240424202021260.png" alt="image-20240424202021260"></p><p><img src="/../images/image-20240424202037136.png" alt="image-20240424202037136"></p><p><img src="/../images/%E5%BD%B1%E8%AF%84%E7%BD%91%E7%AB%994.png" alt="影评网站4"></p>        <h2 id="Room-327-极简聊天软件"   >          <a href="#Room-327-极简聊天软件" class="heading-link"><i class="fas fa-link"></i></a><a href="#Room-327-极简聊天软件" class="headerlink" title="Room-327 极简聊天软件"></a>Room-327 极简聊天软件</h2>      <blockquote><p>Room-327是计算机网络课程设计项目，由我使用electro+vue3独自完成。</p><p>功能有创建&#x2F;加入局域网聊天室，可以在聊天室的大厅中发送群体信息，或跟聊天室的任意其他用户私聊。</p></blockquote><p><img src="/../images/room-327.png" alt="room-327"></p><p><img src="/../images/room-327%EF%BC%882%EF%BC%89.png" alt="room-327（2）"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;贝壳指北-移动端APP项目&quot;   &gt;
          &lt;a href=&quot;#贝壳指北-移动端APP项目&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#贝壳指北-移动端APP项目&quot; class=&quot;headerlink&quot; title=&quot;贝壳指北 移动端APP项目&quot;&gt;&lt;/a&gt;&lt;strong&gt;贝壳指北 移动端APP项目&lt;/strong&gt;&lt;/h2&gt;
      &lt;blockquote&gt;
&lt;p&gt;“贝壳指北”是一款运用了image caption技术的智能APP，它可以通过拍照识别出楼宇，并且输出对应的介绍和吐槽，就像一个真人导游一样。不仅如此，它还可以让你了解楼宇内的机器使用方式，实验室介绍等，让你更深入地掌握校园的信息。此外，我们的APP还有地图位置显示，搜索搜楼，地图点击等功能，让你随时随地找到你想去的地方，并且看到实景图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为配合“贝壳”这一形象，整体采用淡蓝色调，以母校“北科”的谐音“贝壳”作为原型，在中心加上了象征APP功能的指南针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/%E8%BD%AF%E4%BB%B6UI.jpg&quot; alt=&quot;软件UI&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="个人作品" scheme="https://lzmustb.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81/"/>
    
    <category term="平面设计" scheme="https://lzmustb.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81/%E5%B9%B3%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计" scheme="https://lzmustb.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>rust学习笔记</title>
    <link href="https://lzmustb.github.io/2024/04/24/my-rust-note/"/>
    <id>https://lzmustb.github.io/2024/04/24/my-rust-note/</id>
    <published>2024-04-24T02:51:38.000Z</published>
    <updated>2024-04-25T10:35:00.034Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="引言"   >          <a href="#引言" class="heading-link"><i class="fas fa-link"></i></a><a href="#引言" class="headerlink" title="引言"></a>引言</h1>      <p>本文是阅读<span class="exturl"><a class="exturl__link"   href="https://doc.rust-lang.org/book/title-page.html%E6%89%80%E5%81%9A%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82" >https://doc.rust-lang.org/book/title-page.html所做的学习笔记。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><span id="more"></span>        <h2 id="Hello-world"   >          <a href="#Hello-world" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>main函数是rust可执行文件的入口函数，总是第一个被执行。</li><li>rust缩进使用4个空格而非tab</li><li><code>println!</code> 会调用一个宏，去掉<code>!</code>表示调用一个函数</li></ul><p>Rust是一种<strong>预编译静态类型</strong>（ahead-of-time compiled）语言，因此你可以将可执行文件发送给没有安装Rust的人运行。</p>        <h2 id="Cargo"   >          <a href="#Cargo" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2>      <p>Cargo是rust的构建系统和包管理器，可以给rust程序简单地添加依赖。</p><p><code>cargo new [filename] </code> 可以创建一个代有<em>Cargo.toml</em>的项目文件夹。</p><figure class="highlight toml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></div></figure><p><code>cargo doc --open</code>可以生成当前依赖的文档，并在一个网页中打开。</p>        <h3 id="Build"   >          <a href="#Build" class="heading-link"><i class="fas fa-link"></i></a><a href="#Build" class="headerlink" title="Build"></a>Build</h3>      <p><code>cargo build</code> 会在 <code>./target/debug</code> 构建一个可执行文件，同时在根目录创建一个<em>Cargo.lock</em>文件，这个文件可以自动追踪当前的依赖版本。</p><p><code>cargo run</code> 可以在build后直接运行文件。</p><p><code>cargo check</code> 可以在不产生exe的情况下检查你的代码是否编译完成。</p><p><code>cargo build --release</code> 会在 <code>./target/release </code> 构建release版本可执行文件，这个文件的运行速度会更快，但编译速度更慢。</p>        <h2 id="use"   >          <a href="#use" class="heading-link"><i class="fas fa-link"></i></a><a href="#use" class="headerlink" title="use"></a>use</h2>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></div></figure><p><code>use</code>  关键字可以引入library。默认情况下，rust设定了若干个自动导入的标准库内容称为<a href="https://doc.rust-lang.org/std/prelude/index.html">预导入（<em>prelude</em>）内容</a></p>        <h2 id="变量定义"   >          <a href="#变量定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2>              <h3 id="let-amp-const"   >          <a href="#let-amp-const" class="heading-link"><i class="fas fa-link"></i></a><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h3>      <p><code>let</code> 可以声明一个变量，变量默认是<strong>不可变</strong>的（<em>immutable</em>），使用 <code>mut</code> 关键字可以使变量可变，但<strong>不可改变数据类型</strong>。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></div></figure><p><code>::</code>表明<code>new()</code>是String类型的一个<strong>关联函数</strong>（<em>associated function</em>），类似C++中静态方法。</p><p><code>const</code> 可以声明一个常量，常量不可使用<code>mut</code>，且必须显式声明类型。在声明它的作用域中，常量在整个程序生命周期中都有效，常用来作为全局范围的值。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></div></figure>        <h3 id="shadowing"   >          <a href="#shadowing" class="heading-link"><i class="fas fa-link"></i></a><a href="#shadowing" class="headerlink" title="shadowing"></a>shadowing</h3>      <p>重复声明一个变量会让第一次声明的值被隐藏，直至二次声明的作用域结束。</p><p>与<code>mut</code>的区别是，shadowing会创建一个新的变量，可以改变值得类型。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//x=12</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">//x=6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="数据类型"   >          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2>      <p>Rust是<strong>静态类型</strong>语言，在编译时必须知道所有变量得类型。</p><ul><li><p>Scalar（标量）：</p><ul><li>Integer：<code>i8</code> ~ <code>i128</code> , <code>u8</code> ~ <code>u128</code> , <code>isize</code> , <code>usize</code></li></ul><div class="table-container"><table><thead><tr><th>进制</th><th>例子</th></tr></thead><tbody><tr><td>Decimal</td><td>98_222 (98222)</td></tr><tr><td>Hex</td><td>0xff</td></tr><tr><td>Octal</td><td>0o77</td></tr><tr><td>Binary</td><td>0b1111_0000</td></tr><tr><td>Byte (u8 only)</td><td>b’A’</td></tr></tbody></table></div><ul><li>float：<code>f32</code> , <code>f64</code> </li><li>boolean：<code>bool</code>，值为true或false</li><li>character：<code>char</code>，<strong>4Bytes</strong>，unicode，使用单引号声明</li></ul></li><li><p>Compound 复合类型：</p><ul><li>tuple 元组：</li></ul><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = tup.<span class="number">0</span>; <span class="comment">// 下标访问，temp=500</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;  <span class="comment">//元组解构</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单元(unit)：空值或空得返回类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unit</span>: ()=();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>array 数组：在栈上分配的固定大小的单个内存块，<strong>所有元素类型必须相同，长度固定</strong>。</li></ul><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr2</span>: [<span class="number">1</span>;<span class="number">2</span>]; <span class="comment">//arr2=[1,1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = arr[<span class="number">0</span>]; <span class="comment">//索引访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h2 id="函数"   >          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数" class="headerlink" title="函数"></a>函数</h2>              <h3 id="定义"   >          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>，y: <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The values are: &#123;x&#125; &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>fn</code>关键字定义，不分前后。</p><p>在函数签名中，必须<strong>声明每个参数的类型</strong>。</p>        <h3 id="语句和表达式"   >          <a href="#语句和表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3>      <p>Rust是一门基于表达式（expression-based）的语言，函数体由一系列语句（Statements）和可选的结尾表达式（Expressions）构成。</p><p>语句不返回值，表达式会计算并返回一个值。</p><p>一个数字（字符），函数调用，宏调用，块作用域 都是表达式，<strong>表达式的结尾没有分号，如果加上分号就变成语句。</strong></p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有返回值的函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"> x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>链式调用</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></div></figure><p>read_line()返回Result类型，Result分为Ok和Err两种值</p>        <h3 id="println"   >          <a href="#println" class="heading-link"><i class="fas fa-link"></i></a><a href="#println" class="headerlink" title="println!"></a>println!</h3>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;you guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125; and y + 2 = &#123;&#125;&quot;</span>, y + <span class="number">2</span>);</span><br><span class="line"><span class="comment">//第二个&#123;&#125;值为y+2</span></span><br></pre></td></tr></table></div></figure><p>{}占位符可以将变量的值打印。</p>        <h2 id="控制流"   >          <a href="#控制流" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2>              <h3 id="条件"   >          <a href="#条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件" class="headerlink" title="条件"></a>条件</h3>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was a&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was b&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用在语句中，分支返回值类型必须相同</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="循环"   >          <a href="#循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环" class="headerlink" title="循环"></a>循环</h3>              <h4 id="loop"   >          <a href="#loop" class="heading-link"><i class="fas fa-link"></i></a><a href="#loop" class="headerlink" title="loop"></a>loop</h4>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span> [返回值]; <span class="comment">//退出循环，可选返回值</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//跳过此轮</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过给loop加上label，可以跳出外层循环</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="while"   >          <a href="#while" class="heading-link"><i class="fas fa-link"></i></a><a href="#while" class="headerlink" title="while"></a>while</h4>      <p>相当于loop+if</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="for"   >          <a href="#for" class="heading-link"><i class="fas fa-link"></i></a><a href="#for" class="headerlink" title="for"></a>for</h4>      <p>用于遍历一个集合</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">        <span class="comment">//输出 3! 2! 1!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="Ownership-所有权"   >          <a href="#Ownership-所有权" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ownership-所有权" class="headerlink" title="Ownership 所有权"></a>Ownership 所有权</h2>      <p>所有权是Rust最与众不同的特性，它让Rust无需垃圾回收即可保障内存安全。</p><p>所有权是管理内存的一系列的规则，编译器若发现程序有违这些规则，就会编译失败。因此所有权的内存管理在程序运行中不会有性能损耗。</p>        <h3 id="堆-amp-栈"   >          <a href="#堆-amp-栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈"></a>堆&amp;栈</h3>      <p>堆栈都是代码在运行时可供使用的内存，但它们的结构不同。</p><p><strong>栈</strong>：先进后出，栈中所有数据都必须占用已知且固定的大小。</p><p><strong>堆</strong>：向堆存放数据时，要先请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到足够大的空位标记并返回一个指针。</p>        <h3 id="所有权规则"   >          <a href="#所有权规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h3>      <ul><li>Rust中的每个值都有一个<em>owner</em>，且在任何时候都唯一。</li><li>当<em>owner</em>离开作用域，这个值就会被丢弃。</li></ul>        <h3 id="作用域"   >          <a href="#作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3>      <p>以<code>String</code>类型为例，<code>String</code>不同于<code>string</code>，是分配在堆上的，可用于创建编译阶段未知大小的字符串（例如用户输入）。</p><p>这种类型的数据可以在程序运行中发生改变，这意味着：</p><ul><li><em>memory allocator</em>会在运行时申请内存分配。</li><li>需要一个方法以在这个变量用完时释放内存。</li></ul><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() appends a literal to a String</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// This will print `hello, world!`</span></span><br></pre></td></tr></table></div></figure><p>当变量在离开作用域时，Rust会调用一个特殊的函数<code>drop</code>，在这个函数中执行内存释放相关的操作。</p><blockquote><p>在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取 即初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的 话应该对 Rust 的 drop 函数并不陌生。</p></blockquote>        <h3 id="变量与数据交互"   >          <a href="#变量与数据交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量与数据交互" class="headerlink" title="变量与数据交互"></a>变量与数据交互</h3>              <h4 id="Move"   >          <a href="#Move" class="heading-link"><i class="fas fa-link"></i></a><a href="#Move" class="headerlink" title="Move"></a>Move</h4>      <p>1.将x的值赋给y，则x，y的值均被存入栈中。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></div></figure><p>2.String复制时，只从栈上拷贝了ptr，len，capacity，而没有复制指针指向的数据。为了防止重复释放内存，Rust在发生复制后，认为s1不再有效，在创建s2后使用s1将<strong>报错</strong>。</p><p>※Rust永远不会自动创建数据的“深拷贝”，因此任何自动的复制都不会有太大的性能影响。</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;Hello&quot;);</span><br><span class="line">let s2 = s1;</span><br></pre></td></tr></table></div></figure><p><img src="/../images/image-20240425102457409.png" alt="image-20240425102457409"></p><p><code>copy trait</code>注解：允许在move后依然有效。（整数，布尔，浮点数，字符，以及只包含上述类型的元组）</p>        <h4 id="Clone"   >          <a href="#Clone" class="heading-link"><i class="fas fa-link"></i></a><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h4>      <p>使用clone可以人为地复制变量。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></div></figure>        <h4 id="函数调用的move和clone"   >          <a href="#函数调用的move和clone" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用的move和clone" class="headerlink" title="函数调用的move和clone"></a>函数调用的move和clone</h4>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s的值移动到函数里</span></span><br><span class="line">                        <span class="comment">// s不能再被使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// x 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                   <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                   <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line">&#125;                  <span class="comment">// 这里，x 先移出了作用域，然后是s。但s的值已被移走</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line"> <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特</span></span><br></pre></td></tr></table></div></figure><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  </span><br><span class="line">&#125; <span class="comment">//s2被move，s1和s3被drop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>);<span class="comment">// some_string comes into scope</span></span><br><span class="line">    some_string                             <span class="comment">//some_string被返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">    a_string  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过元组返回多个值</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Borrowing"   >          <a href="#Borrowing" class="heading-link"><i class="fas fa-link"></i></a><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h3>      <p>引用（<em>reference</em>）可以在传递参数的同时不获取其所有权，因此可以让原来的变量继续使用。</p><p>创建一个reference的行为称为borrowing。</p><p>无效的引用会导致报错，以避免空指针。</p><p><strong>reference不允许修改引用的值。</strong></p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="comment">//s1可以继续使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img src="/../images/image-20240425125325560.png" alt="image-20240425125325560"></p>        <h4 id="可变引用"   >          <a href="#可变引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h4>      <p>通过<code>&amp;mut</code>可以创建可变引用，如果作为函数参数，形参也应该声明为可变引用。</p><p><strong>可变引用在同一作用域只能存在一个，以防止数据竞争。</strong></p><p><strong>不可变引用生效前不能使用可变引用</strong>。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="Slice"   >          <a href="#Slice" class="heading-link"><i class="fas fa-link"></i></a><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4>      <p>字符串slice是String中部分值的引用。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">//左开右闭（0可省略）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..s.<span class="title function_ invoke__">len</span>()];</span><br></pre></td></tr></table></div></figure><p><img src="/../images/image-20240425132107322.png" alt="image-20240425132107322"></p>        <h2 id="struct-结构体"   >          <a href="#struct-结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a>struct 结构体</h2>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    username,  <span class="comment">//简化写法，形参与字段重名</span></span><br><span class="line">    email,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="comment">//实例化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">use1</span> = User&#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc@qq.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;def@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">//结构体更新语法 move规则与元组相同</span></span><br><span class="line">    <span class="comment">//如果username或email中至少一个拷贝了user1，user1失效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ggg@qq.com&quot;</span>);</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="tuple-structs-元组结构体"   >          <a href="#tuple-structs-元组结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#tuple-structs-元组结构体" class="headerlink" title="tuple structs 元组结构体"></a>tuple structs 元组结构体</h3>      <p>※元组结构体的参数类型相同也不能互相传参</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="unit-like-structs"   >          <a href="#unit-like-structs" class="heading-link"><i class="fas fa-link"></i></a><a href="#unit-like-structs" class="headerlink" title="unit-like structs"></a>unit-like structs</h3>      <p>没有任何字段的结构体</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="打印struct"   >          <a href="#打印struct" class="heading-link"><i class="fas fa-link"></i></a><a href="#打印struct" class="headerlink" title="打印struct"></a>打印struct</h3>      <figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加上外部属性</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = User&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//仅打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,&amp;user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印并返回值</span></span><br><span class="line">    dbg!(&amp;user);</span><br><span class="line">    dbg!(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="关联方法-amp-关联函数"   >          <a href="#关联方法-amp-关联函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#关联方法-amp-关联函数" class="headerlink" title="关联方法&amp;关联函数"></a>关联方法&amp;关联函数</h3>      <p>关联方法（associated method）以<code>self</code>为第一个形参</p><p>关联函数（associated functions）不作用于<strong>结构体实例</strong>，类似c++中的静态函数。</p><p><code>impl</code>块中用来存放与结构体相关的函数&#x2F;方法，<code>impl</code>块可以存在多个。</p><figure class="highlight rust"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//第一个参数为self/&amp;self/&amp;mut self</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以在同名方法中使用同名字段</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入同类型的参数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compare</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关联函数 Self为关联结构体的别名</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new_square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>&#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    rect1.<span class="title function_ invoke__">area</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="枚举"   >          <a href="#枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2>      ]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;   &gt;
          &lt;a href=&quot;#引言&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;
      &lt;p&gt;本文是阅读&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;https://doc.rust-lang.org/book/title-page.html%E6%89%80%E5%81%9A%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82&quot; &gt;https://doc.rust-lang.org/book/title-page.html所做的学习笔记。&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>《游戏设计艺术》笔记</title>
    <link href="https://lzmustb.github.io/2024/04/19/read-the-art-of-game-design/"/>
    <id>https://lzmustb.github.io/2024/04/19/read-the-art-of-game-design/</id>
    <published>2024-04-19T04:30:36.000Z</published>
    <updated>2024-04-24T06:40:50.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真正的发现之旅不在于寻找新风景，而是拥有新眼光。<br>——马塞尔·普鲁斯特</p></blockquote><p>游戏设计师最终关注的是创造<strong>体验</strong>。</p><span id="more"></span>        <h2 id="体验"   >          <a href="#体验" class="heading-link"><i class="fas fa-link"></i></a><a href="#体验" class="headerlink" title="体验"></a>体验</h2>              <h3 id="1号透镜：情感"   >          <a href="#1号透镜：情感" class="heading-link"><i class="fas fa-link"></i></a><a href="#1号透镜：情感" class="headerlink" title="1号透镜：情感"></a>1号透镜：情感</h3>      <ul><li>我希望玩家能够体验到怎样的情感？为什么？</li><li>当人们玩游戏时，他们产生了怎样的情感？为什么？</li><li>我怎样缩小人们实际体验与我的设想之间的距离？</li></ul><p>分析记忆</p>        <h3 id="2号透镜：本质体验"   >          <a href="#2号透镜：本质体验" class="heading-link"><i class="fas fa-link"></i></a><a href="#2号透镜：本质体验" class="headerlink" title="2号透镜：本质体验"></a>2号透镜：本质体验</h3>      <ul><li>我想要让玩家获得怎样的体验？</li><li>这种体验的本质是什么？</li><li>我应该如何让我的游戏抓住这种体验的本质？</li></ul><p>如果你对玩家获得的体验有明确的想象，并知道游戏中的哪一部分创造了这种体验，你就能更清楚地知道怎样才能把你的游戏变得更好，因为你知道游戏中哪些元素能够安全地改变，而哪些不行。</p>        <h3 id="3号透镜：场景"   >          <a href="#3号透镜：场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#3号透镜：场景" class="headerlink" title="3号透镜：场景"></a>3号透镜：场景</h3>      <ul><li>我想要制作的游戏最适合哪种场景？</li><li>我的场景中是否有一些特殊的属性会影响到我的游戏？</li><li>我的游戏中有哪些元素能够与场景和谐共处，哪些不行？</li></ul><p><img src="/../images/image-20240419124003314.png" alt="image-20240419124003314"></p><p>炉边设计的游戏系统：wii，与家庭成员一起游玩</p><p>工作台：PC（steam），单独更高，更适合单人或在线</p><p>读书角：iPad，难度更低，更简单放松</p><p>竞技场：体育运动，电子竞技</p>        <h3 id="4号透镜：惊喜"   >          <a href="#4号透镜：惊喜" class="heading-link"><i class="fas fa-link"></i></a><a href="#4号透镜：惊喜" class="headerlink" title="4号透镜：惊喜"></a>4号透镜：惊喜</h3>      <ul><li>当玩家们玩我的游戏时，什么会让他们感到惊喜？</li><li>我的游戏中的故事，规则，艺术，技术有惊喜吗？</li><li>你的规则能够让玩家之间互相带来惊喜吗？</li><li>你的规则能够让玩家们给自己带来惊喜吗？</li></ul>        <h3 id="5号透镜：乐趣"   >          <a href="#5号透镜：乐趣" class="heading-link"><i class="fas fa-link"></i></a><a href="#5号透镜：乐趣" class="headerlink" title="5号透镜：乐趣"></a>5号透镜：乐趣</h3>      <p>大多数玩乐活动都是尝试回答这样的问题：</p><ul><li><p>当我转动把手时会发生什么？</p></li><li><p>我们能击败这支队伍吗？</p></li><li><p>我能把这些黏土做成什么？</p></li><li><p>我能跳神多少次？</p></li><li><p>完成这个关卡后会发生什么？</p></li></ul>        <h3 id="6号透镜：好奇心"   >          <a href="#6号透镜：好奇心" class="heading-link"><i class="fas fa-link"></i></a><a href="#6号透镜：好奇心" class="headerlink" title="6号透镜：好奇心"></a>6号透镜：好奇心</h3>      <ul><li>我的游戏给玩家的大脑提出了怎样的问题？</li><li>我正在做哪些努力让他们在意这些问题？</li><li>我能做什么来使他们提出更多的问题？</li></ul>        <h3 id="7号透镜：内生价值"   >          <a href="#7号透镜：内生价值" class="heading-link"><i class="fas fa-link"></i></a><a href="#7号透镜：内生价值" class="headerlink" title="7号透镜：内生价值"></a>7号透镜：内生价值</h3>      <ul><li>在我的游戏中哪些东西对玩家很有价值？</li><li>怎样让这些东西对玩家更有价值？</li><li>游戏中的价值与玩家的动机之间有怎样的关系？</li></ul>        <h3 id="8号透镜：解决的问题"   >          <a href="#8号透镜：解决的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#8号透镜：解决的问题" class="headerlink" title="8号透镜：解决的问题"></a>8号透镜：解决的问题</h3>      <ul><li>我的游戏要求玩家解决哪些问题？</li><li>是否有一些隐藏的问题作为玩法的一部分出现？</li><li>在我的游戏中，怎样产生新的问题来对玩家保持吸引力？</li></ul>        <h2 id="元素"   >          <a href="#元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#元素" class="headerlink" title="元素"></a>元素</h2>              <h3 id="9号透镜：四种元素"   >          <a href="#9号透镜：四种元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#9号透镜：四种元素" class="headerlink" title="9号透镜：四种元素"></a>9号透镜：四种元素</h3>      <p>四种基本元素：</p><pre><code>* 右脑元素：美学，故事* 左脑元素：机制，技术</code></pre>        <h3 id="10号透镜：全息设计"   >          <a href="#10号透镜：全息设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#10号透镜：全息设计" class="headerlink" title="10号透镜：全息设计"></a>10号透镜：全息设计</h3>      <p>四种元素和玩家体验，以及联系方式。</p><ul><li>游戏中的哪一种元素产生了令人享受的体验？</li><li>游戏中的哪一种元素会让玩家在体验中分心？</li><li>怎样改变游戏元素来提高游戏体验？</li></ul>        <h2 id="主题"   >          <a href="#主题" class="heading-link"><i class="fas fa-link"></i></a><a href="#主题" class="headerlink" title="主题"></a>主题</h2>              <h3 id="11号透镜：统一"   >          <a href="#11号透镜：统一" class="heading-link"><i class="fas fa-link"></i></a><a href="#11号透镜：统一" class="headerlink" title="11号透镜：统一"></a>11号透镜：统一</h3>      <ul><li>我的主题是什么？</li><li>我已经采用了所有方法来强化这个主题吗？</li></ul>        <h3 id="12号透镜：共鸣"   >          <a href="#12号透镜：共鸣" class="heading-link"><i class="fas fa-link"></i></a><a href="#12号透镜：共鸣" class="headerlink" title="12号透镜：共鸣"></a>12号透镜：共鸣</h3>      <ul><li>在我的游戏中，有哪些有力的或者特殊的元素？</li><li>我的游戏描述给他人时，那些创意真的能让他们兴奋吗？</li><li>如果没有任何限制，这个游戏将会变成什么样？</li><li>我对这个游戏的方向有特定的直觉，是什么在驱动这种直觉呢？</li></ul>        <h2 id="灵感"   >          <a href="#灵感" class="heading-link"><i class="fas fa-link"></i></a><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h2>      <blockquote><p>当你知道如何倾听时，每个人都可以成为大师。</p><p>​——拉姆·达斯</p></blockquote>        <h3 id="13号透镜：无尽灵感"   >          <a href="#13号透镜：无尽灵感" class="heading-link"><i class="fas fa-link"></i></a><a href="#13号透镜：无尽灵感" class="headerlink" title="13号透镜：无尽灵感"></a>13号透镜：无尽灵感</h3>      <ul><li>我的生活中有怎样的体验想要与他人分享？</li><li>有哪些技巧可以让我捕捉到体验的本质，并把它纳入我的游戏中？</li></ul>        <h2 id="约束"   >          <a href="#约束" class="heading-link"><i class="fas fa-link"></i></a><a href="#约束" class="headerlink" title="约束"></a>约束</h2>              <h3 id="14号透镜：问题陈述"   >          <a href="#14号透镜：问题陈述" class="heading-link"><i class="fas fa-link"></i></a><a href="#14号透镜：问题陈述" class="headerlink" title="14号透镜：问题陈述"></a>14号透镜：问题陈述</h3>      <ul><li>我真正想要解决什么问题？</li><li>我是否做过一些与真正目标无关的游戏设定？</li><li>游戏是不是这个问题最好的解决方案？</li><li>我将怎样分辨出问题是否已经解决了？</li></ul>        <h2 id="头脑风暴"   >          <a href="#头脑风暴" class="heading-link"><i class="fas fa-link"></i></a><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h2>      <ul><li>记下答案</li><li>写在纸上</li><li>草图</li><li>玩具</li><li>改变视角</li><li>沉浸你自己</li><li>开几个玩笑</li><li>不要节约材料</li><li>写在墙上（白板）（多人）</li><li>空间记忆</li><li>记下所有东西</li><li>为你的清单计数</li><li>颠覆你的设定</li><li>组合和搭配分类</li><li>自言自语（独自）</li><li>找一个搭档</li></ul>        <h3 id="15号透镜：八项测试"   >          <a href="#15号透镜：八项测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#15号透镜：八项测试" class="headerlink" title="15号透镜：八项测试"></a>15号透镜：八项测试</h3>      <ul><li>艺术冲动：作为设计师，问自己这个游戏是否“感觉不错”。</li><li>人群特征：这个设计是否符合目标受众？</li><li>体验设计：游戏是否经得起这些透镜的检验？</li><li>革新：这个设计是否与众不同？</li><li>商业和市场：这个游戏能盈利吗？</li><li>工程：这个游戏在技术上是否具备可行性？</li><li>社区：这个游戏达到我们的社区&#x2F;社交目标了吗？</li><li>玩法测试：游戏测试者是否享受这个游戏？</li></ul>        <h2 id="迭代"   >          <a href="#迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2>              <h3 id="软件开发螺旋模型"   >          <a href="#软件开发螺旋模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#软件开发螺旋模型" class="headerlink" title="软件开发螺旋模型"></a>软件开发螺旋模型</h3>      <p>包含三个理念：风险评估，原型，迭代</p><pre><code>* 想出一个基础设计* 找出设计中的最大风险* 建立原型消除这些风险* 测试这个原型* 基于你从原型中得出的结论做一个更详细的设计* 回到第二步</code></pre><p><img src="/../images/image-20240424084946656.png" alt="image-20240424084946656"></p>        <h3 id="敏捷宣言"   >          <a href="#敏捷宣言" class="heading-link"><i class="fas fa-link"></i></a><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3>      <p>2001年由一群软件工程师提出。</p><ol><li>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</li><li>欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</li><li>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。</li><li>业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li><li>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</li><li>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。</li><li>可工作的软件是进度的首要度量标准。</li><li>敏捷过程倡导可持续开发。责任人，开发人员和用户要能够共同维持其步调稳定延续。</li><li>坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</li><li>以简洁为本，它是极力减少不必要工作量的艺术。</li><li>最好的架构，需求和设计出自组织团队。</li><li>团队定期地反思如何能提高成效，并依此调整自身的举止表现。</li></ol><p>敏捷开发的核心元素：</p><ul><li>灵活的目标：迅速适应新的的创意和信息，有计划地改变计划。</li><li>优先级列表：给需要完成的特性定优先级，从顶端的开始完成。</li><li>冲刺：制定多个短期目标，更多的DDL意味着更多的工作被完成。</li><li>争分夺秒会议：10~15分钟的短会，每个成员只解释三件事：昨天完成了什么，今天计划完成什么，面临的问题。会议后与团队成员一对一解决问题。</li><li>演示日：每个冲刺阶段的最后，团队观看和测试工作结果，并从新的基准开始工作，分析风险，确定计划。</li></ul>        <h2 id="风险评估与原型设计"   >          <a href="#风险评估与原型设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#风险评估与原型设计" class="headerlink" title="风险评估与原型设计"></a>风险评估与原型设计</h2>      <p>152</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;真正的发现之旅不在于寻找新风景，而是拥有新眼光。&lt;br&gt;——马塞尔·普鲁斯特&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;游戏设计师最终关注的是创造&lt;strong&gt;体验&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏制作" scheme="https://lzmustb.github.io/categories/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
    <category term="读书笔记" scheme="https://lzmustb.github.io/categories/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="游戏" scheme="https://lzmustb.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>游戏技术笔记</title>
    <link href="https://lzmustb.github.io/2024/03/23/my-game-notes/"/>
    <id>https://lzmustb.github.io/2024/03/23/my-game-notes/</id>
    <published>2024-03-23T01:46:43.000Z</published>
    <updated>2025-07-15T13:48:46.941Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="游戏技术笔记"   >          <a href="#游戏技术笔记" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏技术笔记" class="headerlink" title="游戏技术笔记"></a>游戏技术笔记</h1>              <h2 id="多人实时对战"   >          <a href="#多人实时对战" class="heading-link"><i class="fas fa-link"></i></a><a href="#多人实时对战" class="headerlink" title="多人实时对战"></a>多人实时对战</h2>      <div class="table-container"><table><thead><tr><th></th><th>传输内容</th><th>逻辑计算</th><th>断线重连</th><th>回放&#x2F;观战</th></tr></thead><tbody><tr><td>帧同步</td><td>操作</td><td>客户端</td><td>追历史帧</td><td>天然支持</td></tr><tr><td>状态同步</td><td>结果</td><td>服务器</td><td>下次同步</td><td>另外实现</td></tr></tbody></table></div><p>不是非此即彼的二选一，最终同步的都是<strong>数据状态</strong>。</p><span id="more"></span>        <h3 id="同步策略"   >          <a href="#同步策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h3>      <p>在有延迟的情况下，给玩家无延迟的体验</p><ul><li>慢节奏（简单）：<ul><li>回合制游戏</li><li>表现层面优化，及时反馈</li></ul></li><li>快节奏：<ul><li>无冲突（简单）</li><li>有冲突（困难）</li></ul></li></ul><p>快节奏有冲突的同步策略：</p><ul><li>预测：服务端同步前先更新客户端的变化</li><li>和解：</li><li>插值：</li></ul>        <h3 id="io小游戏举例"   >          <a href="#io小游戏举例" class="heading-link"><i class="fas fa-link"></i></a><a href="#io小游戏举例" class="headerlink" title="io小游戏举例"></a>io小游戏举例</h3>      <p>移动+击晕其他玩家的小游戏：</p><ul><li>快节奏</li><li>有冲突：被其他人击晕后停止移动</li><li>操作及时反馈：帧同步</li><li>进入游戏（连接）：状态同步</li></ul><p><img src="/../images/image-20240323121914743.png" alt="image-20240323121914743"></p>        <h2 id="3D数学"   >          <a href="#3D数学" class="heading-link"><i class="fas fa-link"></i></a><a href="#3D数学" class="headerlink" title="3D数学"></a>3D数学</h2>              <h1 id="游戏企划书"   >          <a href="#游戏企划书" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏企划书" class="headerlink" title="游戏企划书"></a>游戏企划书</h1>      <ul><li>在尽可能早的阶段放出游戏画面</li></ul>        <h1 id="游戏设计"   >          <a href="#游戏设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h1>              <h2 id="SOLID-principles"   >          <a href="#SOLID-principles" class="heading-link"><i class="fas fa-link"></i></a><a href="#SOLID-principles" class="headerlink" title="SOLID principles"></a>SOLID principles</h2>      <ul><li>Single responsibility</li><li>Open-closed</li><li>Liskov substitution</li><li>Interface segregation</li><li>Dependency inversion</li></ul>        <h3 id="Single-responsibility"   >          <a href="#Single-responsibility" class="heading-link"><i class="fas fa-link"></i></a><a href="#Single-responsibility" class="headerlink" title="Single-responsibility"></a>Single-responsibility</h3>      <p>每个类，或模块只负责一个单一的功能，细分类和方法，让它们的功能一目了然。</p><p>把<strong>易读性，可扩展性，可复用性</strong>作为实现SRP的标准。</p>        <h3 id="Open-closed"   >          <a href="#Open-closed" class="heading-link"><i class="fas fa-link"></i></a><a href="#Open-closed" class="headerlink" title="Open-closed"></a>Open-closed</h3>      <p>open for extension but closed for modification。对扩展开放，对修改关闭。</p>        <h3 id="Liskov-substitution"   >          <a href="#Liskov-substitution" class="heading-link"><i class="fas fa-link"></i></a><a href="#Liskov-substitution" class="headerlink" title="Liskov substitution"></a>Liskov substitution</h3>      <p>子类必须实现基类的所有方法。优先考虑组合（interface）而非继承。</p>        <h3 id="Interface-segregation"   >          <a href="#Interface-segregation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Interface-segregation" class="headerlink" title="Interface segregation"></a>Interface segregation</h3>      <p>不要让接口里含有无关的方法，拆分成更细的接口。</p>        <h3 id="Dependency-inversion-principle"   >          <a href="#Dependency-inversion-principle" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a>Dependency inversion principle</h3>      <p>当两个类之间有关联时，就必然会引入一定程度的风险。不要直接让两个类关联，而是引入一个抽象层。</p><p><img src="/../images/image-20241028182559422.png" alt="image-20241028182559422"></p>        <h3 id="抽象类和接口"   >          <a href="#抽象类和接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3>      <div class="table-container"><table><thead><tr><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>有基类方法</td><td>具体类里具体实现</td></tr><tr><td>有静态成员</td><td>没有静态成员</td></tr><tr><td>使用构造器</td><td>不能使用构造器</td></tr><tr><td>可以使用访问修饰符</td><td>强制public</td></tr></tbody></table></div>        <h2 id="Design-patterns"   >          <a href="#Design-patterns" class="heading-link"><i class="fas fa-link"></i></a><a href="#Design-patterns" class="headerlink" title="Design patterns"></a>Design patterns</h2>              <h3 id="Factory-pattern"   >          <a href="#Factory-pattern" class="heading-link"><i class="fas fa-link"></i></a><a href="#Factory-pattern" class="headerlink" title="Factory pattern"></a>Factory pattern</h3>      <p>一个用于生成其他对象的中枢对象。</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IProduct</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">string</span> ProductName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Factory</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IProduct <span class="title">GetProduct</span>(<span class="params">Vector3 position</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Object-pool"   >          <a href="#Object-pool" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object-pool" class="headerlink" title="Object pool"></a>Object pool</h3>      <p>在需要操作大量的对象时，不要不断创建和销毁，而是从提前初始化的对象池里调用。</p><p>对象池的中对象的实例化在加载等<strong>玩家无法察觉的时候</strong>进行。</p><p>Unity官方的Pool库：<span class="exturl"><a class="exturl__link"   href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.html" >UnityEngine.Pool</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">int</span> initPoolSize;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PooledObject objectToPool;</span><br><span class="line">    <span class="comment">// Store the pooled objects in a collection</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;PooledObject&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> SetupPool();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Creates the pool (invoke when the lag is not noticeable)</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetupPool</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> stack = <span class="keyword">new</span> Stack&lt;PooledObject&gt;();</span><br><span class="line">PooledObject instance = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; initPoolSize; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> instance = Instantiate(objectToPool);</span><br><span class="line"> instance.Pool = <span class="keyword">this</span>;</span><br><span class="line"> instance.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line"> stack.Push(instance);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// returns the first active GameObject from the pool</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PooledObject <span class="title">GetPooledObject</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">// if the pool is not large enough, instantiate a new PooledObjects</span></span><br><span class="line"> <span class="keyword">if</span> (stack.Count == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">PooledObject newInstance = Instantiate(objectToPool);</span><br><span class="line">newInstance.Pool = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> newInstance;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// otherwise, just grab the next one from the list</span></span><br><span class="line">PooledObject nextInstance = stack.Pop();</span><br><span class="line">nextInstance.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> nextInstance;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReturnToPool</span>(<span class="params">PooledObject pooledObject</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">stack.Push(pooledObject);</span><br><span class="line">pooledObject.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PooledObject</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ObjectPool pool;</span><br><span class="line"><span class="keyword">public</span> ObjectPool Pool &#123; <span class="keyword">get</span> =&gt; pool; <span class="keyword">set</span> =&gt; pool = <span class="keyword">value</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">pool.ReturnToPool(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Singleton"   >          <a href="#Singleton" class="heading-link"><i class="fas fa-link"></i></a><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3>      <p>懒加载（在第一次使用时才实例化）</p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetupInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">this</span>;</span><br><span class="line">DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetupInstance</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">instance = FindObjectOfType&lt;Singleton&gt;();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">GameObject gameObj = <span class="keyword">new</span> GameObject();</span><br><span class="line">gameObj.name = “Singleton”;</span><br><span class="line">instance = gameObj.AddComponent&lt;Singleton&gt;();</span><br><span class="line">DontDestroyOnLoad(gameObj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Command"   >          <a href="#Command" class="heading-link"><i class="fas fa-link"></i></a><a href="#Command" class="headerlink" title="Command"></a>Command</h3>      <p>通过一系列指令栈，实现可撤销操作。</p><p><img src="/../images/1730119449054.png"></p>        <h3 id="StateMachine"   >          <a href="#StateMachine" class="heading-link"><i class="fas fa-link"></i></a><a href="#StateMachine" class="headerlink" title="StateMachine"></a>StateMachine</h3>      <figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Exit</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="Observer"   >          <a href="#Observer" class="heading-link"><i class="fas fa-link"></i></a><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3>      <p>事件的发送者不关心接收者的行为，不同接收者之间也不关心彼此的行为。</p><p><img src="/../images/image-20241029093246133.png" alt="image-20241029093246133"></p><figure class="highlight c#"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件的发送者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subject</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action ThingHappened;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoThing</span>()</span>&#123;</span><br><span class="line">        ThingHappened?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件的接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Observer</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Subject subjectToObserve;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(subjectToObserve !=<span class="literal">null</span>)</span><br><span class="line">            subjectToObserve.ThingHappened += OnThingHappened;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(subjectToObserve !=<span class="literal">null</span>)</span><br><span class="line">            subjectToObserve.ThingHappened -= OnThingHappened;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>※如果没有注销事件而删除了这个对象，在<strong>触发事件时会导致报错</strong>。</p><p>※Unity检视器中的UI事件系统会导致运行变慢。</p>        <h3 id="Model-View-Presenter"   >          <a href="#Model-View-Presenter" class="heading-link"><i class="fas fa-link"></i></a><a href="#Model-View-Presenter" class="headerlink" title="Model View Presenter"></a>Model View Presenter</h3>      <p>MVC：<img src="/../images/image-20241029100928217.png" alt="image-20241029100928217"></p><p>MVP：</p><p><img src="/../images/image-20241029101515862.png" alt="image-20241029101515862"></p>        <h3 id="Model-View-ViewModel-Unity6"   >          <a href="#Model-View-ViewModel-Unity6" class="heading-link"><i class="fas fa-link"></i></a><a href="#Model-View-ViewModel-Unity6" class="headerlink" title="Model-View-ViewModel (Unity6)"></a>Model-View-ViewModel (Unity6)</h3>      <p>在MVC的基础上加了数据绑定，使UI的更新自动化。</p>        <h3 id="Strategy"   >          <a href="#Strategy" class="heading-link"><i class="fas fa-link"></i></a><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h3>              <h3 id="Flyweight"   >          <a href="#Flyweight" class="heading-link"><i class="fas fa-link"></i></a><a href="#Flyweight" class="headerlink" title="Flyweight"></a>Flyweight</h3>              <h2 id="碰撞检测"   >          <a href="#碰撞检测" class="heading-link"><i class="fas fa-link"></i></a><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2>              <h3 id="AABB"   >          <a href="#AABB" class="heading-link"><i class="fas fa-link"></i></a><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3>      <p>Axis-aligned Bounding Box</p><p><img src="https://learnopengl-cn.github.io/img/06/Breakout/05/02/collisions_overlap.png" alt="img"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLboolean <span class="title">CheckCollision</span><span class="params">(GameObject &amp;one, GameObject &amp;two)</span> <span class="comment">// AABB - AABB collision</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x轴方向碰撞？</span></span><br><span class="line">    <span class="type">bool</span> collisionX = one.Position.x + one.Size.x &gt;= two.Position.x &amp;&amp;</span><br><span class="line">        two.Position.x + two.Size.x &gt;= one.Position.x;</span><br><span class="line">    <span class="comment">// y轴方向碰撞？</span></span><br><span class="line">    <span class="type">bool</span> collisionY = one.Position.y + one.Size.y &gt;= two.Position.y &amp;&amp;</span><br><span class="line">        two.Position.y + two.Size.y &gt;= one.Position.y;</span><br><span class="line">    <span class="comment">// 只有两个轴向都有碰撞时才碰撞</span></span><br><span class="line">    <span class="keyword">return</span> collisionX &amp;&amp; collisionY;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></div></figure>        <h3 id="球形"   >          <a href="#球形" class="heading-link"><i class="fas fa-link"></i></a><a href="#球形" class="headerlink" title="球形"></a>球形</h3>      <p><img src="https://learnopengl-cn.github.io/img/06/Breakout/05/02/collisions_aabb_circle.png" alt="img"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLboolean <span class="title">CheckCollision</span><span class="params">(BallObject &amp;one, GameObject &amp;two)</span> <span class="comment">// AABB - Circle collision</span></span></span><br><span class="line"><span class="function"></span>&#123;u</span><br><span class="line">    <span class="comment">// 获取圆的中心 </span></span><br><span class="line">    <span class="function">glm::vec2 <span class="title">center</span><span class="params">(one.Position + one.Radius)</span></span>;</span><br><span class="line">    <span class="comment">// 计算AABB的信息（中心、半边长）</span></span><br><span class="line">    <span class="function">glm::vec2 <span class="title">aabb_half_extents</span><span class="params">(two.Size.x / <span class="number">2</span>, two.Size.y / <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">glm::vec2 <span class="title">aabb_center</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        two.Position.x + aabb_half_extents.x, </span></span></span><br><span class="line"><span class="params"><span class="function">        two.Position.y + aabb_half_extents.y</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="comment">// 获取两个中心的差矢量</span></span><br><span class="line">    glm::vec2 difference = center - aabb_center;</span><br><span class="line">    glm::vec2 clamped = glm::<span class="built_in">clamp</span>(difference, -aabb_half_extents, aabb_half_extents);</span><br><span class="line">    <span class="comment">// AABB_center加上clamped这样就得到了碰撞箱上距离圆最近的点closest</span></span><br><span class="line">    glm::vec2 closest = aabb_center + clamped;</span><br><span class="line">    <span class="comment">// 获得圆心center和最近点closest的矢量并判断是否 length &lt;= radius</span></span><br><span class="line">    difference = closest - center;</span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">length</span>(difference) &lt; one.Radius;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></div></figure>        <h3 id="三角形-lt-gt-球"   >          <a href="#三角形-lt-gt-球" class="heading-link"><i class="fas fa-link"></i></a><a href="#三角形-lt-gt-球" class="headerlink" title="三角形&lt;-&gt;球"></a>三角形&lt;-&gt;球</h3>      <p>①计算球心到三角形的距离</p><p>②如果球心的投影在三角形内，则距离为<strong>到三角形平面的距离</strong></p><p>③如果在外部，则距离为<strong>到其中一条边的距离</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></div></figure><ul><li>计算球心投影是否在三角形内</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v21.cross(normal)得到垂直于[边21]的向三角形内的向量</span></span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot</span>(v21.<span class="built_in">cross</span>(normal), p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot</span>(v32.<span class="built_in">cross</span>(normal), p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot</span>(v13.<span class="built_in">cross</span>(normal), p3);</span><br><span class="line"><span class="comment">// 有一个为负，说明点不在三角形内</span></span><br><span class="line"><span class="type">bool</span> outside = (d1 &lt; <span class="number">0.0f</span> || d2 &lt; <span class="number">0.0f</span> || d3 &lt; <span class="number">0.0f</span>);</span><br></pre></td></tr></table></div></figure><ul><li>计算到三角形平面的距离</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dot</span>(p-v1, normal) / <span class="built_in">length</span>(normal);</span><br></pre></td></tr></table></div></figure><ul><li>计算到每条边的距离</li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆解</span></span><br><span class="line"><span class="comment">// 点在线段上的投影比例t： v21.dot(p1) / dot2(v21)</span></span><br><span class="line"><span class="comment">// 约束到[0,1]： std::clamp(t, 0, 1)</span></span><br><span class="line"><span class="comment">// 得到线段上的最近点Q： v21 * std::clamp(t, 0, 1)</span></span><br><span class="line"><span class="comment">// 计算向量PQ长度</span></span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot2</span>(v21 * std::<span class="built_in">clamp</span>(v21.<span class="built_in">dot</span>(p1) / <span class="built_in">dot2</span>(v21), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot2</span>(v32 * std::<span class="built_in">clamp</span>(v32.<span class="built_in">dot</span>(p2) / <span class="built_in">dot2</span>(v32), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot2</span>(v13 * std::<span class="built_in">clamp</span>(v13.<span class="built_in">dot</span>(p3) / <span class="built_in">dot2</span>(v13), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p3);</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">min</span>(&#123; d1, d2, d3 &#125;));</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">calDistance</span><span class="params">(Point p, Point v1, Point v2, Point v3)</span> </span>&#123;</span><br><span class="line">Point v21 = v2 - v1;</span><br><span class="line">Point v13 = v1 - v3;</span><br><span class="line">Point v32 = v3 - v2;</span><br><span class="line">Point p1 = p - v1;</span><br><span class="line">Point p2 = p - v2;</span><br><span class="line">Point p3 = p - v3;</span><br><span class="line">Point normal = v21.<span class="built_in">cross</span>(v13);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot</span>(v21.<span class="built_in">cross</span>(normal), p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot</span>(v32.<span class="built_in">cross</span>(normal), p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot</span>(v13.<span class="built_in">cross</span>(normal), p3);</span><br><span class="line"><span class="type">bool</span> outside = (d1 &lt; <span class="number">0.0f</span> || d2 &lt; <span class="number">0.0f</span> || d3 &lt; <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (outside) &#123;</span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot</span>(v21 * std::<span class="built_in">clamp</span>(v21.<span class="built_in">dot</span>(p1) / <span class="built_in">dot</span>(v21), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot</span>(v32 * std::<span class="built_in">clamp</span>(v32.<span class="built_in">dot</span>(p2) / <span class="built_in">dot</span>(v32), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot</span>(v13 * std::<span class="built_in">clamp</span>(v13.<span class="built_in">dot</span>(p3) / <span class="built_in">dot</span>(v13), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p3);</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">min</span>(&#123; d1, d2, d3 &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> d = normal.<span class="built_in">dot</span>(p1);</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(d * d / <span class="built_in">dot</span>(normal));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>完整代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">calDistance</span><span class="params">(Point p, Point v1, Point v2, Point v3)</span> </span>&#123;</span><br><span class="line">Point v21 = v2 - v1;</span><br><span class="line">Point v13 = v1 - v3;</span><br><span class="line">Point v32 = v3 - v2;</span><br><span class="line">Point p1 = p - v1;</span><br><span class="line">Point p2 = p - v2;</span><br><span class="line">Point p3 = p - v3;</span><br><span class="line">Point normal = v21.<span class="built_in">cross</span>(v13);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot</span>(v21.<span class="built_in">cross</span>(normal), p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot</span>(v32.<span class="built_in">cross</span>(normal), p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot</span>(v13.<span class="built_in">cross</span>(normal), p3);</span><br><span class="line"><span class="type">bool</span> outside = (d1 &lt; <span class="number">0.0f</span> || d2 &lt; <span class="number">0.0f</span> || d3 &lt; <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (outside) &#123;</span><br><span class="line"><span class="type">float</span> d1 = <span class="built_in">dot</span>(v21 * std::<span class="built_in">clamp</span>(v21.<span class="built_in">dot</span>(p1) / <span class="built_in">dot</span>(v21), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p1);</span><br><span class="line"><span class="type">float</span> d2 = <span class="built_in">dot</span>(v32 * std::<span class="built_in">clamp</span>(v32.<span class="built_in">dot</span>(p2) / <span class="built_in">dot</span>(v32), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p2);</span><br><span class="line"><span class="type">float</span> d3 = <span class="built_in">dot</span>(v13 * std::<span class="built_in">clamp</span>(v13.<span class="built_in">dot</span>(p3) / <span class="built_in">dot</span>(v13), <span class="number">0.0f</span>, <span class="number">1.0f</span>) - p3);</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">min</span>(&#123; d1, d2, d3 &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> d = normal.<span class="built_in">dot</span>(p1);</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(d * d / <span class="built_in">dot</span>(normal));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="游戏机制实现"   >          <a href="#游戏机制实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏机制实现" class="headerlink" title="游戏机制实现"></a>游戏机制实现</h2>      ]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;游戏技术笔记&quot;   &gt;
          &lt;a href=&quot;#游戏技术笔记&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#游戏技术笔记&quot; class=&quot;headerlink&quot; title=&quot;游戏技术笔记&quot;&gt;&lt;/a&gt;游戏技术笔记&lt;/h1&gt;
      
        &lt;h2 id=&quot;多人实时对战&quot;   &gt;
          &lt;a href=&quot;#多人实时对战&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#多人实时对战&quot; class=&quot;headerlink&quot; title=&quot;多人实时对战&quot;&gt;&lt;/a&gt;多人实时对战&lt;/h2&gt;
      &lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;传输内容&lt;/th&gt;
&lt;th&gt;逻辑计算&lt;/th&gt;
&lt;th&gt;断线重连&lt;/th&gt;
&lt;th&gt;回放&amp;#x2F;观战&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;帧同步&lt;/td&gt;
&lt;td&gt;操作&lt;/td&gt;
&lt;td&gt;客户端&lt;/td&gt;
&lt;td&gt;追历史帧&lt;/td&gt;
&lt;td&gt;天然支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;状态同步&lt;/td&gt;
&lt;td&gt;结果&lt;/td&gt;
&lt;td&gt;服务器&lt;/td&gt;
&lt;td&gt;下次同步&lt;/td&gt;
&lt;td&gt;另外实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;不是非此即彼的二选一，最终同步的都是&lt;strong&gt;数据状态&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏制作" scheme="https://lzmustb.github.io/categories/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
    
    <category term="游戏" scheme="https://lzmustb.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>MASM X86 汇编笔记</title>
    <link href="https://lzmustb.github.io/2023/11/28/MASMx86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
    <id>https://lzmustb.github.io/2023/11/28/MASMx86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</id>
    <published>2023-11-28T00:00:28.000Z</published>
    <updated>2024-04-23T08:05:33.043Z</updated>
    
    <content type="html"><![CDATA[<p>汇编课的笔记</p><span id="more"></span>        <h2 id="关于DOS-INT-21H-x2F-AH-x3D-0ah"   >          <a href="#关于DOS-INT-21H-x2F-AH-x3D-0ah" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于DOS-INT-21H-x2F-AH-x3D-0ah" class="headerlink" title="关于DOS INT 21H&#x2F;AH&#x3D;0ah"></a>关于DOS INT 21H&#x2F;AH&#x3D;0ah</h2>      <p>该功能为键盘输入缓冲区</p><p>使用：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">buffer db 20 DUP(&#x27;$&#x27;)</span><br><span class="line">ends data</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax, data </span><br><span class="line">mov ds, ax;初始化数据段 </span><br><span class="line"></span><br><span class="line">mov ah,0ah</span><br><span class="line">mov dx,offset buffer</span><br><span class="line">int 21h;输入缓冲区</span><br><span class="line"></span><br><span class="line">mov      ah,9</span><br><span class="line">    lea      dx,buffer+2</span><br><span class="line">    int      21h;输出缓冲区</span><br><span class="line">ends</span><br></pre></td></tr></table></div></figure><p>注意点：</p><p>下图7100h~7113h为buffer的20个空间</p><p>当输入“helloworld”时，可以看到输入为7101h~710ch</p><p>总结：</p><ul><li><p>真正用户输入的内容从dx+2开始，</p></li><li><p>输入的结尾为CRET（回车符）</p></li><li><p>缓冲区的前两个字符为$和随机值</p></li><li><p>由于输出(AH&#x3D;9)要靠‘$’判断字符串结束，因此设置缓冲区大小应不小于<strong>N+4</strong>（N为你需要输入的字符数）</p></li></ul><p><img src="E:\BlogData\source\images\image-20231128205600204.png" alt="image-20231128205600204"></p>        <h2 id="宏定义（函数定义）"   >          <a href="#宏定义（函数定义）" class="heading-link"><i class="fas fa-link"></i></a><a href="#宏定义（函数定义）" class="headerlink" title="宏定义（函数定义）"></a>宏定义（函数定义）</h2>      <p>使用<code>macro</code>关键字</p><p>※在macro中使用跳转时，需声明<code>local label1，label2</code></p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;输出换行符的宏指令</span><br><span class="line">nextline macro [param1,param2,param3...]</span><br><span class="line">          mov ah,9</span><br><span class="line">          lea dx,cret</span><br><span class="line">          int 21h</span><br><span class="line">nextline endm</span><br><span class="line">;调用：</span><br><span class="line">...</span><br><span class="line">nextline</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;数字转换成ASCII码并输出：</span><br><span class="line">num_to_asc macro num </span><br><span class="line">;local label1，label2</span><br><span class="line">    mov al,num</span><br><span class="line">    mov ah,0h</span><br><span class="line">    aam</span><br><span class="line">    mov bx,ax</span><br><span class="line">    add bl,30h</span><br><span class="line">    add bh,30h         </span><br><span class="line">    mov ah,02h  </span><br><span class="line">    mov dl,bh</span><br><span class="line">    int 21h   </span><br><span class="line">    mov dl,bl</span><br><span class="line">    int 21h</span><br><span class="line">num_to_asc endm  </span><br></pre></td></tr></table></div></figure>        <h2 id="LOOP"   >          <a href="#LOOP" class="heading-link"><i class="fas fa-link"></i></a><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h2>      <p>格式：<code>LOOP loop标号</code></p><p>执行loop指令时会有隐式的两步操作：</p><pre><code>* (cx)=(cx)-1* 判断(cx)的值为ZERO则停止循环</code></pre>        <h2 id="移位指令"   >          <a href="#移位指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h2>      <ul><li>逻辑移位(无符号)：补0<ul><li><code>SHL</code>,<code>SHR</code></li></ul></li><li>算术移位：最高位不变<ul><li><code>SAL</code>,<code>SAR</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;汇编课的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Javascript与前端算法</title>
    <link href="https://lzmustb.github.io/2023/09/08/my-javascript-note/"/>
    <id>https://lzmustb.github.io/2023/09/08/my-javascript-note/</id>
    <published>2023-09-08T00:00:28.000Z</published>
    <updated>2023-09-24T01:23:32.296Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="Javascript"   >          <a href="#Javascript" class="heading-link"><i class="fas fa-link"></i></a><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1>              <h2 id="ES6"   >          <a href="#ES6" class="heading-link"><i class="fas fa-link"></i></a><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2>              <h3 id="Map"   >          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map" class="headerlink" title="Map"></a>Map</h3>      <p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><p>也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“<strong>值—值</strong>”的对应，是一种更完善的 Hash 结构实现。</p><span id="more"></span><ul><li>实例化</li></ul><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空map</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//初始化map，通过数组表示键值对</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">   [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>],</span><br><span class="line">   [<span class="string">&#x27;age&#x27;</span>,<span class="number">16</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></div></figure><ul><li>方法</li></ul><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="property">size</span> <span class="comment">//2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//&#x27;Jack&#x27;</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>); <span class="comment">//返回对象本身，可链式调用</span></span><br><span class="line">map.<span class="title function_">delete</span>(key); <span class="comment">//删除成功返回true</span></span><br><span class="line">map.<span class="title function_">clear</span>(); <span class="comment">//清除所有成员，无返回值</span></span><br><span class="line"></span><br><span class="line">&lt;!--遍历:--&gt;</span><br><span class="line">map.<span class="title function_">keys</span>(); <span class="comment">//返回键名的遍历器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">values</span>(); <span class="comment">//返回键值的遍历器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">entries</span>(); <span class="comment">//返回所有成员的遍历器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--与数组结合:--&gt;</span><br><span class="line">[...map.<span class="title function_">keys</span>()];</span><br><span class="line">[...map.<span class="title function_">values</span>()];</span><br><span class="line">[...map];</span><br><span class="line">[...map.<span class="title function_">entries</span>()];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组filter创建新map</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>※注意点</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有对同一个对象的引用，Map结构才将其视为同一个键</span></span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的值的两个实例，在 Map 结构中被视为两个键</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">map.<span class="title function_">set</span>(k1,<span class="number">1</span>);<span class="comment">//两者不同</span></span><br><span class="line">map.<span class="title function_">set</span>(k2,<span class="number">2</span>);<span class="comment">//两者不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined和null是两个键</span></span><br><span class="line"><span class="comment">//NaN为同一个键</span></span><br><span class="line"><span class="comment">//0，-0为同一个键</span></span><br></pre></td></tr></table></div></figure>        <h3 id="Class"   >          <a href="#Class" class="heading-link"><i class="fas fa-link"></i></a><a href="#Class" class="headerlink" title="Class"></a>Class</h3>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.基本类语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"> name , age </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我叫&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&#x27;,今年&#x27;</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">walk</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会走路&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">p.<span class="title function_">say</span>(); <span class="comment">//成员方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">walk</span>(); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.原型继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name,age,gender</span>)&#123;</span><br><span class="line">        <span class="comment">//通过super可以调用父类构造器或方法</span></span><br><span class="line">        <span class="variable language_">super</span>(name,age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">gender</span>=gender;</span><br><span class="line">        <span class="comment">//super作为对象时，指向父类的原型对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">func</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ES6中规定，子类的构造函数必须执行一次super函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.getter,setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用get和set关键字可设置存值函数和取值函数</span></span><br><span class="line"><span class="comment">//拦截该属性的存取行为</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="property">prop</span> = <span class="number">666</span>; <span class="comment">//setter: 666</span></span><br></pre></td></tr></table></div></figure><p>虽然引入了关键字，但ES6中并没有真的引入类这个概念，通过class定义的仍然是函数。class仅仅是通过更简单直观的语法去实现原型链继承。这种对语言功能没有影响、但是给程序员带来方便的新语法，被称为<strong>语法糖</strong>。</p><p>在 constructor 里面，super 的用法是 super()。它相当于一个函数，调用它等于调用父类的 constructor 。</p><p>但在普通方法里面，super 的用法是 super.prop 或者 super.method()，它相当于一个指向对象的 [[Prototype]] 的属性。</p>        <h2 id="前端算法"   >          <a href="#前端算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#前端算法" class="headerlink" title="前端算法"></a>前端算法</h2>              <h3 id="链表"   >          <a href="#链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表" class="headerlink" title="链表"></a>链表</h3>              <h4 id="双指针"   >          <a href="#双指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4>      <p>判断链表有无成环</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> slow = head;</span><br><span class="line"><span class="keyword">let</span> fast = head;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123;</span><br><span class="line">fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">slow = slow.<span class="property">next</span>;</span><br><span class="line">    <span class="comment">//快慢指针相遇说明链表成环</span></span><br><span class="line"><span class="keyword">if</span>(slow===fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="LRUcache"   >          <a href="#LRUcache" class="heading-link"><i class="fas fa-link"></i></a><a href="#LRUcache" class="headerlink" title="LRUcache"></a>LRUcache</h4>      <p>least recently use cache</p><p>Vue的<code>&lt;keep-alive&gt;</code>组件使用了<strong>LRUcache（最少最近使用缓存）</strong>。</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxSize</span> = capacity; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="comment">//若key对应的value存在，在返回之前将其排在队尾</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key,tmp);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key,value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span>&gt;=<span class="variable language_">this</span>.<span class="property">maxSize</span>)&#123;</span><br><span class="line">            <span class="comment">//如果新增元素将超过缓存容量，淘汰队首元素</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="位运算"   >          <a href="#位运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3>              <h4 id="组合权限认证"   >          <a href="#组合权限认证" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合权限认证" class="headerlink" title="组合权限认证"></a>组合权限认证</h4>      <ul><li>标记：通过二进制位标记某个属性</li><li>授权：<strong>或运算</strong>授予一个变量多个属性</li><li>校验：<strong>与运算</strong>判断有无该属性</li><li>删除：<strong>异或运算</strong>删除一个属性</li></ul><p>vue中判断虚拟DOM类型</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">ShapeFlags</span>&#123;</span><br><span class="line"><span class="variable constant_">ELEMENT</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="variable constant_">FUNCTIONAL_COMPONENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="variable constant_">STATEFUL_COMPONENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable constant_">COMPONENT</span> = <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span> | <span class="title class_">ShapeFlags</span>.<span class="property">FUNCTIONAL_COMPONENT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>判断一个数是否为2的整数次幂</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n&gt;<span class="number">0</span> </span><br><span class="line">&amp;&amp;</span><br><span class="line">n &amp; (n-<span class="number">1</span>) === <span class="number">0</span> </span><br></pre></td></tr></table></div></figure><p>异或去重</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^a^b^b^c <span class="comment">//c</span></span><br></pre></td></tr></table></div></figure>        <h3 id="树结构"   >          <a href="#树结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3>      <p>递归翻转</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">invertTree=<span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">[root.<span class="property">left</span>,root.<span class="property">right</span>]=[<span class="title function_">invertTree</span>(root.<span class="property">right</span>),<span class="title function_">invertTree</span>(root.<span class="property">left</span>)];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="栈"   >          <a href="#栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈" class="headerlink" title="栈"></a>栈</h3>      <p>判断html标签是否闭合，简化路径</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack=[];</span><br><span class="line"><span class="keyword">let</span> paths=path.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;paths.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> p = paths[i];</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="string">&#x27;..&#x27;</span>)&#123;</span><br><span class="line">        spack.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p &amp;&amp; p!==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     stack.<span class="title function_">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span>+stack.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br></pre></td></tr></table></div></figure>        <h3 id="排序"   >          <a href="#排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序" class="headerlink" title="排序"></a>排序</h3>              <h4 id="快速排序"   >          <a href="#快速排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4>      <p> 每次将数组二分为<code>比x小的数组</code>和<code>比x大的数组</code>，递归至数组大小为1</p><p>O(n*logn）</p>        <h3 id="leftPad"   >          <a href="#leftPad" class="heading-link"><i class="fas fa-link"></i></a><a href="#leftPad" class="headerlink" title="leftPad"></a>leftPad</h3>      <p>二分优化</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leftpad</span>(<span class="params">str,length,ch</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = length - str.<span class="property">length</span> ;</span><br><span class="line">    total = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &amp; <span class="number">1</span>)&#123; <span class="comment">//相当于len%2==1</span></span><br><span class="line">            total+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> total+str</span><br><span class="line">        &#125;</span><br><span class="line">        ch+=ch;</span><br><span class="line">        len=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Javascript&quot;   &gt;
          &lt;a href=&quot;#Javascript&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Javascript&quot; class=&quot;headerlink&quot; title=&quot;Javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h1&gt;
      
        &lt;h2 id=&quot;ES6&quot;   &gt;
          &lt;a href=&quot;#ES6&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;
      
        &lt;h3 id=&quot;Map&quot;   &gt;
          &lt;a href=&quot;#Map&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;
      &lt;p&gt;JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，ES6 提供了 Map 数据结构。它也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。&lt;/p&gt;
&lt;p&gt;也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“&lt;strong&gt;值—值&lt;/strong&gt;”的对应，是一种更完善的 Hash 结构实现。&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="前端" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基本乐理与声音设计</title>
    <link href="https://lzmustb.github.io/2023/07/19/my-music-note/"/>
    <id>https://lzmustb.github.io/2023/07/19/my-music-note/</id>
    <published>2023-07-19T13:52:54.000Z</published>
    <updated>2024-03-23T07:50:10.057Z</updated>
    
    <content type="html"><![CDATA[<p>音乐学习相关的笔记</p><span id="more"></span>        <h1 id="基本乐理"   >          <a href="#基本乐理" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本乐理" class="headerlink" title="基本乐理"></a>基本乐理</h1>              <h3 id="泛音-倍音，倍频"   >          <a href="#泛音-倍音，倍频" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛音-倍音，倍频" class="headerlink" title="泛音(倍音，倍频)"></a>泛音(倍音，倍频)</h3>      <p><img src="/../images/image-20230901164632960.png" alt="image-20230901164632960"></p><p>整数次谐波&#x3D;&gt;基音，倍音<br><img src="/../images/image-20230901164700405.png" alt="image-20230901164700405"></p><p>和弦和单音在物理学意义上没有区别<br><img src="/../images/image-20230901164715003.png" alt="image-20230901164715003"></p>        <h2 id="音乐基础"   >          <a href="#音乐基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#音乐基础" class="headerlink" title="音乐基础"></a>音乐基础</h2>              <h3 id="三要素"   >          <a href="#三要素" class="heading-link"><i class="fas fa-link"></i></a><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3>      <ul><li>节奏</li><li>旋律</li><li>和声</li></ul>        <h3 id="音程-interval"   >          <a href="#音程-interval" class="heading-link"><i class="fas fa-link"></i></a><a href="#音程-interval" class="headerlink" title="音程-interval"></a>音程-interval</h3>      <div class="table-container"><table><thead><tr><th><strong>度数名</strong></th><th><strong>英語</strong></th><th><strong>例（ドの場合※）</strong></th><th><strong>半音数</strong></th><th><strong>テンションとして見た場合</strong></th></tr></thead><tbody><tr><td><strong>完全1度</strong></td><td>P1&#x2F;d2</td><td>ド（同じ音）</td><td>0</td><td></td></tr><tr><td>増1度&#x2F;短2度</td><td>m2&#x2F;A1</td><td>ド♯&#x2F;レ♭</td><td>1</td><td>♭9th</td></tr><tr><td>長2度&#x2F;減3度</td><td>M2&#x2F;d3</td><td>レ&#x2F;ミ♭♭</td><td>2</td><td>9th</td></tr><tr><td>増2度&#x2F;短3度</td><td>m3&#x2F;A2</td><td>レ#&#x2F;ミ♭</td><td>3</td><td>♯9th</td></tr><tr><td>長3度&#x2F;減4度</td><td>M3&#x2F;d4</td><td>ミ&#x2F;ファ♭</td><td>4</td><td></td></tr><tr><td><strong>完全4度</strong>&#x2F;増3度</td><td>P4&#x2F;A3</td><td>ファ&#x2F;ミ♯</td><td>5</td><td>11th</td></tr><tr><td>増4度&#x2F;減5度</td><td>A5&#x2F;d5</td><td>ファ♯&#x2F;ソ♭</td><td>6</td><td>♯11th</td></tr><tr><td><strong>完全5度</strong></td><td>P5</td><td>ソ</td><td>7</td><td></td></tr><tr><td>増5度&#x2F;短6度</td><td>A5&#x2F;m6</td><td>ソ♯&#x2F;ラ♭</td><td>8</td><td>♭13th</td></tr><tr><td>長6度&#x2F;減7度</td><td>M6&#x2F;d7</td><td>ラ&#x2F;シ♭♭</td><td>9</td><td>13th</td></tr><tr><td>短7度</td><td>m7</td><td>ラ♯&#x2F;シ♭</td><td>10</td><td></td></tr><tr><td>長7度</td><td>M7</td><td>シ</td><td>11</td><td></td></tr><tr><td><strong>完全8度</strong></td><td>P8</td><td>ド（オクターブ上）</td><td>12</td><td></td></tr></tbody></table></div><ul><li><strong>P</strong>…パーフェクト（完全）</li><li><strong>M</strong>…メジャー（長）</li><li><strong>m</strong>…マイナー（短）</li><li><strong>A</strong>…オーグメンテッド（増）</li><li><strong>d</strong>…ディミニッシュト（減）</li></ul><p>异名同音(×为##)：<br><img src="/../images/image-20230901164732238.png" alt="image-20230901164732238"></p>        <h3 id="大小调"   >          <a href="#大小调" class="heading-link"><i class="fas fa-link"></i></a><a href="#大小调" class="headerlink" title="大小调"></a>大小调</h3>      <p>与大调有关的三个小调：（只按自然小调标升降号）</p><ul><li>自然小调：组成音完全相同（C大调&#x2F;A小调）</li><li>和声小调：自然小调升第七个音</li><li>旋律小调：下行自然小调，上行自然小调升六七音</li></ul><p>12大调，48大小调</p>        <h3 id="冠音"   >          <a href="#冠音" class="heading-link"><i class="fas fa-link"></i></a><a href="#冠音" class="headerlink" title="冠音"></a>冠音</h3>      <p>最高音，大部分情况下是旋律音</p><p><img src="/../images/image-20230829115933572.png" alt="image-20230829115933572"></p><p><img src="/../images/image-20230901164746538.png" alt="image-20230901164746538"></p>        <h3 id="五度圈"   >          <a href="#五度圈" class="heading-link"><i class="fas fa-link"></i></a><a href="#五度圈" class="headerlink" title="五度圈"></a>五度圈</h3>      <p><img src="/../images/co5th.png" alt="PNG"></p><p>查看基调和弦：以A大调为例，由框内的六个音组成<br>    <img src="/../images/1694867599892.png" alt="1694867599892"></p>        <h2 id="和弦"   >          <a href="#和弦" class="heading-link"><i class="fas fa-link"></i></a><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h2>      <p>五音经常可以被省略，通常不影响和弦判断</p><p>三音和七音不能省</p>        <h3 id="钢琴指法"   >          <a href="#钢琴指法" class="heading-link"><i class="fas fa-link"></i></a><a href="#钢琴指法" class="headerlink" title="钢琴指法"></a>钢琴指法</h3>      <ul><li>m：三音左移半音</li><li>♯：全部右移半音</li><li>♭：全部左移半音</li><li>dim：三音，五音左移半音</li><li>sus4：三音右移半音（挂4和弦）</li><li>aug：五音右移半音</li><li>-5&#x2F;b5：五音左移半音（flat five）</li><li>6：七音在五音的右侧两个半音位置</li><li>7：七音在五音的右侧3个半音位置</li><li>9：短七音+九音</li><li>M7（Δ7）：七音在五音的右侧4个半音位置</li><li>add9：七音在根音的右侧两个半音位</li></ul>        <h3 id="cadence-x2F-终止"   >          <a href="#cadence-x2F-终止" class="heading-link"><i class="fas fa-link"></i></a><a href="#cadence-x2F-终止" class="headerlink" title="cadence&#x2F;终止"></a>cadence&#x2F;终止</h3>      <ul><li>Authentic&#x2F;正格终止（Ⅴ→Ⅰ）<ul><li>perfect authentic（根音&#x3D;和弦最低音&amp;和弦最高声部为Tonic）</li><li>imperfect authentic</li></ul></li><li>half&#x2F;半终止（→Ⅴ）</li><li>plagal&#x2F;变格终止（Ⅳ→Ⅰ）</li><li>deceptive&#x2F;伪终止（Ⅴ→Ⅵm）</li></ul>        <h3 id="和声机能"   >          <a href="#和声机能" class="heading-link"><i class="fas fa-link"></i></a><a href="#和声机能" class="headerlink" title="和声机能"></a>和声机能</h3>      <p><img src="/../images/1694871651941.png" alt="1694871651941"></p><p><img src="/../images/1694872296729.png" alt="1694872296729"></p><p>Ⅲm在有些时候会有<strong>T</strong>的作用</p><p><img src="/../images/image-20230917084451373.png" alt="image-20230917084451373"></p>        <h3 id="和声韵律-Harmonic-rhythm"   >          <a href="#和声韵律-Harmonic-rhythm" class="heading-link"><i class="fas fa-link"></i></a><a href="#和声韵律-Harmonic-rhythm" class="headerlink" title="和声韵律(Harmonic rhythm)"></a>和声韵律(Harmonic rhythm)</h3>              <h3 id="常见和声"   >          <a href="#常见和声" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见和声" class="headerlink" title="常见和声"></a>常见和声</h3>      <ul><li>丸之内&#x2F;just the two of us</li></ul><p>$$<br>ⅣM7-Ⅲ7-Ⅵm7-Ⅰ7<br>$$</p>        <h2 id="人声的范围"   >          <a href="#人声的范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#人声的范围" class="headerlink" title="人声的范围"></a>人声的范围</h2>      <p><img src="/../images/image-20230903194409225.png" alt="image-20230903194409225"></p>        <h2 id="转调"   >          <a href="#转调" class="heading-link"><i class="fas fa-link"></i></a><a href="#转调" class="headerlink" title="转调"></a>转调</h2>      <p><img src="/../images/image-20230903194746090.png" alt="image-20230903194746090"></p>        <h2 id="旋律"   >          <a href="#旋律" class="heading-link"><i class="fas fa-link"></i></a><a href="#旋律" class="headerlink" title="旋律"></a>旋律</h2>              <h3 id="五音音阶-Pentatonic"   >          <a href="#五音音阶-Pentatonic" class="heading-link"><i class="fas fa-link"></i></a><a href="#五音音阶-Pentatonic" class="headerlink" title="五音音阶 Pentatonic"></a>五音音阶 Pentatonic</h3>              <h3 id="注意点"   >          <a href="#注意点" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3>      <p>  <img src="/../images/image-20230903200858730.png" alt="image-20230903200858730"></p>        <h3 id="和弦外音"   >          <a href="#和弦外音" class="heading-link"><i class="fas fa-link"></i></a><a href="#和弦外音" class="headerlink" title="和弦外音"></a>和弦外音</h3>      <ul><li>经过音：两个和弦音之间的音</li><li>相邻音：两个相同的音之间差一个以上相邻的音</li><li>先现音：提前出现下一个和弦的音</li><li>跳脱音</li><li>倚音</li><li>悬挂音suspension&#x2F;retardation</li></ul>        <h3 id="付点-x2F-切分"   >          <a href="#付点-x2F-切分" class="heading-link"><i class="fas fa-link"></i></a><a href="#付点-x2F-切分" class="headerlink" title="付点&#x2F;切分"></a>付点&#x2F;切分</h3>              <h2 id="节奏"   >          <a href="#节奏" class="heading-link"><i class="fas fa-link"></i></a><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h2>              <h3 id="鼓的构成"   >          <a href="#鼓的构成" class="heading-link"><i class="fas fa-link"></i></a><a href="#鼓的构成" class="headerlink" title="鼓的构成"></a>鼓的构成</h3>      <ul><li>Kick</li><li>Hi-Hat：通常是将节奏分的最细的部分，根据Hi-hat的节奏，将节奏类型分为8beat，16beat等</li><li>Snare</li></ul><p>ghost note</p><p><img src="/../images/1694958953650.png" alt="1694958953650"></p>        <h3 id="Syncopation"   >          <a href="#Syncopation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Syncopation" class="headerlink" title="Syncopation"></a>Syncopation</h3>      <p><img src="/../images/image-20230917220432748.png" alt="image-20230917220432748"></p>        <h3 id="Anticipation"   >          <a href="#Anticipation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Anticipation" class="headerlink" title="Anticipation"></a>Anticipation</h3>      <p><img src="/../images/image-20230917221947515.png" alt="image-20230917221947515"></p>        <h1 id="设计声音"   >          <a href="#设计声音" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计声音" class="headerlink" title="设计声音"></a>设计声音</h1>              <h2 id="物理学系统"   >          <a href="#物理学系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理学系统" class="headerlink" title="物理学系统"></a>物理学系统</h2>      <ul><li><p>自由度：物体能够运动的方向的数量（三个平移自由度，三个转动自由度）在声音模型中通常假设仅有一个自由度</p></li><li><p>激励者：把能量带给系统的物体</p></li><li><p>受激：产生振动的物体</p><p>在声音的产生过程中，激励者和受激缺一不可</p></li></ul>        <h3 id="材料"   >          <a href="#材料" class="heading-link"><i class="fas fa-link"></i></a><a href="#材料" class="headerlink" title="材料"></a>材料</h3>      <ul><li>质量</li><li>弹性&#x2F;塑性</li><li>硬度</li><li>密度</li><li>结构与强度</li></ul><p>材料对声音的影响主要体现在质量和弹性两个方面。不同状态(固液气)的物体对声音的传导能力不同</p><p>体积模量K（E：杨氏模量；v：泊松比）：<br>$$<br>K&#x3D;\frac{E}{3(1-2v)}<br>$$</p>        <h3 id="波"   >          <a href="#波" class="heading-link"><i class="fas fa-link"></i></a><a href="#波" class="headerlink" title="波"></a>波</h3>      <ul><li><p>横波&#x2F;纵波&#x2F;扭转波</p></li><li><p>速度（质点速度，相速度，群速度）</p></li><li><p>幅度</p></li></ul><p><strong>声速</strong>（相速度phase velocity）c近似公式（K：杨氏模量；ρ：密度）：<br>$$<br>c&#x3D;\sqrt{\frac{K}{ρ}}<br>$$</p><p>$$<br>c&#x3D;fλ<br>$$</p><p><strong>群速度</strong>：取决于介质属性的常量，通常与相速度相等。当相速度和群速度不完全相等时，该介质弥散（dispersive），如水波冲刷海岸的现象。</p>        <h3 id="界面"   >          <a href="#界面" class="heading-link"><i class="fas fa-link"></i></a><a href="#界面" class="headerlink" title="界面"></a>界面</h3>      <p>当界面的两种物质相差极大时，声音中有很大一部分会被反射，很小一部分会传导。对于水和空气，这个比率约为99%。</p><p>入射角会影响反射波的强度，在布鲁斯特角，反射波会消失。</p><p><strong>固体界面处的弯曲波相位</strong>：对于坚硬界面的材料，波会反相反射；对于弹性界面的材料，波会同相反射。</p><p>反射波与入射波具有相同的波长和波速，但幅度较小。</p><p>被传导的波在新的介质中有新的波长，频率不变。</p><p><strong>驻波</strong>：持续不断的行波与反射波叠加干涉，形成驻波（在吉他中，第一个是基音，后面的是泛音）</p><p><img src="/../images/image-20230901105905563.png" alt="image-20230901105905563"></p>        <h3 id="模拟（analogue）"   >          <a href="#模拟（analogue）" class="heading-link"><i class="fas fa-link"></i></a><a href="#模拟（analogue）" class="headerlink" title="模拟（analogue）"></a>模拟（analogue）</h3>      <p>借由其他类似系统进行推理，达到连续测量的目的。在声音设计中主要考虑“电，力，声”三种系统。</p><ul><li><p>流动：</p><ul><li><p>电学：电流</p></li><li><p>力学：速度</p></li><li><p>声学：体积流动</p><p><img src="/../images/image-20230901115743564.png" alt="image-20230901115743564"></p></li></ul></li><li><p>质量：</p><ul><li><p>电学：电感</p></li><li><p>力学：质量</p></li><li><p>声学：声质量 <em>inertance</em></p><blockquote><p>（流动介质的质量除以波阵面的横截面积）</p></blockquote></li></ul></li><li><p>阻抗：</p><ul><li><p>电学：电阻</p></li><li><p>力学：摩擦</p></li><li><p>声学：粘滞力，介质的耗散属性</p><blockquote><p>（波阵面上的声波压强除以体积速度）</p></blockquote><p><img src="/../images/image-20230901115909642.png" alt="image-20230901115909642"></p></li></ul></li><li><p>容抗</p><ul><li>电学：电容</li><li>力学：柔度，硬度的倒数</li><li>声学：声容，与所施压强的变化相抗的量<br>  <img src="/../images/image-20230901115803986.png" alt="image-20230901115803986"></li></ul></li></ul><p><strong>将被敲打的弦的类比系统</strong>：</p><p><img src="/../images/image-20230901120723041.png" alt="image-20230901120723041"></p><p><strong>对钟和小提琴的entity-action解构</strong>：</p><p><img src="/../images/image-20230901120828572.png" alt="image-20230901120828572"></p>        <h3 id="振动"   >          <a href="#振动" class="heading-link"><i class="fas fa-link"></i></a><a href="#振动" class="headerlink" title="振动"></a>振动</h3>      <p>周期波听起来像有固定的音高，而非周期波听起来很复杂或类似噪声。</p><ul><li><p>弛豫振荡relaxation oscillator</p></li><li><p>简谐振荡</p></li></ul><p>弦的固有频率：(L:长度；T:张力；mu:单位长度质量)<br>$$<br>f&#x3D;\frac{1}{2L}\sqrt{\frac{T}{m_u}}<br>$$<br>简单几何形状的物体大致可以分为两类：能够自由振动的物体，和在张力下的物体。琴弦，鼓皮会以与它们所受张力有关的频率振动。</p>        <h4 id="受激振荡与谐振"   >          <a href="#受激振荡与谐振" class="heading-link"><i class="fas fa-link"></i></a><a href="#受激振荡与谐振" class="headerlink" title="受激振荡与谐振"></a>受激振荡与谐振</h4>      <p>共振系统在不同阻尼下的响应：</p><p><img src="/../images/image-20230901145420644.png" alt="image-20230901145420644"></p><p>将驱动振荡器看作是对能量流动的阻抗，随着驱动频率远离固有频率，能量的转移越来越小。</p><p>受激系统的行为就像是<strong>滤波器(filter)<strong>。当系统阻尼较小时，系统具有</strong>高谐振，窄带宽</strong>的特性，而受到强烈阻尼的系统具有<strong>低谐振，宽带宽</strong>的特性。</p>        <h2 id="声学系统"   >          <a href="#声学系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#声学系统" class="headerlink" title="声学系统"></a>声学系统</h2>      <p>在声学中我们仅考虑<strong>纵波</strong>，总体积的行为。</p><p>空气中的声速方程：<br>$$<br>c&#x3D;\sqrt{\frac{γp}{ρ}}&#x3D;\sqrt{\frac{γRT}{M}}<br>$$<br>R：摩尔气体常数，T：绝对温度，M：摩尔质量</p>        <h3 id="声压级-amp-声强级"   >          <a href="#声压级-amp-声强级" class="heading-link"><i class="fas fa-link"></i></a><a href="#声压级-amp-声强级" class="headerlink" title="声压级&amp;声强级"></a>声压级&amp;声强级</h3>      <p>声压p是单位面积上的一个力，波的峰值声压反比于距离，所以若与声源相距为r，则峰值按1&#x2F;r减少。</p><p>声压级（Sound pressure level）是一个以分贝为单位的比率，设20μN&#x2F;m^2^作为声学上最小可测量值，则：<br>$$<br>SPL&#x3D;20log_{10}\frac{p(N&#x2F;m^2)}{2*10^{-5}}<br>$$<br>※声波的声压级不会超过194dB，这个值意味着疏部压强为真空压强。（在爆炸和闪电中存在压强大于194dB的单极性脉冲）</p><hr><p>声音强度I是单位面积上的功率，用W(瓦特)&#x2F;m^2表示，它正比于声压级的平方。</p><p>对于谐波平面波：（ρ：密度，c：相速度）<br>$$<br>I&#x3D;±\frac{p^2}{2ρc}<br>$$<br>声强级(sound intensity level)是以分贝为单位的比率，以10^-12^W&#x2F;m^2^作为参考值：<br>$$<br>SIL&#x3D;10log_{10}{\frac{I}{10^{-12}}}<br>$$</p>        <h3 id="位置与相干性"   >          <a href="#位置与相干性" class="heading-link"><i class="fas fa-link"></i></a><a href="#位置与相干性" class="headerlink" title="位置与相干性"></a>位置与相干性</h3>      <p>当观察者听到来自不同声源（或是反射波）的<strong>相关</strong>声音时，声音可能被加强或减小。当声源移动，则声音不断地加强或对消，观察者会听到一个扫频的陷波滤波效果。</p><p><img src="/../images/image-20230901153530820.png" alt="image-20230901153530820"></p><p>如果各个声源相似但由单独的机制产生（如合唱，一团蜜蜂）那么声源之间不具有<strong>相关性</strong>。</p><p>对于大量的声源集合，相关与否会导致观察到的平均幅度上的显著差异：<br>$$<br>A_{相关}&#x3D;A_a+A_b+A_c\cdots\<br>A_{不相关}&#x3D;\sqrtNaN<br>$$</p>        <h3 id="衰减"   >          <a href="#衰减" class="heading-link"><i class="fas fa-link"></i></a><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3>              <h4 id="距离导致的几何损耗"   >          <a href="#距离导致的几何损耗" class="heading-link"><i class="fas fa-link"></i></a><a href="#距离导致的几何损耗" class="headerlink" title="距离导致的几何损耗"></a>距离导致的几何损耗</h4>      <p><img src="/../images/image-20230901160653650.png" alt="image-20230901160653650"></p><p>对于圆柱模型（琴弦，或是繁忙的公路），辐射功率的耗散正比于距离。</p><p>对于球模型，功率耗散正比于距离的平方。</p>        <h4 id="吸收导致的能量损耗"   >          <a href="#吸收导致的能量损耗" class="heading-link"><i class="fas fa-link"></i></a><a href="#吸收导致的能量损耗" class="headerlink" title="吸收导致的能量损耗"></a>吸收导致的能量损耗</h4>      <p>声音频率越高，速度越快，吸收损耗越大（斯托克斯定律）</p><p>衰减α：(η：粘滞度)<br>$$<br>α&#x3D;\frac{2η2\pi\f^2}{3ρc^3}(Np&#x2F;m)\ *8.685889\rightarrow(dB&#x2F;m)<br>$$</p>        <h3 id="传播效应"   >          <a href="#传播效应" class="heading-link"><i class="fas fa-link"></i></a><a href="#传播效应" class="headerlink" title="传播效应"></a>传播效应</h3>      <p>P58补</p><ul><li>反射</li></ul><p>纵向的声波在反射时会保持相同的(压强)相位，我们将听到由直达波和反射波相互叠加所引起的效果，类似的驻波模式图样将出现在房间等声学空间中。<br><img src="/../images/image-20230904131043414.png" alt="image-20230904131043414"></p><ul><li><p>散射</p></li><li><p>弥散</p></li><li><p>折射</p></li><li><p>衍射</p></li></ul>        <h3 id="声学振荡"   >          <a href="#声学振荡" class="heading-link"><i class="fas fa-link"></i></a><a href="#声学振荡" class="headerlink" title="声学振荡"></a>声学振荡</h3>              <h2 id="心理声学"   >          <a href="#心理声学" class="heading-link"><i class="fas fa-link"></i></a><a href="#心理声学" class="headerlink" title="心理声学"></a>心理声学</h2>      <p>人类听觉的频率范围：20~20kHz</p><p>自然声音（语音和音乐）的大部分频率都在300~3kHz之间。</p>        <h3 id="定位"   >          <a href="#定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#定位" class="headerlink" title="定位"></a>定位</h3>      <p>三大规律：</p><ul><li>高频声音比低频声音更容易定位，且声音刚开始的时候比延音更容易定位。</li><li>在户外或自由空间中对声音的定位能力好于在具有大量反射的小房间中的定位能力。</li><li>倾斜头部能获得更好的仰角感知，更容易定位</li></ul>        <h4 id="耳间强度差IID"   >          <a href="#耳间强度差IID" class="heading-link"><i class="fas fa-link"></i></a><a href="#耳间强度差IID" class="headerlink" title="耳间强度差IID"></a>耳间强度差IID</h4>      <p>抵达每只耳朵的相对幅度（即立体声系统中的<strong>声像定位-panning</strong>）</p><p>在频率高于700Hz开始有效，1.5kHz以上时完全工作。</p>        <h4 id="耳间时间差ITD"   >          <a href="#耳间时间差ITD" class="heading-link"><i class="fas fa-link"></i></a><a href="#耳间时间差ITD" class="headerlink" title="耳间时间差ITD"></a>耳间时间差ITD</h4>      <p>声音抵达两只耳朵的时间差值。当多于一个完整波长放到两耳之间（15~25cm），就会引起含糊不清。</p><p>因此耳间时间差对700Hz以下的声音最有效，在1.5kHz以上时无效。</p><p>(r:头部半径；θ：与鼻子方向中线的夹角)<br>$$<br>ITD&#x3D;r\frac{(θ+sinθ)}{c}<br>$$</p>        <h3 id="响度"   >          <a href="#响度" class="heading-link"><i class="fas fa-link"></i></a><a href="#响度" class="headerlink" title="响度"></a>响度</h3>      <p>声音的响度是一个主观数值，单位为sone。</p><p>1sone&#x3D;1kHz的正弦波在40dB SPL的响度。声压级增大10dB SPL，感受到的响度用sone表示会变为原来的2倍。</p><p>对于人耳，同声压级的一些频率比另一些频率听上去会更响，因此人们测量得到了等响度曲线，并定义</p><p>1phon&#x3D;1dB SPL的1kHz纯音</p><p><img src="/../images/image-20230904140147498.png" alt="image-20230904140147498"></p><p>声级表运用“计权滤波器”来补偿频率的相关性，其中A计权标度多用于环境噪声测量，BBC给出的ITU-R468标度用于广播和母带的处理。</p>        <h4 id="时域积分效应"   >          <a href="#时域积分效应" class="heading-link"><i class="fas fa-link"></i></a><a href="#时域积分效应" class="headerlink" title="时域积分效应"></a>时域积分效应</h4>      <p>对于200ms以内的持续时间，通过将声音拉长一些毫秒，就可以使它们具有更大的表观音量。</p>        <h3 id="音域"   >          <a href="#音域" class="heading-link"><i class="fas fa-link"></i></a><a href="#音域" class="headerlink" title="音域"></a>音域</h3>      <ul><li><strong>低音bass</strong><ul><li><strong>次低音sub</strong>：多用于给雷声等音响效果增加深度</li><li><strong>上低音upper bass</strong>：底鼓，贝斯基频，钢琴与吉他较低的八度</li></ul></li><li><strong>中音mid</strong>：人声，弦乐，铜管的最佳音区</li><li><strong>高音treble</strong><ul><li><strong>临场感presence</strong>：为人声和乐器增加清晰度</li><li><strong>上方top</strong>：镲片，类噪声音</li><li><strong>空气感air</strong>：所有最高泛音</li></ul></li></ul><p><img src="/../images/image-20230906090620166.png" alt="image-20230906090620166"></p>        <h3 id="分辨率"   >          <a href="#分辨率" class="heading-link"><i class="fas fa-link"></i></a><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3>      <p>人耳可以区分100Hz和105Hz的区别，但无法区分16000Hz和16005Hz的区别。</p>        <h3 id="频谱"   >          <a href="#频谱" class="heading-link"><i class="fas fa-link"></i></a><a href="#频谱" class="headerlink" title="频谱"></a>频谱</h3>      <p><strong>音色timbre</strong>是对频谱的主观感知量，是由一个稳定频谱产生的瞬时的听觉感受。</p>        <h4 id="明亮度"   >          <a href="#明亮度" class="heading-link"><i class="fas fa-link"></i></a><a href="#明亮度" class="headerlink" title="明亮度"></a>明亮度</h4>      <p>将具有一些较响的高频并不足以让一个声音明亮，声音的明亮度取决于<strong>频谱质心</strong>，以及<strong>起音attack</strong>。</p>        <h4 id="对时域结构的感知"   >          <a href="#对时域结构的感知" class="heading-link"><i class="fas fa-link"></i></a><a href="#对时域结构的感知" class="headerlink" title="对时域结构的感知"></a>对时域结构的感知</h4>              <h3 id="包络envelope"   >          <a href="#包络envelope" class="heading-link"><i class="fas fa-link"></i></a><a href="#包络envelope" class="headerlink" title="包络envelope"></a>包络envelope</h3>      <p>在声音设计中通常用四个词描述一个声音的包络：</p><ul><li>起音attack</li><li>衰减decay</li><li>延音sustain</li><li>释音release</li></ul>        <h4 id="Attack"   >          <a href="#Attack" class="heading-link"><i class="fas fa-link"></i></a><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h4>      <p>在这个阶段，声音从0开始上升到最大能量处。对于打击型声音，这个起音非常短；对于琴弦，可以长达几秒钟。</p><p>从斜面滑落空气的物体可以模拟起音的过程，该物体持续加速，同时摩擦激励产生一个越来越响的声音。</p>        <h4 id="Decay"   >          <a href="#Decay" class="heading-link"><i class="fas fa-link"></i></a><a href="#Decay" class="headerlink" title="Decay"></a>Decay</h4>      <p>衰减应用于那些在瞬变阶段后有能量持续供应的系统上。</p>        <h4 id="Sustain"   >          <a href="#Sustain" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sustain" class="headerlink" title="Sustain"></a>Sustain</h4>      <p>在这个阶段，系统的输入能量等于输出能量。</p>        <h4 id="Release"   >          <a href="#Release" class="heading-link"><i class="fas fa-link"></i></a><a href="#Release" class="headerlink" title="Release"></a>Release</h4>      <p>系统不再接受能量，只通过存储的能量产生一段声音。对于运动物体，这个数值对应于动量，对于流体则对应于存储能力。</p>        <h3 id="哈斯效应"   >          <a href="#哈斯效应" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈斯效应" class="headerlink" title="哈斯效应"></a>哈斯效应</h3>      <p>又称先入为主效应，决定了我们在何处区分环境与声源。</p><p>大约30ms后接受到的反射声将被分配给环境，被听成单独的回声，比如在大厅里击掌产生的回声；发生在30ms内的反射声被融合到这个声音本身中，比如古典吉他的空腔内产生的回声</p>        <h3 id="Gabor极限"   >          <a href="#Gabor极限" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gabor极限" class="headerlink" title="Gabor极限"></a>Gabor极限</h3>      <p>Gabor极限标出了一个声音具有音高所需的最小持续时间，大约在10~20ms。</p>        <h1 id="吉他"   >          <a href="#吉他" class="heading-link"><i class="fas fa-link"></i></a><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h1>              <h1 id="合成器"   >          <a href="#合成器" class="heading-link"><i class="fas fa-link"></i></a><a href="#合成器" class="headerlink" title="合成器"></a>合成器</h1>              <h2 id="放大器Amplifier"   >          <a href="#放大器Amplifier" class="heading-link"><i class="fas fa-link"></i></a><a href="#放大器Amplifier" class="headerlink" title="放大器Amplifier"></a>放大器Amplifier</h2>              <h2 id="振荡器Oscillator"   >          <a href="#振荡器Oscillator" class="heading-link"><i class="fas fa-link"></i></a><a href="#振荡器Oscillator" class="headerlink" title="振荡器Oscillator"></a>振荡器Oscillator</h2>              <h3 id="音频振荡器"   >          <a href="#音频振荡器" class="heading-link"><i class="fas fa-link"></i></a><a href="#音频振荡器" class="headerlink" title="音频振荡器"></a>音频振荡器</h3>      <p>用于产生音频，不同波形会产生不同音色timbre的声音，振幅影响响度</p>        <h3 id="低频振荡器（LFO）"   >          <a href="#低频振荡器（LFO）" class="heading-link"><i class="fas fa-link"></i></a><a href="#低频振荡器（LFO）" class="headerlink" title="低频振荡器（LFO）"></a>低频振荡器（LFO）</h3>      <p>用于调制某个音频，让一个参数（音高，音量等）来回振荡，使音频的某些特性随时间变化。<br>慢速的调制通常用作改变行为（声音的表现），而快速调制则用来改变音色（声音本身的特征）</p>        <h2 id="滤波器Filter"   >          <a href="#滤波器Filter" class="heading-link"><i class="fas fa-link"></i></a><a href="#滤波器Filter" class="headerlink" title="滤波器Filter"></a>滤波器Filter</h2>      <ul><li><p>Low-Pass Filter低通滤波器</p><p><img src="/../images/image-20230912205725143.png" alt="image-20230912205725143"></p><ul><li>Resonance：共振，增强截止频率周围的振幅</li><li>Frequency：滤波器的截止频率</li></ul></li></ul>        <h2 id="合成弹拨贝斯"   >          <a href="#合成弹拨贝斯" class="heading-link"><i class="fas fa-link"></i></a><a href="#合成弹拨贝斯" class="headerlink" title="合成弹拨贝斯"></a>合成弹拨贝斯</h2>      <div style='display:flex;width:100%;'><img style='width:50%;' src='../images/image-20230912210218103.png' /><img style='width:50%;' src='../images/image-20230912210242942.png' /></div><p>声音的”弹拨”性是由包络调制滤波器而生成的。 这会导致滤波器快速开合和关闭。</p>        <h3 id="音高失谐detune"   >          <a href="#音高失谐detune" class="heading-link"><i class="fas fa-link"></i></a><a href="#音高失谐detune" class="headerlink" title="音高失谐detune"></a>音高失谐detune</h3>      <ul><li><p>cents音分：一音分等于半音的百分之一</p></li><li><p>semitone半音</p><p>12semitone&#x3D;1个八度</p></li></ul>        <h2 id="噪声发生器"   >          <a href="#噪声发生器" class="heading-link"><i class="fas fa-link"></i></a><a href="#噪声发生器" class="headerlink" title="噪声发生器"></a>噪声发生器</h2>      <p>噪声发生器会生成没有音高的声音，可以用来模拟风或雨的声音。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;音乐学习相关的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="音乐" scheme="https://lzmustb.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="音乐" scheme="https://lzmustb.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>安装与配置MySQL(Ubuntu)</title>
    <link href="https://lzmustb.github.io/2023/06/26/MySQL_commands/"/>
    <id>https://lzmustb.github.io/2023/06/26/MySQL_commands/</id>
    <published>2023-06-26T00:06:00.000Z</published>
    <updated>2023-09-25T12:55:46.067Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="安装mysql"   >          <a href="#安装mysql" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></div></figure><span id="more"></span>        <h2 id="查看mysql是否安装成功"   >          <a href="#查看mysql是否安装成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看mysql是否安装成功" class="headerlink" title="查看mysql是否安装成功"></a>查看mysql是否安装成功</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></div></figure>        <h2 id="设置root用户的密码"   >          <a href="#设置root用户的密码" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置root用户的密码" class="headerlink" title="设置root用户的密码"></a>设置root用户的密码</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql #登录mysql服务器</span><br></pre></td></tr></table></div></figure><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>指令:</span><br><span class="line"><span class="comment">/*将new_password部分替换为你的新密码*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">/*更新用户权限*/</span></span><br><span class="line">FLUSH PRIVILEGES; </span><br><span class="line"><span class="comment">/*退出sql命令行*/</span></span><br><span class="line">exit</span><br></pre></td></tr></table></div></figure>        <h2 id="查看mysql服务器运行状态"   >          <a href="#查看mysql服务器运行状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看mysql服务器运行状态" class="headerlink" title="查看mysql服务器运行状态"></a>查看mysql服务器运行状态</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql status</span><br></pre></td></tr></table></div></figure><p>如果MySQL正在运行，将显示”active (running)”</p>        <h2 id="启动mysql服务器"   >          <a href="#启动mysql服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#启动mysql服务器" class="headerlink" title="启动mysql服务器"></a>启动mysql服务器</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></div></figure>        <h2 id="本地连接mysql服务器"   >          <a href="#本地连接mysql服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地连接mysql服务器" class="headerlink" title="本地连接mysql服务器"></a>本地连接mysql服务器</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u &lt;username&gt; -p</span><br></pre></td></tr></table></div></figure><p>将<code>&lt;username&gt;</code>替换为用户名(未创建新用户则填root)</p>        <h2 id="查看MySQL服务器的ip地址"   >          <a href="#查看MySQL服务器的ip地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看MySQL服务器的ip地址" class="headerlink" title="查看MySQL服务器的ip地址"></a>查看MySQL服务器的ip地址</h2>      <p>通常主机外网ip即为服务器ip地址</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig #linux</span><br></pre></td></tr></table></div></figure>        <h2 id="配置MySQL服务器远程连接"   >          <a href="#配置MySQL服务器远程连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置MySQL服务器远程连接" class="headerlink" title="配置MySQL服务器远程连接"></a>配置MySQL服务器远程连接</h2>              <h3 id="编辑配置文件’mysqld-cnf’"   >          <a href="#编辑配置文件’mysqld-cnf’" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑配置文件’mysqld-cnf’" class="headerlink" title="编辑配置文件’mysqld.cnf’"></a>编辑配置文件’mysqld.cnf’</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></div></figure><p>在 <code>mysqld.cnf</code> 文件中找到 <code>bind-address</code> 选项，并将其注释掉或将其值设置为MySQL服务器的IP地址。默认情况下，此选项被设置为 <code>127.0.0.1</code>，只允许本地连接。如果要允许远程连接，请将其修改为服务器的实际IP地址或注释掉该行。例如：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind-address = 127.0.0.1</span><br></pre></td></tr></table></div></figure><p>保存并关闭<code>mysqld.cnf</code>文件（ctrl+x）</p>        <h3 id="重启MySQL服务器以应用更改"   >          <a href="#重启MySQL服务器以应用更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#重启MySQL服务器以应用更改" class="headerlink" title="重启MySQL服务器以应用更改"></a>重启MySQL服务器以应用更改</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></div></figure>        <h3 id="创建或授予远程访问权限"   >          <a href="#创建或授予远程访问权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建或授予远程访问权限" class="headerlink" title="创建或授予远程访问权限"></a>创建或授予远程访问权限</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></div></figure><p>进入sql命令行</p><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*显示MySQL服务器上所有用户列表*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, host <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></div></figure><p>如果有用户拥有<code>%</code>主机的访问权限，则该用户可以进行远程访问。如果没有，则授予权限</p><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*替换&lt;password&gt;（包括大小于号）*/</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;&lt;password&gt;&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*刷新用户权限*/</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></div></figure><p>或创建新用户：</p><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*替换&lt;username&gt;和&lt;password&gt;（包括大小于号）*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;&lt;password&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*授予新用户对所有数据库的完全权限*/</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*刷新用户权限*/</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></div></figure>        <h2 id="查看MySQL服务器端口"   >          <a href="#查看MySQL服务器端口" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看MySQL服务器端口" class="headerlink" title="查看MySQL服务器端口"></a>查看MySQL服务器端口</h2>      <p>默认为3306，若进行了自定义设置可在<strong>sql命令行</strong>使用以下指令</p><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;port&#x27;</span>;</span><br></pre></td></tr></table></div></figure>        <h2 id="关闭Ubuntu防火墙"   >          <a href="#关闭Ubuntu防火墙" class="heading-link"><i class="fas fa-link"></i></a><a href="#关闭Ubuntu防火墙" class="headerlink" title="关闭Ubuntu防火墙"></a>关闭Ubuntu防火墙</h2>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">sudo ufw disable</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看防火墙状态，若显示<span class="string">&#x27;Status:inactive&#x27;</span>则关闭成功</span></span><br><span class="line">sudo ufw status</span><br></pre></td></tr></table></div></figure>        <h1 id="MySQL语言"   >          <a href="#MySQL语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL语言" class="headerlink" title="MySQL语言"></a>MySQL语言</h1>      ]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装mysql&quot;   &gt;
          &lt;a href=&quot;#安装mysql&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#安装mysql&quot; class=&quot;headerlink&quot; title=&quot;安装mysql&quot;&gt;&lt;/a&gt;安装mysql&lt;/h2&gt;
      &lt;figure class=&quot;highlight shell&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install mysql-server	&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>《献给阿尔吉侬的花束》</title>
    <link href="https://lzmustb.github.io/2023/02/25/read-Flowers-for-Algernon/"/>
    <id>https://lzmustb.github.io/2023/02/25/read-Flowers-for-Algernon/</id>
    <published>2023-02-25T02:20:54.000Z</published>
    <updated>2023-09-25T13:03:19.304Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="引言"   >          <a href="#引言" class="heading-link"><i class="fas fa-link"></i></a><a href="#引言" class="headerlink" title="引言"></a>引言</h2>      <blockquote><p>箱子里有迷宫。</p><p>你在错综复杂的道路上前行。</p><p>你相信墙的另一侧一定有些什么，</p><p>时而失道却坚定地向着出口前进。</p><p>这身影对我有些耀眼。(阿尔吉侬)就是这样的一首曲子。</p><p style="text-align:right">——n-buna</p></blockquote><span id="more"></span><p>前段时间听夜鹿新曲<span class="exturl"><a class="exturl__link"   href="https://music.163.com/#/song?id=2020247157" >アルジャーノン(阿尔吉侬)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>得知其原型是科幻巨著《献给阿尔吉侬的花束》。</p><p>小说从主人公 查理·高登 的自述开始。通过没有逗号、错别字满篇的报告得知，他是一名30多岁的智力障碍者，在面包店做些清扫工作，同时在低能成人学校努力学习。他想变聪明，想让面包店的同事高兴，想理解他的朋友们所谈论的话题，并参与其中。</p><p>后来，他被带到声称能改造智力的科学实验室中，在那里遇到了高智商老鼠 阿尔吉侬。阿尔吉侬是唯一一个实验成功的老鼠，它快速走出迷宫的样子令查理感到无比的惊讶和敬佩。</p><p>科学家和医生看到查理天性善良，又有上进心，认为他是人体实验的不二之选。查理接受了手术，变成了天才。然而，等待他的不是为他自豪的朋友，而是他不曾体会的复杂世界。</p><p><font color='scarlet'><strong>※以下涉及剧透</strong></font></p>        <h2 id="人物关系图"   >          <a href="#人物关系图" class="heading-link"><i class="fas fa-link"></i></a><a href="#人物关系图" class="headerlink" title="人物关系图"></a>人物关系图</h2>      <p><img src="https://cdn.jsdelivr.net/gh/LzmUSTB/BlogImages/flowersForAlgernon.png" alt="flowersForAlgernon"></p>        <h2 id="“比拥有高智商更重要的事”"   >          <a href="#“比拥有高智商更重要的事”" class="heading-link"><i class="fas fa-link"></i></a><a href="#“比拥有高智商更重要的事”" class="headerlink" title="“比拥有高智商更重要的事”"></a>“比拥有高智商更重要的事”</h2>      <p>在智力的飞速发展下，查理很快便掌握多门语言，读通最前沿的科学论文。一开始，他以为这就是正常人的世界，但此时的查理和其他人之间的隔阂却和手术前一样大。查理不能忍受尼姆等人追求名利，他在公开场合说的话虽然理性而正确，但让这些科学家们难堪。</p><p>高智商让他察觉人性中的丑恶，但却没有给他宽容这些丑恶的人情。</p><blockquote><p>但我可以告诉你一件事，在你手术之前，你并不是这个样子。你不会在自己的秽物中打滚，不会沉迷于自怜，不会整天整夜坐在电视机前污染自己的心灵，更不会大声对别人咆哮。你有些令我们尊敬的特质……没错，即使是过去的你。你身上有些我从来没有在其他弱智者身上见过的特别东西。</p><p style="text-align:right">——艾丽斯·纪尼安</p></blockquote>        <h2 id="献给阿尔吉侬"   >          <a href="#献给阿尔吉侬" class="heading-link"><i class="fas fa-link"></i></a><a href="#献给阿尔吉侬" class="headerlink" title="献给阿尔吉侬"></a>献给阿尔吉侬</h2>      <p>查理得知留给自己的时间不长后，把所有精力花在研究他自身发生的变化上。他并没有用他梦寐以求的聪明去做自己想做的事，而是用昙花一现的人类最高智力，去推进科学发展，为未来其他智障者开辟道路。</p><blockquote><p>我把阿尔吉侬的尸体放在一个小金属容器里带回家，我不会让他们把它丢进焚化炉。这样做有些愚蠢和伤感，但昨天深夜我把它埋在后院。把一束野花放在坟上时，我哭了起来。</p></blockquote><hr>        <h2 id="我"   >          <a href="#我" class="heading-link"><i class="fas fa-link"></i></a><a href="#我" class="headerlink" title="我"></a>我</h2>      <p>这本小说中会出现很多<strong>错字</strong>，但正是这一巧妙的设计让读者看到一个有血有肉的残疾人的一生。</p><p>我和查理没有什么共同点可言，无论是在他做手术前，还是之后。我想象自己如果在书中是个什么样的位置，最后发现可能只是面包店里默默工作的一员。我不会嘲笑和捉弄查理，也不会在他变成高智商时排挤他。但我的篇幅一定不会比金皮或者乔更多。或许查理会主动和我敞开心扉，而我多半对此爱莫能助；或许我从头到尾都不会知道查理对命运的伟大抗争。</p><p>全世界有7%左右的残疾人，其中智力残疾比肢体残疾要少一些。在我的20多年人生中，擦肩而过的可能有10来个，但不曾接触过他们中的任何人。我自认为与人交流时有注意不让对方尴尬难堪，但或许我并不比那些为残障机构捐款却从不与他们交流的富豪更有同情心。我自认为对任何人都没有歧视和偏见，但我实际能做到的只是表示理解，却不能提供真正的帮助。</p><p>我的心灵是一块开阔却贫瘠的土地，不会拒绝踏入的脚印，但也找不着一束可以献上的花。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;   &gt;
          &lt;a href=&quot;#引言&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
      &lt;blockquote&gt;
&lt;p&gt;箱子里有迷宫。&lt;/p&gt;
&lt;p&gt;你在错综复杂的道路上前行。&lt;/p&gt;
&lt;p&gt;你相信墙的另一侧一定有些什么，&lt;/p&gt;
&lt;p&gt;时而失道却坚定地向着出口前进。&lt;/p&gt;
&lt;p&gt;这身影对我有些耀眼。(阿尔吉侬)就是这样的一首曲子。&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt;——n-buna&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://lzmustb.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="感想" scheme="https://lzmustb.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>并发/并行&amp;同步/异步</title>
    <link href="https://lzmustb.github.io/2022/11/05/my-programing-note1/"/>
    <id>https://lzmustb.github.io/2022/11/05/my-programing-note1/</id>
    <published>2022-11-05T03:17:20.000Z</published>
    <updated>2023-09-08T01:01:42.438Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="并发vs并行"   >          <a href="#并发vs并行" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发vs并行" class="headerlink" title="并发vs并行"></a>并发vs并行</h1>              <h2 id="并发-Concurrency"   >          <a href="#并发-Concurrency" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发-Concurrency" class="headerlink" title="并发(Concurrency)"></a>并发(Concurrency)</h2>      <p>并发是一个宽泛概念，表示计算机同时执行多项任务。</p><p>对于单核处理器，可以通过分配时间片的方式（又称上下文切换context switching）</p>        <h2 id="并行-Parallelism"   >          <a href="#并行-Parallelism" class="heading-link"><i class="fas fa-link"></i></a><a href="#并行-Parallelism" class="headerlink" title="并行(Parallelism)"></a>并行(Parallelism)</h2>      <p>在多核处理器中，真正意义上同时执行多项任务。</p><span id="more"></span>        <h1 id="同步vs异步"   >          <a href="#同步vs异步" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步vs异步" class="headerlink" title="同步vs异步"></a>同步vs异步</h1>              <h2 id="同步编程-Synchronous"   >          <a href="#同步编程-Synchronous" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步编程-Synchronous" class="headerlink" title="同步编程(Synchronous)"></a>同步编程(Synchronous)</h2>      <p>在执行完一项任务后才执行下一项任务，没有并发并行的概念</p>        <h2 id="异步编程-Async"   >          <a href="#异步编程-Async" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步编程-Async" class="headerlink" title="异步编程(Async)"></a>异步编程(Async)</h2>      <p>在<strong>单线程中</strong>同时执行多个任务的编程方式。无需考虑线程同步，线程竞争的问题。</p><p>适用于有网络操作，数据库访问等I&#x2F;O密集的应用程序。如果使用多线程，线程中的大部分时间在等待，反而浪费了线程切换和线程内存的开销。多线程适合计算量大的程序。</p>        <h3 id="Javascript"   >          <a href="#Javascript" class="heading-link"><i class="fas fa-link"></i></a><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3>      <p>Js中实现异步的方法有callback，Promise，async&#x2F;await</p>        <h4 id="async-x2F-await"   >          <a href="#async-x2F-await" class="heading-link"><i class="fas fa-link"></i></a><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4>      <p>async将函数标记为异步函数，返回值为Promise对象。在async函数中可以调用await标记的异步函数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;并发vs并行&quot;   &gt;
          &lt;a href=&quot;#并发vs并行&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#并发vs并行&quot; class=&quot;headerlink&quot; title=&quot;并发vs并行&quot;&gt;&lt;/a&gt;并发vs并行&lt;/h1&gt;
      
        &lt;h2 id=&quot;并发-Concurrency&quot;   &gt;
          &lt;a href=&quot;#并发-Concurrency&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#并发-Concurrency&quot; class=&quot;headerlink&quot; title=&quot;并发(Concurrency)&quot;&gt;&lt;/a&gt;并发(Concurrency)&lt;/h2&gt;
      &lt;p&gt;并发是一个宽泛概念，表示计算机同时执行多项任务。&lt;/p&gt;
&lt;p&gt;对于单核处理器，可以通过分配时间片的方式（又称上下文切换context switching）&lt;/p&gt;

        &lt;h2 id=&quot;并行-Parallelism&quot;   &gt;
          &lt;a href=&quot;#并行-Parallelism&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#并行-Parallelism&quot; class=&quot;headerlink&quot; title=&quot;并行(Parallelism)&quot;&gt;&lt;/a&gt;并行(Parallelism)&lt;/h2&gt;
      &lt;p&gt;在多核处理器中，真正意义上同时执行多项任务。&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://lzmustb.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="编程" scheme="https://lzmustb.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
